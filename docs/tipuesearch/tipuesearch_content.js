var tipuesearch = {"pages":[{"tags":"","title":" Fortran Program ","text":"Fortran Program Developer Info Leon Foks I do cool things in Fortran. (I think)","loc":"index.html"},{"tags":"","title":"m_array1D.f90 – Fortran Program","text":"Modules m_array1D Source Code m_array1D.f90 Source Code module m_array1D !! 1D array routines !! !! See !! [[arange]], [[diff]], [[isSorted]], [[repeat]] !! for more information. use variableKind , only : r32 , r64 , i32 , i64 use m_allocate , only : allocate implicit none private public arange interface arange !! Create a 1D array from start to stop in given increments of 1 or optionally step !! !! Example Usage !!```fortran !!program arangeTest !!use variableKind, only: i32,i64,r32,r64 !!use m_allocatable, only: allocatable !!use m_array1D, only: arange !!real(r32), allocatable :: a(:) !!integer(i32), allocatable :: b(:) !!real(r64), allocatable :: c(:) !!integer(i64), allocatable :: d(:) !!integer :: N !!N = 10000 !!call allocate(a, N) !!call allocate(b, N) !!call allocate(c, N) !!call allocate(d, N) !! !!call arange(a, 1, N) !!call arange(b, 1, N) !!call arange(c, 1, N) !!call arange(d, 1, N) !! !!call deallocate(a) !!call deallocate(b) !!call deallocate(c) !!call deallocate(d) !! !!end program !!``` module subroutine arange_r1D ( res , start , stp , step ) !! Interfaced with [[arange]] real ( r32 ), intent ( in ) :: start !! Start from here real ( r32 ), intent ( in ) :: stp !! Stop here real ( r32 ), optional , intent ( in ) :: step !! Step size real ( r32 ), allocatable , intent ( inout ) :: res (:) end subroutine module subroutine arange_d1D ( res , start , stp , step ) !! Interfaced with [[arange]] real ( r64 ), intent ( in ) :: start !! Start from here real ( r64 ), intent ( in ) :: stp !! Stop here real ( r64 ), optional , intent ( in ) :: step !! Step size real ( r64 ), allocatable , intent ( inout ) :: res (:) end subroutine module subroutine arange_i1D ( res , start , stp , step ) !! Interfaced with [[arange]] integer ( i32 ), intent ( in ) :: start !! Start from here integer ( i32 ), intent ( in ) :: stp !! Stop here integer ( i32 ), optional , intent ( in ) :: step !! Step size integer ( i32 ), allocatable , intent ( inout ) :: res (:) end subroutine module subroutine arange_id1D ( res , start , stp , step ) !! Interfaced with [[arange]] integer ( i64 ), intent ( in ) :: start !! Start from here integer ( i64 ), intent ( in ) :: stp !! Stop here integer ( i64 ), optional , intent ( in ) :: step !! Step size integer ( i64 ), allocatable , intent ( inout ) :: res (:) end subroutine end interface public :: diff interface diff !! Compute the difference along an array !! !! Example Usage !!```fortran !!program arangeTest !!use variableKind, only: i32,i64,r32,r64 !!use m_allocatable, only: allocatable !!use m_array1D, only: arange, diff !!real(r32), allocatable :: a(:) !!integer(i32), allocatable :: b(:) !!real(r64), allocatable :: c(:) !!integer(i64), allocatable :: d(:) !!integer :: N !!N = 10000 !!call allocate(a, N) !!call allocate(b, N) !!call allocate(c, N) !!call allocate(d, N) !! !!call arange(a, 1, N) !!call arange(b, 1, N) !!call arange(c, 1, N) !!call arange(d, 1, N) !! !!call diff(a, 1, N) !!call diff(b, 1, N) !!call diff(c, 1, N) !!call diff(d, 1, N) !! !!call deallocate(a) !!call deallocate(b) !!call deallocate(c) !!call deallocate(d) !! !!end program !!``` module subroutine diff_r1D ( this , res ) !! Interfaced with [[diff]] real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res (:) !! Difference along array end subroutine module subroutine diff_d1D ( this , res ) !! Interfaced with [[diff]] real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res (:) !! Difference along array end subroutine module subroutine diff_i1D ( this , res ) !! Interfaced with [[diff]] integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res (:) !! Difference along array end subroutine module subroutine diff_id1D ( this , res ) !! Interfaced with [[diff]] integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res (:) !! Difference along array end subroutine end interface public isSorted interface isSorted !! Check that a 1D array is sorted !! !! Example Usage !!```fortran !!program arangeTest !!use variableKind, only: i32,i64,r32,r64 !!use m_allocatable, only: allocatable !!use m_array1D, only: arange, isSorted !!real(r32), allocatable :: a(:) !!integer(i32), allocatable :: b(:) !!real(r64), allocatable :: c(:) !!integer(i64), allocatable :: d(:) !!integer :: N !!N = 10000 !!call allocate(a, N) !!call allocate(b, N) !!call allocate(c, N) !!call allocate(d, N) !! !!call arange(a, 1, N) !!call arange(b, 1, N) !!call arange(c, 1, N) !!call arange(d, 1, N) !! !!call diff(a, 1, N) !!call diff(b, 1, N) !!call diff(c, 1, N) !!call diff(d, 1, N) !! !!call deallocate(a) !!call deallocate(b) !!call deallocate(c) !!call deallocate(d) !! !!end program !!``` module function isSorted_r1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] real ( r32 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_d1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] real ( r64 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_i1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] integer ( i32 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_id1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] integer ( i64 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function end interface public repeat interface repeat !! Repeat each element nRepeat times module subroutine repeat_r1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated real ( r32 ), allocatable :: res (:) end subroutine module subroutine repeat_d1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated real ( r64 ), allocatable :: res (:) end subroutine module subroutine repeat_i1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated integer ( i32 ), allocatable :: res (:) end subroutine module subroutine repeat_id1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated integer ( i64 ), allocatable :: res (:) end subroutine end interface !  interface isConstant !  module procedure :: isConstant_DV !  end interface !  private :: isConstant_DV ! !  interface isConstantIncrement !  module procedure :: isConstantIncrement_DV !  end interface !  private :: isConstantIncrement_DV ! !  interface isInside !  module procedure :: isInside1D_I1,isInside1D_D1 !  end interface ! !  interface getBin !  module procedure :: getBin1D_I1,getBin1D_D1 !  end interface ! !  interface scale !  module procedure :: scaleVector !  end interface ! !  interface deintegerize !  module procedure :: deintegerizeVector !  end interface !  private :: deintegerizeVector ! !  private :: isInside1D_I1,isInside1D_D1 !  private :: getBin1D_I1,getBin1D_D1 ! !  interface mapExponential !  module procedure :: mapExponential_1D !  end interface !  private :: mapExponential_1D ! !  interface unitize !  module procedure :: unitize_1D !  end interface !  private :: unitize_1D end module","loc":"sourcefile/m_array1d.f90.html"},{"tags":"","title":"m_allocate.f90 – Fortran Program","text":"Modules m_allocate Source Code m_allocate.f90 Source Code module m_allocate !! Contains fundamental interface to allocate allocatable arrays of different types and shapes !! !! See [[allocate]] for more information. use variableKind use m_errors , only : eMsg , mErr implicit none private public allocate interface allocate !! Allocate an allocatable array. If the array is already allocated, memory is reallocated to the given size, unless no size change will occur. !! The allocated memory is NOT initialized to any value, so be sure to do so afterwards if you call allocate. !! !! Does not overload the intrinsic allocate function. !! !! This way, calling allocate makes the user aware that checks are being made, and memory will be re-allocated. !! !! Checks for an error during allocation, and will stop the code if there is one. !! !! Example usage !!```fortran !!use variableKind !!use m_allocate, only: allocate !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!call allocate(a1D, 20) !!call allocate(a2D, [20,20]) !!call allocate(a3D, [20,20,20]) !!write(*,'(a)') 'Shape of a3D is [20,20,20]? '//all(shape(a3D) == [20,20,20]) !!``` !====================================================================! module subroutine allocate_r1D ( this , n ) !====================================================================! !!Interfaced with [[allocate]] real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_r2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_r3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_d1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_d2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_d3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_i1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_i2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_i3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_id1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_id2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_id3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_c1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_c2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_c3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_z1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_z2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_z3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_l1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_l2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] logical , allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_l3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] logical , allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! end interface contains !====================================================================! module subroutine allocate_r1D ( this , n ) !!Interfaced with  [[allocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_r1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_r2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_r2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_r3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_r3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_d1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_d1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_d2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_d2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_d3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_d3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_i1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_i1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_i2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_i2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_i3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_i3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_id1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_id1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_id2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_id2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_id3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_id3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_c1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_c1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_c2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_c2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_c3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_c3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_z1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_z1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_z2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_z2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_z3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_z3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_l1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_l1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_l2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_l2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_l3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_l3D:this' , 1 ) end subroutine !====================================================================! end module","loc":"sourcefile/m_allocate.f90.html"},{"tags":"","title":"m_compare.f90 – Fortran Program","text":"Modules m_compare Source Code m_compare.f90 Source Code module m_compare use variableKind implicit none interface compare module procedure :: compare_d1 end interface contains function compare_d1 ( this , that ) result ( res ) real ( r64 ) :: this real ( r64 ) :: that integer ( i32 ) :: res if ( this < that ) then res = - 1 elseif ( this > that ) then res = 1 else res = 0 end if end function end module","loc":"sourcefile/m_compare.f90.html"},{"tags":"","title":"m_copy.f90 – Fortran Program","text":"Modules m_copy Source Code m_copy.f90 Source Code module m_copy !! Contains fundamental routines to copy arrays to new memory locations while maintaining both copies !! !! See [[copy]] for more information. use variableKind use m_errors , only : mErr , eMsg use m_allocate , only : allocate private public copy interface copy !! Copies an array to new memory (no pointers), The output array size will be changed to match the copy. !! !! Example usage !!```fortran !!use variableKind, only: r64 !!use m_allocate, only: allocate !!use m_copy, only: copy !! !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!real(r64),allocatable :: b1D(:), b2D(:,:), b3D(:,:,:) !!call allocate(a1D, 20) !!call allocate(a2D, [20,20]) !!call allocate(a3D, [20,20,20]) !!a1D = 1.d0 !!a2D = 2.d0 !!a3D = 3.d0 !!call copy(a1D, b1D) !!call copy(a2D, b2D) !!call copy(a3D, b3D) !!write(*,'(a)') 'a1D equals b1D: '//str(all(a1D == b1D)) !!write(*,'(a)') 'a2D equals b2D: '//str(all(a2D == b2D)) !!write(*,'(a)') 'a3D equals b3D: '//str(all(a3D == b3D)) !!call deallocate(a1D) !!call deallocate(a2D) !!call deallocate(a3D) !!call deallocate(b1D) !!call deallocate(b2D) !!call deallocate(b3D) !!``` !====================================================================! module subroutine copy_r1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_r2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_r3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_d1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_d2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_d3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_i1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_i2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_i3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_id1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_id2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_id3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_c1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_c2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_c3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_z1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_z2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_z3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_l1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_l2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_l3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! end interface contains !====================================================================! module subroutine copy_r1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_r1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_r2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_r2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_r3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_r3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_d1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_d1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_d2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_d2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_d3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_d3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_i1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_i1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_i2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_i2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_i3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_i3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_id1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_id1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_id2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_id2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_id3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_id3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_c1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_c1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_c2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_c2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_c3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_c3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_z1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_z1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_z2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_z2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_z3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_z3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_l1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_l1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_l2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_l2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_l3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_l3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! end module","loc":"sourcefile/m_copy.f90.html"},{"tags":"","title":"m_deallocate.f90 – Fortran Program","text":"Modules m_deallocate Source Code m_deallocate.f90 Source Code module m_deallocate !! Contains fundamental interface to deallocate allocatable arrays of different types and shapes. !! !! See [[deallocate]] for more information. use variableKind , only : r32 , r64 , i32 , i64 use m_errors , only : eMsg , mErr implicit none private public deallocate interface deallocate !! Deallocate an allocatable array. !! !! Contains fundamental routines to deallocate allocatable arrays of different types and shapes. !! Does not overload the intrinsic deallocate function. !! !! This way, calling deallocate makes the user aware that checks are being made and errors are handled with a message. !! !! Checks for an error during allocation, and will stop the code if there is one. !! !! Example usage !!```fortran !!use variableKind !!use m_allocate, only: allocate !!use m_deallocate, only: deallocate !! ! Could be other intrinsic types too, integer(i32), complex(r32), etc. !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!call allocate(a1D, 20) !!call allocate(a2D, [20,20]) !!call allocate(a3D, [20,20,20]) !!write(*,'(a)') 'Shape of a3D is [20,20,20]? '//all(shape(a3D) == [20,20,20]) !!call deallocate(a1D) !!call deallocate(a2D) !!call deallocate(a3D) !!``` !====================================================================! module subroutine deallocate_r1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! end interface contains !====================================================================! module subroutine deallocate_r1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_r1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_r2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_r3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_d1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_d2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_d3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_i1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_i2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_i3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_id1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_id2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_id3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_c1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_c2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_c3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_z1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_z2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_z3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_l1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_l2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_l3D:this' , 2 ) endif end subroutine !====================================================================! end module","loc":"sourcefile/m_deallocate.f90.html"},{"tags":"","title":"m_debugging.f90 – Fortran Program","text":"Modules m_debugging Source Code m_debugging.f90 Source Code module m_debugging !! Contains routines for debugging use variableKind use m_strings logical :: verbose = . false . !! Verbose option for debugging codes integer :: debugLevel !! Integer level for debug messages interface debug !! Interface for printing primitives with a name for debug purposes !! All may be called using 'call debug(args)' module procedure :: debug_d , debug_d1D , debug_i , debug_i1D end interface private :: debug_d , debug_d1D , debug_i , debug_i1D contains !====================================================================! subroutine debug_s ( name ) !====================================================================! character ( len =* ) :: name real ( r64 ) :: var if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_D ( name , var ) !====================================================================! character ( len =* ) :: name real ( r64 ) :: var if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_D1D ( name , var ) !====================================================================! character ( len =* ) :: name real ( r64 ) :: var (:) if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_I ( name , var ) !====================================================================! character ( len =* ) :: name integer ( i32 ) :: var if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_I1D ( name , var ) !====================================================================! character ( len =* ) :: name integer ( i32 ) :: var (:) if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! end module","loc":"sourcefile/m_debugging.f90.html"},{"tags":"","title":"m_errors.f90 – Fortran Program","text":"Modules m_errors Source Code m_errors.f90 Source Code module m_errors !!Module contains error handling procedures use iso_fortran_env , only : output_unit use variableKind implicit none contains !====================================================================! subroutine mErr ( istat , aMsg , alloc , iunit ) !! Checks for successful (de)allocation.  Stops the code. !! !! Use this after an allocate/deallocate statement !! allocate(x(nz,ny,nx), stat=istat); call mErr(istat,'x',1) !! deallocate(x, stat=istat); call mErr(istat,'x',2) !====================================================================! integer ( i32 ), intent ( in ) :: istat !! results of stat=istat in (de)allocate character ( len =* ), intent ( in ) :: aMsg !! Message associated with the (de)allocate integer ( i32 ), intent ( in ) :: alloc !! 1 = allocate, 2 = deallocate integer ( i32 ), intent ( in ), optional :: iunit !! Optional file id to write the message to character ( len = :), allocatable :: tmp ! If istat is not zero, there is an error. tmp = '' if ( istat /= 0 ) then select case ( alloc ) case ( 1 ) tmp = 'Allocating Memory: ' // trim ( aMsg ) case ( 2 ) tmp = 'Deallocating Memory: ' // trim ( aMsg ) end select call eMsg ( tmp , iunit ) endif end subroutine !====================================================================! !====================================================================! subroutine msg ( aMsg , iunit ) !! Write a message !====================================================================! character ( len =* ), intent ( in ) :: aMsg !! Message to write integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the message to if ( present ( iunit )) then write ( iunit , '(a)' ) trim ( aMsg ) write ( output_unit , '(a)' ) trim ( aMsg ) else write ( output_unit , '(a)' ) trim ( aMsg ) endif end subroutine !====================================================================! !====================================================================! subroutine wMsg ( aMsg , iunit ) !! Write a Warning message !====================================================================! character ( len =* ), intent ( in ) :: aMsg !! Message to write integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the message to call Msg ( 'Warning:' // trim ( aMsg ), iunit ) end subroutine !====================================================================! !====================================================================! subroutine eMsg ( aMsg , iunit ) !! Write an Error message. Stops the code !====================================================================! character ( len =* ), intent ( in ) :: aMsg !! Message to write integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the message to call Msg ( 'Error:' // trim ( aMsg ), iunit ) if ( present ( iunit )) close ( iunit ) stop end subroutine !====================================================================! !====================================================================! subroutine fErr ( istat , fname , flg , iunit ) !! Checks for a file error !====================================================================! integer ( i32 ), intent ( in ) :: istat !! Result of iostat=istat for open,read,write,close character ( len =* ), intent ( in ) :: fname !! Name of the file integer ( i32 ), intent ( in ) :: flg !! 1=Open, 2=Read, 3=Write, 4=Close integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the error to character ( len = :), allocatable :: Amsg Amsg = '' if ( istat /= 0 ) then select case ( flg ) case ( 1 ) Amsg = 'Opening file: ' // trim ( fname ) case ( 2 ) Amsg = 'Reading from: ' // trim ( fname ) case ( 3 ) Amsg = 'Writing to file: ' // trim ( fname ) case ( 4 ) Amsg = 'Closing file: ' // trim ( fname ) case default Amsg = 'Error:Invalid error flag [1-4]' end select call eMsg ( aMsg , iunit ) endif end subroutine !====================================================================! end module","loc":"sourcefile/m_errors.f90.html"},{"tags":"","title":"m_fileIO.f90 – Fortran Program","text":"Modules m_fileIO Source Code m_fileIO.f90 Source Code module m_fileIO !! Contains functions and subroutines that inquire and operate on files !! including reading and writing multiple entries to a file use variableKind , only : i32 , r64 use m_strings , only : compact , lowercase , isString , str use m_errors , only : Emsg , Ferr implicit none contains !====================================================================! function fileExists ( fName ) result ( yes ) !! Checks whether the file with name fName exists on disk !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name to check logical :: yes !! Exists? character ( len = len_trim ( fName )) :: this this = '' ; this = trim ( fName ) ! Inquire as to whether the file exists on disk or not inquire ( FILE = trim ( this ), EXIST = yes ) end function !====================================================================! !====================================================================! function hasExtension ( fName , extension ) result ( yes ) !====================================================================! !! Checks if a file 'fname' is of type 'extension' character ( len =* ), intent ( in ) :: fName !! File name character ( len = 3 ), intent ( in ) :: extension !! Extension to find logical :: yes !! Has this extension? ! Function Declarations integer ( i32 ) :: i , ilen ilen = len_trim ( fName ) i = scan ( fName , '.' ,. true .) ! Get the location of the dot ! If the three entries after the dot match, return yes yes = isString ( fName ( i + 1 : i + 3 ), extension ) end function !====================================================================! !====================================================================! subroutine checkIsOpen ( fName ) !! Checks whether a file is open with an error message if not !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name if (. not . isOpen ( fName )) call Ferr ( 1 , fName , 3 ) end subroutine !====================================================================! !====================================================================! function isOpen ( fname ) result ( yes ) !! Is the file open or not !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name logical :: yes !! Is the file open? inquire ( file = trim ( fname ), opened = yes ) end function !====================================================================! !====================================================================! subroutine openFile ( fname , iunit , stat , istat ) !! Open a file and perform necessary checks for failure !! stat should be 'new','old','unknown','append' !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( out ) :: iunit !! Unit number returned character ( len =* ), intent ( in ) :: stat !! Status of the file you are opening integer ( i32 ), intent ( out ) :: istat !! Error flag character ( len = len_trim ( fname )) :: this this = '' ; this = trim ( fname ) call compact ( this ) select case ( lowercase ( trim ( stat ))) case ( 'new' , 'old' , 'unknown' ) open ( newunit = iunit , file = trim ( this ), status = stat , iostat = istat ) case ( 'append' ) open ( newunit = iunit , file = trim ( this ), access = stat , status = 'old' , iostat = istat ) case default call Emsg ( 'openFile : Invalid status [new,old,unknown,append]' ) end select call Ferr ( istat , this , 1 ) end subroutine !====================================================================! !====================================================================! subroutine openBinaryFile ( fname , iunit , stat , istat ) !! Open an unformatted binary file !! stat should be 'new','old','unknown','append' !====================================================================! character ( len =* ), intent ( in ) :: fname !! File Name integer ( i32 ), intent ( out ) :: iunit !! Unit number returned character ( len =* ), intent ( in ) :: stat !! Status of the file you are opening integer ( i32 ), intent ( out ) :: istat !! Error Flag select case ( lowercase ( trim ( stat ))) case ( 'new' , 'old' , 'unknown' ) open ( newunit = iunit , file = trim ( fname ), form = 'unformatted' , status = stat , iostat = istat ) case ( 'append' ) open ( newunit = iunit , file = trim ( fname ), form = 'unformatted' , access = stat , status = 'old' , iostat = istat ) case default call Emsg ( 'openBinaryFile : Invalid status [new,old,unknown,append]' ) end select call Ferr ( istat , fname , 1 ) end subroutine !====================================================================! !====================================================================! subroutine closeFile ( fname , iunit , stat , istat ) !! Close a file and perform any necessary checks !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! Unit number returned character ( len =* ), intent ( in ) :: stat !! Status of the file you are closing integer ( i32 ), intent ( out ) :: istat !! Error Flag character ( len = len_trim ( fname )) :: this this = '' ; this = trim ( fname ) call compact ( this ) select case ( lowercase ( trim ( stat ))) case ( 'delete' ) close ( iunit , status = 'delete' , iostat = istat ) case default close ( iunit , iostat = istat ) end select call Ferr ( istat , this , 4 ) end subroutine !====================================================================! !====================================================================! subroutine deleteFile ( fname ) !! Deletes a file on disk !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name to delete integer ( i32 ) :: u , istat open ( newunit = u , file = fname , status = 'old' , iostat = istat ) if ( istat == 0 ) close ( u , status = 'delete' ) end subroutine !====================================================================! !====================================================================! function getFileSize ( fName ) result ( that ) !! Get the file size in Bytes !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name integer ( i32 ) :: that !! Size of the file that = 0 if (. not . fileExists ( fName )) return inquire ( file = trim ( fName ), size = that ) end function !====================================================================! !====================================================================! function getNFileLines ( fName , nHeader ) result ( N ) !! Counts the number of lines in a file after the number of specified header lines !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name integer ( i32 ), intent ( in ), optional :: nHeader ! Skip Lines !! Skip this number of lines at the top of the file integer ( i32 ) :: N !! Number of lines in the file integer ( i32 ) :: iunit , istat call openFile ( fName , iunit , 'old' , istat ) if ( present ( nHeader )) then if ( nHeader > 0 ) call skipFileLines ( iunit , nHeader ) endif N = 0 read ( iunit , '(a)' , iostat = istat ) do while ( istat == 0 ) N = N + 1 read ( iunit , '(a)' , iostat = istat ) enddo call closeFile ( fName , iunit , '' , istat ) end function !====================================================================! !====================================================================! subroutine skipFileLines ( iunit , N ) !! Skip N lines in a file !====================================================================! integer ( i32 ), intent ( in ) :: iunit !! Unit number to skip integer ( i32 ) , intent ( in ) :: N !! Number of lines to skip integer ( i32 ) :: i do i = 1 , N read ( iunit , * ) enddo end subroutine !====================================================================! !====================================================================! function getExtension ( fName ) result ( that ) !! Get the extension of a file !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name character ( len = :), allocatable :: that !! File extension integer ( i32 ) :: i , N N = len_trim ( fName ) i = scan ( fName , '.' ) if ( i == 0 ) call Emsg ( 'getExtension : Filename ' // trim ( fName ) // ' needs an extension (.txt?)' ) that = fName ( i + 1 : N ) end function !====================================================================! !====================================================================! function trimExtension ( fName ) result ( that ) !! Trims the extension of a filename !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name character ( len = :), allocatable :: that !! File name without the extension integer ( i32 ) :: i i = scan ( fName , '.' ); if ( i == 0 ) call Emsg ( 'trimExtension : Filename ' // trim ( fName ) // ' needs an extension (.txt?)' ) that = fName ( 1 : i - 1 ) end function !====================================================================! end module","loc":"sourcefile/m_fileio.f90.html"},{"tags":"","title":"m_format.f90 – Fortran Program","text":"Modules formatting Source Code m_format.f90 Source Code module formatting !! Contains routines that handle string formatting use variableKind , only : i32 implicit none contains !  !====================================================================! !  function getNFormats(N, formt) result(FMT) !    !! Create a format string with N times strings for writing on a single line !  !====================================================================! !  integer(i32), intent(in) :: N !! Number of times to repeat the format !  character(len=*), intent(in), optional :: formt !! Optional format to repeat !  character(len=20), intent(out) :: FMT !    !! Format statement with (N('a')) !  if (present(formt)) then !    write(FMT,'(\"(\",i0,a,\")\")') N,trim(formt) !  else !    write(FMT,'(\"(\",i0,\"(a))\")') N !  endif !  end function !  !====================================================================! end module","loc":"sourcefile/m_format.f90.html"},{"tags":"","title":"m_indexing.f90 – Fortran Program","text":"Modules m_indexing Source Code m_indexing.f90 Source Code module m_indexing !! Contains routines to obtain packed and unpacked indices into arrays use variableKind implicit none contains !====================================================================! function ind2sub ( iG , nSub ) result ( iSub ) !! Compute the indices in each dimension from the global index !====================================================================! integer ( i32 ), intent ( in ) :: iG !! Index into a global vector integer ( i32 ), intent ( in ) :: nSub (:) !! Size in each dimension integer ( i32 ) :: iSub ( size ( nSub )) !! Indices in each dimension to return integer ( i32 ) :: i , iGtmp , iTmp integer ( i32 ) :: nDims integer ( i32 ) :: prod nDims = size ( nSub ) if ( nDims == 1 ) then iSub ( 1 ) = iG return end if prod = product ( nSub ) iGtmp = iG do i = nDims , 1 , - 1 prod = prod / nSub ( i ) iTmp = mod ( iGtmp - 1 , prod ) + 1 iSub ( i ) = ( iGtmp - iTmp ) / prod + 1 iGtmp = iTmp end do end function !====================================================================! !====================================================================! function sub2ind ( iSub , nSub ) result ( iG ) !! Given component indices, get the global vector location. !====================================================================! integer ( i32 ), intent ( in ) :: iSub (:) !! Indices in each dimension. The first entry in iL is the left most index integer ( i32 ), intent ( in ) :: nSub (:) !! Size in each dimension integer ( i32 ) :: iG !! Index in the global vector integer ( i32 ) :: i integer ( i32 ) :: nDims integer ( i32 ) :: prod nDims = size ( iSub ) prod = 1 iG = 1 do i = 1 , nDims iG = iG + ( iSub ( i ) - 1 ) * prod prod = prod * nSub ( i ) end do end function !====================================================================! !====================================================================! function integerBin ( this , n , bound ) result ( i ) !====================================================================! ! Given a real number this, that is assumed to lie between 1 and N ! Round the real number and if it is outside 1 or N, limit the output to ! either of those values ! Automatically limits the output between 1 and N, unless bound is .false. ! TODO: This is not an integer bin, its the integer Nearest. real ( r64 ) :: this integer ( i32 ) :: n logical :: bound integer ( i32 ) :: i i = idnint ( this ) if ( bound ) then if ( i < 1 ) i = 1 if ( i > n ) i = n endif end function !====================================================================! end module","loc":"sourcefile/m_indexing.f90.html"},{"tags":"","title":"m_parameters.f90 – Fortran Program","text":"Modules m_parameters Source Code m_parameters.f90 Source Code module m_parameters !! Module contains user defined parameters for consistent use use variableKind implicit none real ( r64 ), parameter :: inf = huge ( 0. d0 ) real ( r64 ), parameter :: NaN = transfer (( / Z '00000000' , Z '7FF80000' / ), 1.0 _ 8 ) real ( r64 ), parameter :: pi = dacos ( - 1. d0 ) end module","loc":"sourcefile/m_parameters.f90.html"},{"tags":"","title":"m_partition.f90 – Fortran Program","text":"Modules m_partition Source Code m_partition.f90 Source Code module m_partition !! Contains Hoare's style partitioning algorithm used for quicksorting and quickselect routines. !! !! See [[partition]] and [[argPartition]] for more information. use variableKind , only : r32 , r64 , i32 , i64 implicit none private public :: partition interface partition !! Partitioning used for quickSort and quickSelect routines !====================================================================! module subroutine partition_r1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! real ( r32 ), intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: left !! Left index integer ( i32 ), intent ( in ) :: right !! Right index integer ( i32 ), intent ( inout ) :: iPivot !! Pivoting index end subroutine !====================================================================! !====================================================================! module subroutine partition_d1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: left !! Left index integer ( i32 ), intent ( in ) :: right !! Right index integer ( i32 ), intent ( inout ) :: iPivot !! Pivoting index end subroutine !====================================================================! !====================================================================! module subroutine partition_i1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! integer ( i32 ), intent ( inout ) :: this (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: iPivot end subroutine !====================================================================! !====================================================================! module subroutine partition_id1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! integer ( i64 ), intent ( inout ) :: this (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: iPivot end subroutine !====================================================================! end interface public :: argPartition interface argPartition !! Partitioning used for argQuicksort routines !====================================================================! module subroutine argPartition_r1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! real ( r32 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! !====================================================================! module subroutine argPartition_d1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! real ( r64 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! !====================================================================! module subroutine argPartition_i1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! integer ( i32 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! !====================================================================! module subroutine argPartition_id1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! integer ( i64 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! end interface contains end module","loc":"sourcefile/m_partition.f90.html"},{"tags":"","title":"m_partition3way.f90 – Fortran Program","text":"Modules m_partition3way Source Code m_partition3way.f90 Source Code module m_partition3way !! Contains Hoare's style partitioning algorithms used for quicksorting routines use variableKind use m_swap , only : swap use m_compare , only : compare implicit none interface partition3way !! Partitioning used for quicksort routines !    module procedure :: partition_r1D, module procedure :: partition3way_d1D !, partition_i1D, partition_id1D end interface !  interface argPartition !    !! Partitioning used for argQuicksort routines !    module procedure :: argPartition_r1D, argPartition_d1D, argPartition_i1D, argPartition_id1D !  end interface contains !  !====================================================================! !  subroutine partition_r1D(this,left,right,iPivot) !    !! Interfaced with partition() !  !====================================================================! !  real(r32), intent(inout) :: this(:) !! 1D array !  integer(i32), intent(inout) :: left !! Left index !  integer(i32), intent(inout) :: right !! Right index !  integer(i32), intent(inout) :: iPivot !! Pivoting index !  integer(i32) :: n !  integer(i32) :: lo,hi !  real(r32) :: pivot !  n=(right+left)/2 !  call swap(this(left),this(n)) !  pivot=this(left) !  lo=left;hi=right !  do while (lo <= hi) !    do while (this(hi) > pivot) !      hi=hi-1 !    end do ! !    do while (lo <= hi .and. this(lo) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(this(lo),this(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(this(left),this(hi)) !  iPivot=hi !  end subroutine !  !====================================================================! !====================================================================! subroutine partition3way_d1D ( this , left , right , iPivot1 , iPivot2 ) !! Interfaced with partition() !====================================================================! real ( r64 ), intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: left !! Left index integer ( i32 ), intent ( inout ) :: right !! Right index integer ( i32 ), intent ( inout ) :: iPivot1 !! Pivoting index integer ( i32 ), intent ( inout ) :: iPivot2 !! Pivoting index integer ( i32 ) :: i , j integer ( i32 ) :: c real ( r64 ) :: pivot iPivot1 = left iPivot2 = right pivot = this ( left ) i = left do while ( i <= iPivot2 ) c = compare ( this ( i ), pivot ) select case ( c ) case ( - 1 ) call swap ( this ( iPivot1 ), this ( i )) iPivot1 = iPivot1 + 1 i = i + 1 case ( 1 ) call swap ( this ( i ), this ( iPivot2 )) iPivot2 = iPivot2 - 1 case ( 0 ) i = i + 1 end select end do end subroutine !====================================================================! !  !====================================================================! !  subroutine partition_i1D(this,left,right,iPivot) !    !! Interfaced with partition() !  !====================================================================! !  integer(i32), intent(inout) :: this(:) !  integer(i32), intent(inout) :: left !  integer(i32), intent(inout) :: right !  integer(i32), intent(inout) :: iPivot !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i32) :: pivot !  n=(right+left)/2 !  call swap(this(left),this(n)) !  pivot=this(left) !  lo=left;hi=right !  do while (lo <= hi) !    do while (this(hi) > pivot) !      hi=hi-1 !    end do ! !    do while (lo <= hi .and. this(lo) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(this(lo),this(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(this(left),this(hi)) !  iPivot=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine partition_id1D(this,left,right,iPivot) !    !! Interfaced with partition() !  !====================================================================! !  integer(i64), intent(inout) :: this(:) !  integer(i32), intent(inout) :: left !  integer(i32), intent(inout) :: right !  integer(i32), intent(inout) :: iPivot !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i64) :: pivot !  n=(right+left)/2 !  call swap(this(left),this(n)) !  pivot=this(left) !  lo=left;hi=right !  do while (lo <= hi) !    do while (this(hi) > pivot) !      hi=hi-1 !    end do ! !    do while (lo <= hi .and. this(lo) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(this(lo),this(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(this(left),this(hi)) !  iPivot=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_r1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  real(r32) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  real(r32) :: pivot !  n=(right+left)/2 !  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. this(idx(lo)) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_d1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  real(r64) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  real(r64) :: pivot !!  n=(right+left)/2 !!  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. (this(idx(lo)) - pivot) <= 1.d-12  ) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_i1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  integer(i32) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i32) :: pivot !  n=(right+left)/2 !  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. this(idx(lo)) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_id1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  integer(i64) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i64) :: pivot !  n=(right+left)/2 !  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. this(idx(lo)) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! end module","loc":"sourcefile/m_partition3way.f90.html"},{"tags":"","title":"m_read.f90 – Fortran Program","text":"Modules m_readline Source Code m_read.f90 Source Code module m_readline !! Contains core routines to read different combinations of scalars and 1D arrays from a file use variableKind use m_errors , only : Ferr use m_strings , only : isString implicit none private public :: readline interface readline !! Read in multiple items from a line !! !! Example usage !!```fortran !!use variableKind !!use m_readline !!character(len=:),allocatable :: s !!real(r64) :: a,b,c !!real(r64) :: a1D(3) !!s = '1.0 2.0 3.0' !!call readline(a, b, c, 'No File Name', 0, s) ! Read 3 scalars from a string !!write(*,*) 'a should equal 1.0 ',a == 1.d0 !!write(*,*) 'b should equal 2.0 ',b == 2.d0 !!write(*,*) 'c should equal 3.0 ',c == 3.d0 !!call readline(a1D, 'No File Name', 0, s) ! Read a length 3 1D array from a string !!write(*,*) 'a1D should equal [1.0,2.0,3.0] ',all(a == [1.d0,2.d0,3.d0]) !!``` module procedure :: readLine_a , readLine_ab , readLine_abc , readLine_abcd , readLine_abcde module procedure :: readLine_av , readLine_avbv , readLine_avbvcv , readLine_abv , readLine_abvcv , readLine_abcdev module procedure :: readLine_abcdv , readLine_abcdvev , readLine_abcv , readLine_abcvdv , readLine_abcdefv , readLine_abcdefvgv end interface contains !====================================================================! subroutine readLine_a ( a , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! real ( r64 ), intent ( out ) :: a !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a else read ( iunit , * , iostat = istat ) a endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_ab ( a , b , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b else read ( iunit , * , iostat = istat ) a , b endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abc ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a b c on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c else read ( iunit , * , iostat = istat ) a , b , c endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcd ( a , b , c , d , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a b c d on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d else read ( iunit , * , iostat = istat ) a , b , c , d endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcde ( a , b , c , d , e , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a b c on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d , e else read ( iunit , * , iostat = istat ) a , b , c , d , e endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_av ( a , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a(1),...,a(Na) on a single line real ( r64 ), intent ( out ) :: a (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Na , istat Na = size ( a ) if ( present ( buf )) then read ( buf , * , iostat = istat ) ( a ( i ), i = 1 , Na ) else read ( iunit , * , iostat = istat ) ( a ( i ), i = 1 , Na ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_avbv ( a , b , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ), intent ( out ) :: a (:) !! Vector real ( r64 ), intent ( out ) :: b (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Na , Nb , istat Na = size ( a ); Nb = size ( b ) if ( present ( buf )) then read ( buf , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ) else read ( iunit , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_avbvcv ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ), intent ( out ) :: a (:) !! Vector real ( r64 ), intent ( out ) :: b (:) !! Vector real ( r64 ), intent ( out ) :: c (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Na , Nb , Nc , istat Na = size ( a ); Nb = size ( b ); Nc = size ( c ) if ( present ( buf )) then read ( buf , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) else read ( iunit , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abv ( a , b , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b(1),...,b(Nb) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nb , istat Nb = size ( b ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ) else read ( iunit , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abvcv ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b(1),...,b(Nb),c(1),...,c(Nc) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b (:) !! Vector real ( r64 ), intent ( out ) :: c (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nb , Nc , istat Nb = size ( b ); Nc = size ( c ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) else read ( iunit , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) endif if (. not . isString ( fname , '' )) call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcv ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c(1),...,c(Nc) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nc , istat Nc = size ( c ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ) else read ( iunit , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ) endif if (. not . isString ( fname , '' )) call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcvdv ( a , b , c , d , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c(1),...,c(Nc),d(1),...,d(Nd) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c (:) !! Vector real ( r64 ), intent ( out ) :: d (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nc , Nd , istat Nc = size ( c ); Nd = size ( d ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ),( d ( i ), i = 1 , Nd ) else read ( iunit , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ),( d ( i ), i = 1 , Nd ) endif if (. not . isString ( fname , '' )) call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdv ( a , b , c , d , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d(1),...,d(Nd) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nd , istat Nd = size ( d ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ) else read ( iunit , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdvev ( a , b , c , d , e , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d(1),...,d(Nd),e(1),...,e(Ne) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d (:) !! Vector real ( r64 ), intent ( out ) :: e (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nd , Ne , istat Nd = size ( d ); Ne = size ( e ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ),( e ( i ), i = 1 , Ne ) else read ( iunit , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ),( e ( i ), i = 1 , Ne ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdev ( a , b , c , d , e , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d,e(1),...,e(Ne) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Ne , istat Ne = size ( e ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d ,( e ( i ), i = 1 , Ne ) else read ( iunit , * , iostat = istat ) a , b , c , d ,( e ( i ), i = 1 , Ne ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdefv ( a , b , c , d , e , f , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d,e,f(1),...,f(Nf) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e !! Number real ( r64 ), intent ( out ) :: f (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nf , istat Nf = size ( f ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ) else read ( iunit , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdefvgv ( a , b , c , d , e , f , g , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d,e,f(1),...,f(Nf),g(1),...,g(Ng) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e !! Number real ( r64 ), intent ( out ) :: f (:) !! Vector real ( r64 ), intent ( out ) :: g (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nf , Ng , istat Nf = size ( f ); Ng = size ( g ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ),( g ( i ), i = 1 , Ng ) else read ( iunit , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ),( g ( i ), i = 1 , Ng ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! end module","loc":"sourcefile/m_read.f90.html"},{"tags":"","title":"m_reallocate.f90 – Fortran Program","text":"Modules m_reallocate Source Code m_reallocate.f90 Source Code module m_reallocate !! Contains routines to re-allocate allocatable arrays !! !! Copies the original values after reallocation. If you don't need to copy the values, use 'call allocate()' instead use variableKind use m_errors , only : eMsg , mErr implicit none private public reallocate interface reallocate !! Reallocate an allocatable array !! !! Example usage !!```fortran !!use variableKind !!use m_reallocate !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!allocate(a1D(5)) !!allocate(a2D(5,5)) !!allocate(a3D(5,5,5)) !!write(*,'(a)') 'Shape of a3D is [5,5,5]? '//all(shape(a3D) == [5,5,5]) !!call reallocate(a1D, 20) !!call reallocate(a2D, [20,20]) !!call reallocate(a3D, [20,20,20]) !!write(*,'(a)') 'Shape of a3D is [20,20,20]? '//all(shape(a3D) == [20,20,20]) !!``` module procedure :: reallocate_r1D , reallocate_r2D , reallocate_r3D module procedure :: reallocate_d1D , reallocate_d2D , reallocate_d3D module procedure :: reallocate_i1D , reallocate_i2D , reallocate_i3D module procedure :: reallocate_id1D , reallocate_id2D , reallocate_id3D module procedure :: reallocate_c1D , reallocate_c2D , reallocate_c3D module procedure :: reallocate_z1D , reallocate_z2D , reallocate_z3D module procedure :: reallocate_l1D , reallocate_l2D , reallocate_l3D end interface contains !====================================================================! subroutine reallocate_r1D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size real ( r32 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_r1D:tmp' , 1 ) tmp = 0. d0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_r2D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape real ( r32 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_r2D:tmp' , 1 ) tmp = 0. d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_r3D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape real ( r32 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_r3D:tmp' , 1 ) tmp = 0. d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_d1D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size real ( r64 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_d1D:tmp' , 1 ) tmp = 0. d0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_d2D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape real ( r64 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_d2D:tmp' , 1 ) tmp = 0. d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_d3D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape real ( r64 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_d3D:tmp' , 1 ) tmp = 0. d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_i1D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size integer ( i32 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_i1D:tmp' , 1 ) tmp = 0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_i2D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_i2D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_i3D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_i3D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_id1D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size integer ( i64 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_id1D:tmp' , 1 ) tmp = 0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_id2D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i64 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_id2D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_id3D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i64 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_id3D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_c1D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size complex ( r32 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_c1D:tmp' , 1 ) tmp = ( 0. d0 , 0. d0 ) nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_c2D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape complex ( r32 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_c2D:tmp' , 1 ) tmp = ( 0. d0 , 0. d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_c3D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape complex ( r32 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_c3D:tmp' , 1 ) tmp = ( 0. d0 , 0. d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_z1D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size complex ( r64 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_z1D:tmp' , 1 ) tmp = ( 0. d0 , 0. d0 ) nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_z2D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape complex ( r64 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_z2D:tmp' , 1 ) tmp = ( 0. d0 , 0. d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_z3D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape complex ( r64 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_z3D:tmp' , 1 ) tmp = ( 0. d0 , 0. d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_l1D ( this , n ) !! Interfaced with reallocate() !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size logical , allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_l1D:tmp' , 1 ) tmp = . false . nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_l2D ( this , n ) !! Interfaced with reallocate() !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape logical , allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_l2D:tmp' , 1 ) tmp = . false . nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_l3D ( this , n ) !! Interfaced with reallocate() !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape logical , allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_l3D:tmp' , 1 ) tmp = . false . nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! end module","loc":"sourcefile/m_reallocate.f90.html"},{"tags":"","title":"m_strings.f90 – Fortran Program","text":"Modules m_strings Source Code m_strings.f90 Source Code module m_strings !! Module provides string handling capabilities use iso_fortran_env , only : output_unit use variableKind use m_errors , only : wMsg , eMsg , Ferr , mErr use m_parameters , only : NaN , inf implicit none private public :: appendString public :: compact public :: countEntries public :: hasNentries public :: iachar1D public :: isString public :: lowercase public :: prependString public :: read1Dble public :: read1Integer public :: removeComments public :: replacedelim public :: str public :: uppercase public :: printOptions interface str !! Interface to print a string representation of a number !! The output format options can be set using the printOptions class !! !! Example usage !!```fortran !!use variableKind !!use m_strings !!real(r64) :: arr(20) !!integer(i32) :: i !!integer(i32) :: j(5) !!arr = [(dble(i), i = 1,20)] !!i = 12 !!j = [0, 1, 2, 3, 4] !!write(*,'(a)') str(i)//str(j) !!write(*,'(a)') str(j)//str(arr) !!write(*,'(a)') str(arr) !!printOptions%threshold = 0 !!write(*,'(a)') str(arr) !!``` module procedure :: str_r1 , str_r1D module procedure :: str_d1 , str_d1D , str_d2D module procedure :: str_i1 , str_i1D , str_id1 module procedure :: str_id1D module procedure :: str_s1 , str_s1D module procedure :: str_1L end interface interface compactReal !! Returns a compact representation of a real number !! By default, truncates to 3 decimal places unless printOptions%precision is changed module procedure :: compactReal_d1 !,compactReal_d1D end interface type , public :: c_printOptions !! Print options similar to numpy's print_options integer ( i32 ) :: precision = 3 !! Force this precision on the written number integer ( i32 ) :: threshold = 10 !! Omit the middle entries if the size is greater than threshold integer ( i32 ) :: edgeitems = 3 !! Only write the first and last threshold elements from rows and/or columns character ( len = 32 ) :: nanstr = 'nan' !! Print NAN as this character ( len = 32 ) :: infstr = 'inf' !! Print infinity as this end type type ( c_printOptions ) :: printOptions contains !====================================================================! subroutine ensure1Integer ( N , fname , vName , iUnit ) !! Forces the next line, read in from file contains a single integer !! Useful for ascii data files with a size specified in a header !====================================================================! integer ( i32 ), intent ( out ) :: N !! Number character ( len =* ), intent ( in ) :: fname !! File name character ( len =* ), intent ( in ) :: vName !! Integer variable name for warning message integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len = cLen ) :: buf integer ( i32 ) :: istat ! Removes multiple spaces and tabs from the line ! Adjusts the string to the left call readline ( iunit , buf , istat ) call Ferr ( istat , fname , 2 ) call read1Integer ( buf , N , istat ) if ( istat /= 0 ) then call eMsg ( 'Reading a single integer to variable ' // trim ( vName ) // ' Value obtained = ' // str ( N )) endif end subroutine !====================================================================! !====================================================================! subroutine read1Integer ( buf , N , istat ) !! Get a single integer from a line, returns an error code if there is more than one entry !====================================================================! character ( len =* ) :: buf !! String integer ( i32 ) :: N !! Single integer integer ( i32 ) :: istat !! istat > 0 if more than one entry is found integer ( i32 ) :: i call compact ( buf ) ! Check if any spaces exist between 2 numbers(there should only be 1 number) i = scan ( trim ( buf ), ' ' ,. true .) read ( buf , * , iostat = istat ) N if ( i > 2 ) istat = 1 end subroutine !====================================================================! !====================================================================! subroutine read1Dble ( iunit , this , fname , vName , istat ) !!TODO: CHECK THIS !====================================================================! ! Requires the line being read to contain ONLY one real number integer ( i32 ), intent ( in ) :: iunit character ( len =* ) :: fname character ( len =* ) :: vName ! varvariable name for warning msg, if str='', no msg will write character ( len = 500 ) :: buf integer ( i32 ) :: i , istat real ( r64 ) :: this call readline ( iunit , buf , istat ) call Ferr ( istat , fname , 2 ) call compact ( buf ) !Need to do this to ensure that spaces after the number !Are not considered as multiple spaces, and to remove control !characters and tabs. ! Check if any spaces exist between 2 numbers(there should only be 1) i = scan ( trim ( buf ), ' ' ,. true .) read ( buf , * , iostat = istat ) this if ( istat /= 0 ) then if ( len_trim ( vName ) /= 0 ) then call Wmsg ( str ( fname ) // vName ) write ( output_unit , '(a)' ) trim ( vName ) // ': ' , this endif endif end subroutine !====================================================================! !  !====================================================================! !  subroutine parse(str,delims,args,nargs) !  !====================================================================! !  ! Parses the string 'str' into arguments args(1), ..., args(nargs) based on !  ! the delimiters contained in the string 'delims'. Preceding a delimiter in !  ! 'str' by a backslash ( makes this particular instance not a delimiter. !  ! The integer output variable nargs contains the number of arguments found. ! !  character(len=*) :: str,delims !  character(len=len_trim(str)) :: strsav !  character(len=*),dimension(:) :: args !  integer(i32) :: i !  integer(i32) :: k !  integer(i32) :: lenstr !  integer(i32) :: na,nargs !  strsav=str !  call compact(str) !  na=size(args) !  do i=1,na !    args(i)=' ' !  end do !  nargs=0 !  lenstr=len_trim(str) !  if(lenstr==0) return !  k=0 ! !  do !    if(len_trim(str) == 0) exit !    nargs=nargs+1 !    call split(str,delims,args(nargs)) !    call removebksl(args(nargs)) !  end do !  str=strsav ! !  end subroutine parse ! !  !********************************************************************** !====================================================================! function hasNentries ( this , N ) result ( yes ) !! Check that a string has N entries !====================================================================! character ( len =* ) :: this integer ( i32 ) :: N logical :: yes yes = ( countEntries ( this ) == N ) end function !====================================================================! !====================================================================! function countEntries ( this ) result ( N ) !! Count the number of entries in a string !====================================================================! character ( len =* ) :: this integer ( i32 ) :: N integer ( i32 ) :: i , ich , lenstr character ( len = 1 ) :: c call compact ( this ) ! Ensure only single spaces between items lenstr = len_trim ( this ) c = this ( 1 : 1 ) ich = iachar ( c ) if ( ich >= 33 ) N = 1 do i = 2 , lenstr c = this ( i : i ) ich = iachar ( c ) if ( ich == 32 ) N = N + 1 enddo end function !====================================================================! !====================================================================! subroutine compact ( this ) !! Replace tabs and spaces with a single space !! str must be a variable and not an explicit 'string'. Otherwise adjustl will fail. !====================================================================! character ( len =* ) :: this character ( len = 1 ) :: s character ( len = len_trim ( this )) :: tmp integer ( i32 ) :: i , iL , iRes integer ( i32 ) :: N logical :: oneSpace N = len_trim ( this ) oneSpace = . true . iRes = 1 tmp = '' do i = 1 , N s = this ( i : i ) iL = iachar ( s ) select case ( iL ) case ( 9 , 32 ) ! If tab or space, skip entries while they are tabs or spaces if ( oneSpace ) then tmp ( iRes : iRes ) = ' ' oneSpace = . false . iRes = iRes + 1 endif case ( 33 :) tmp ( iRes : iRes ) = s oneSpace = . true . iRes = iRes + 1 end select enddo this = tmp end subroutine !====================================================================! !====================================================================! function isNumeric ( this ) result ( yes ) !! Determine if the item in a string is numeric !====================================================================! character ( len =* ), intent ( in ) :: this logical :: yes real ( r64 ) :: tmp integer ( i32 ) :: istat read ( this , * , iostat = istat ) tmp yes = ( istat == 0 ) end function !====================================================================! !====================================================================! function compactReal_d1 ( this ) result ( res ) !! Returns a compact representation of a real number !! By default, truncates to 3 decimal places unless dp is provided !====================================================================! real ( r64 ), intent ( in ) :: this !! Double precision number character ( len = :), allocatable :: res !! String character ( len = 1024 ) :: s character ( len = 9 ) :: ctmp real ( r64 ) :: tmp integer ( i32 ) :: p integer ( i32 ) :: myP character ( len = 12 ) :: FMT ! Check for an NaN if ( this /= this ) then res = printOptions % nanstr return end if if ( this > inf ) then res = printOptions % infstr return end if myP = printOptions % precision tmp = dabs ( this ) select case ( tmp < 1. d0 ) case (. true .) write ( FMT , '(\"(es\",i0,\".\",i0,\")\")' ) 7 + myP , myP write ( s , FMT ) this case (. false .) p = floor ( dlog10 ( tmp )) if ( p > printOptions % precision ) then write ( FMT , '(\"(es\",i0,\".\",i0,\")\")' ) p + 7 + myP , myP write ( s , FMT ) this else if ( this == 0. d0 ) then s = '0.' else write ( FMT , '(\"(f0.\",i0,\")\")' ) myP write ( s , FMT ) this p = len_trim ( s ) if ( all ( iachar1D ( s ( p - myP + 1 : p )) == 48 )) then ctmp = s ( 1 : p - myP ) s = '' s = ctmp endif endif endif end select write ( cTmp , 1 ) 46 , 48 , 48 , 48 , 69 , 43 , 48 , 48 1 format ( 8 ( a1 )) if ( verify ( s , cTmp ) == 0 ) then ! Checks that zero isnt being written as 0.000e+00, and replaces with just 0 s = '0.' endif s = adjustl ( s ) res = trim ( s ) end function !====================================================================! !  !====================================================================! !  subroutine compactReal_d1D(this,res) !    !! Use CompactReal on an r64 vector !  !====================================================================! !  real(r64) :: this(:) !    !! 1D vector of numbers !  character(len=*) :: res(:) !    !! 1D vector of strings !  integer(i32) :: i,N !  N=size(this) !  do i=1,N !    call compactReal(this(i),res(i)) !  enddo !  end subroutine !  !====================================================================! !====================================================================! function str_r1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r32 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ res = compactReal ( dble ( this )) // deli end function !====================================================================! !====================================================================! function str_r1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r32 ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_d2D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r64 ), intent ( in ) :: this (:,:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this , 1 ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str_d1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo else do i = 1 , printOptions % edgeitems res = res // str_d1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) end do res = res // '...' // new_line ( 'a' ) do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str_d1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo endif res = res // str_d1D ( this ( N ,:), delim_ ) end function !====================================================================! !====================================================================! function str_d1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r64 ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_d1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r64 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ res = compactReal ( this ) // deli end function !====================================================================! !====================================================================! function str_i1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i32 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = cLen ) :: tmp character ( len = :), allocatable :: res character ( len = :), allocatable :: deli write ( tmp , '(i0)' ) this deli = ' ' if ( present ( delim_ )) deli = delim_ res = trim ( tmp ) // deli end function !====================================================================! !====================================================================! function str_id1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i64 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = cLen ) :: tmp character ( len = :), allocatable :: res character ( len = :), allocatable :: deli write ( tmp , '(i0)' ) this deli = ' ' if ( present ( delim_ )) deli = delim_ res = trim ( tmp ) // deli end function !====================================================================! !====================================================================! function str_i2D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i32 ), intent ( in ) :: this (:,:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this , 1 ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str_i1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo else do i = 1 , printOptions % edgeitems res = res // str_i1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) end do res = res // '...' // new_line ( 'a' ) do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str_i1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo endif res = res // str_i1D ( this ( N ,:), delim_ ) end function !====================================================================! !====================================================================! function str_i1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i32 ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_id2D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i64 ), intent ( in ) :: this (:,:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this , 1 ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str_id1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo else do i = 1 , printOptions % edgeitems res = res // str_id1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) end do res = res // '...' // new_line ( 'a' ) do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str_id1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo endif res = res // str_id1D ( this ( N ,:), delim_ ) end function !====================================================================! !====================================================================! function str_id1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i64 ), intent ( in ) :: this (:) !! 1D array character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli !! String integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_s1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! character ( len =* ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ res = trim ( this ) // deli end function !====================================================================! !====================================================================! function str_s1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! character ( len =* ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this ) res = '' do i = 1 , N - 1 res = res // str_s1 ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) end function !====================================================================! !====================================================================! function str_1L ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! logical , intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ if ( this ) then res = 'True' // deli else res = 'False' // deli endif end function !====================================================================! !====================================================================! function lowerCase ( str ) result ( res ) !! Convert a string to lowercase !====================================================================! character ( len =* ) :: str character ( len = len_trim ( str )) :: res character ( len = 1 ) :: s integer ( i32 ) :: i , iSft integer ( i32 ) :: N iSft = iachar ( 'A' ) - iachar ( 'a' ) N = len_trim ( str ) res = str do i = 1 , N s = str ( i : i ) select case ( s ) case ( 'A' : 'Z' ) res ( i : i ) = achar ( iachar ( s ) - iSft ) end select enddo end function lowercase !====================================================================! !====================================================================! function upperCase ( str ) result ( res ) !! Convert a string to uppercase !====================================================================! character ( len =* ) :: str character ( len = len_trim ( str )) :: res character ( len = 1 ) :: s integer ( i32 ) :: i , iSft integer ( i32 ) :: N iSft = iachar ( 'A' ) - iachar ( 'a' ) N = len_trim ( str ) res = str do i = 1 , N s = res ( i : i ) select case ( s ) case ( 'a' : 'z' ) res ( i : i ) = achar ( iachar ( s ) + iSft ) end select enddo end function upperCase !====================================================================! !====================================================================! function isString ( tmp1 , tmp2 , exact_ ) result ( yes ) !! Match two string together !====================================================================! character ( len =* ) :: tmp1 !! Compare this string character ( len =* ) :: tmp2 !! Compare this string logical , optional :: exact_ !! Optional logical, if true, the strings are not converted to lowercase before comparison logical :: yes , exact character ( len = len_trim ( tmp1 )) :: this character ( len = len_trim ( tmp2 )) :: that this = '' ; that = '' this ( 1 : len_trim ( tmp1 )) = trim ( tmp1 ) that ( 1 : len_trim ( tmp2 )) = trim ( tmp2 ) yes = . false . exact = . false . if ( present ( exact_ )) exact = exact_ if ( exact ) then if ( trim ( this ) == trim ( that )) yes = . true . else if ( lowercase ( trim ( this )) == lowercase ( trim ( that ))) yes = . true . endif end function !====================================================================! !====================================================================! subroutine readline ( iUnit , line , istat ) !! Reads a line from a file, ignoring any comments !====================================================================! integer ( i32 ) :: iUnit !! File ID number character ( len =* ) :: line !! Character string to read the line into integer ( i32 ) :: istat !! Error Status integer ( i32 ) :: ipos !  go = .true. !  do while(go) !    read(iUnit,'(a)',iostat=istat, end = 1) line !    call removeBOM(line) ! Remove the byte order mark if present !    i = index(line,'!') ! Get the location of the comment ! !  enddo do read ( iUnit , '(a)' , iostat = istat , end = 1 ) line ! read input line call compact ( line ) if ( istat /= 0 ) return call removeBOM ( line ) line = adjustl ( line ) ipos = index ( line , '!' ) if ( ipos == 1 ) cycle if ( ipos /= 0 ) line = line (: ipos - 1 ) if ( len_trim ( line ) /= 0 ) exit end do return 1 istat = 1 end subroutine readline !====================================================================! !====================================================================! elemental subroutine removeBOM ( this ) !! Removes the byte order mark from the beginning of a string !====================================================================! character ( len =* ), intent ( inout ) :: this if ( iachar ( this ( 1 : 1 )) == 239 . and . iachar ( this ( 2 : 2 )) == 187 . and . iachar ( this ( 3 : 3 )) == 191 ) this ( 1 : 3 ) = '   ' end subroutine !====================================================================! !====================================================================! elemental subroutine removeComments ( this ) !! Removes the text after the ! mark in a string !====================================================================! character ( len =* ), intent ( inout ) :: this character ( len = :), allocatable :: tmp integer ( i32 ) :: i , length length = len_trim ( this ) tmp = this ; this = '' i = index ( tmp , '!' ) this ( 1 : i - 1 ) = tmp ( 1 : i - 1 ) end subroutine !====================================================================! !====================================================================! !! Replace a substring with another in a string !====================================================================! subroutine replace ( this , sub1 , sub2 ) character ( len =* ) :: this character ( len =* ) :: sub1 character ( len =* ) :: sub2 end subroutine !====================================================================! !====================================================================! !> Replace a single character length delimiter in a string subroutine replacedelim ( this , dlim , dlimr ) !====================================================================! character ( len =* ) :: this !! Replace delimiter in this character ( len =* ) :: dlim !! Find this delimiter character ( len =* ) :: dlimr !! Replace with this delimiter integer ( i32 ) :: i , it it = len ( dlim ) if ( it /= len ( dlimr )) call Emsg ( 'replaceDelim : un-equal length replacement' ) do i = 1 , len_trim ( this ) if ( this ( i :( i - 1 ) + it ) == dlim ) this ( i :( i - 1 ) + it ) = dlimr enddo end subroutine !====================================================================! !  !====================================================================! !  subroutine removebksl(str) !  !====================================================================! !  ! Removes backslash ( characters. Double backslashes (\\ are replaced !  ! by a single backslash. !  character(len=*):: str !  character(len=1):: ch !  character(len=len_trim(str))::outstr !  integer(i32) :: i,ibsl !  integer(i32) :: k !  integer(i32) :: lenstr ! !  str=adjustl(str) !  lenstr=len_trim(str) !  outstr=' ' !  k=0 !  ibsl=0                        ! backslash initially inactive ! !  do i=1,lenstr !    ch=str(i:i) !    if(ibsl == 1) then          ! backslash active !      k=k+1 !      outstr(k:k)=ch !      ibsl=0 !      cycle !    end if !    if(ch == '\\') then          ! backslash with backslash inactive !      ibsl=1 !      cycle !    end if !    k=k+1 !    outstr(k:k)=ch              ! non-backslash with backslash inactive !  end do ! !  str=adjustl(outstr) ! !  end subroutine removebksl !  !====================================================================! !====================================================================! function appendString ( this , that , delim ) result ( res ) !! Append a string !====================================================================! character ( len =* ) :: this !! String to append to character ( len =* ) :: that !! String to append character ( len =* ), optional :: delim !! Optional delimiter to separate the append character ( len = :), allocatable :: res !! Appended String if ( present ( delim )) then res = trim ( this ) // trim ( delim ) // trim ( that ) else res = trim ( this ) // trim ( that ) endif end function !====================================================================! !====================================================================! function prependString ( this , that , delim ) result ( res ) !! Prepend a string !====================================================================! character ( len =* ) :: this !! String to prepend to character ( len =* ) :: that !! String to prepend character ( len =* ), optional :: delim !! Optional delimiter to separate the append character ( len = :), allocatable :: res !! Prepended String if ( present ( delim )) then res = trim ( that ) // trim ( delim ) // trim ( this ) else res = trim ( that ) // trim ( this ) endif end function !====================================================================! !====================================================================! function iachar1D ( this ) result ( res ) !! Use iachar on a full string !! !! Cannot overload to intrinsic iachar because of ambiguity !====================================================================! character ( len =* ), intent ( in ) :: this integer ( i32 ), allocatable :: res (:) integer ( i32 ) :: i , istat integer ( i32 ) :: N N = len_trim ( this ) allocate ( res ( N ), stat = istat ); call mErr ( istat , 'iachar:result' , 2 ) do i = 1 , N res ( i ) = iachar ( this ( i : i )) end do end function !====================================================================! end module","loc":"sourcefile/m_strings.f90.html"},{"tags":"","title":"m_swap.f90 – Fortran Program","text":"Modules m_swap Source Code m_swap.f90 Source Code module m_swap !! Handles a simple swapping of two elements use variableKind implicit none private public :: swap interface swap !! Swap the values of two variables !! !!Example usage !!```fortran !!use variableKind !!use m_strings, only: str !!use m_swap, only: swap !!real(r64) :: a,b !!a = 10.d0 !!b = 100.d0 !!call swap(a,b) !!write(*,'(a)') 'Values were swapped? '//str(a == 100.d0 .and. b == 10.d0) !!``` module procedure :: swap_i1 , swap_id1 , swap_r1 , swap_d1 , swap_c1 , swap_z1 , swap_l1 end interface contains !====================================================================! subroutine swap_i1 ( this , that ) !! Interfaced with swap() !====================================================================! integer ( i32 ), intent ( inout ) :: this integer ( i32 ), intent ( inout ) :: that integer ( i32 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_id1 ( this , that ) !! Interfaced with swap() !====================================================================! integer ( i64 ), intent ( inout ) :: this integer ( i64 ), intent ( inout ) :: that integer ( i64 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_r1 ( this , that ) !! Interfaced with swap() !====================================================================! real ( r32 ), intent ( inout ) :: this real ( r32 ), intent ( inout ) :: that real ( r32 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_d1 ( this , that ) !! Interfaced with swap() !====================================================================! real ( r64 ), intent ( inout ) :: this real ( r64 ), intent ( inout ) :: that real ( r64 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_c1 ( this , that ) !! Interfaced with swap() !====================================================================! complex ( r32 ) :: this complex ( r32 ) :: that complex ( r32 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_z1 ( this , that ) !! Interfaced with swap() !====================================================================! complex ( r64 ) :: this complex ( r64 ) :: that complex ( r64 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_l1 ( this , that ) !! Interfaced with swap() !====================================================================! logical :: this logical :: that logical :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! end module","loc":"sourcefile/m_swap.f90.html"},{"tags":"","title":"m_variableKind.f90 – Fortran Program","text":"Modules variableKind Source Code m_variableKind.f90 Source Code module variableKind !! Defines variable kinds use , intrinsic :: iso_fortran_env , only : i8 => int8 , i16 => int16 , i32 => int32 , i64 => int64 use , intrinsic :: iso_fortran_env , only : r32 => real32 , r64 => real64 integer ( i32 ), parameter :: cLen = 1024 !! Default character length for temporaries end module","loc":"sourcefile/m_variablekind.f90.html"},{"tags":"","title":"m_write.f90 – Fortran Program","text":"Modules m_writeline Source Code m_write.f90 Source Code module m_writeline !! Contains core routines to write different combinations of scalars and 1D arrays to a file use iso_fortran_env , only : output_unit use variableKind use m_errors , only : Ferr use m_strings , only : str implicit none private public :: writeline interface writeline !! Write multiple items to a line !! !! Example usage !!```fortran !!use variableKind !!use m_writeline !!use m_fileIO, only: openFile, closeFile !!character(len=:),allocatable :: fName !!real(r64) :: a,b,c !!real(r64) :: a1D(3) !!integer(i32) :: iunit, istat !!a = 1.d0 !!b = 2.d0 !!c = 3.d0 !!a1D = [1.d0, 2.d0, 3.d0] !!fName = 'writeline.txt' !!call openFile(fName, iunit, 'unknown', istat) !!call writeline(a, b, c, fName, iunit) !!call writeline(a1D, fName, iunit) !!call closeFile(fName, iunit, '', istat) !!``` module procedure :: writeLine_a , writeLine_ab , writeLine_abc , writeLine_abcd , writeLine_abcde module procedure :: writeLine_av , writeLine_avbv , writeLine_avbvcv , writeLine_abv , writeLine_abvcv , writeLine_abcdev module procedure :: writeLine_abcdevfv , writeLine_abcdv , writeLine_abcdvev , writeLine_abcv , writeLine_abcvdv module procedure :: writeLine_abcdefv , writeLine_abcdefvgv end interface contains !====================================================================! subroutine writeLine_a ( a , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a on a single line real ( r64 ) :: a character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_ab ( a , b , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b on a single line real ( r64 ) :: a , b character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abc ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b c on a single line real ( r64 ) :: a , b , c character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcd ( a , b , c , d , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b c d on a single line real ( r64 ) :: a , b , c , d character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcde ( a , b , c , d , e , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b c on a single line real ( r64 ) :: a , b , c , d , e character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_av ( a , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a(1),...,a(Na) on a single line real ( r64 ) :: a (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_avbv ( a , b , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ) :: a (:), b (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_avbvcv ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ) :: a (:), b (:), c (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abv ( a , b , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b(1),...,b(Nb) on a single line real ( r64 ) :: a , b (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abvcv ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b(1),...,b(Nb),c(1),...,c(Nc) on a single line real ( r64 ) :: a , b (:), c (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcv ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c(1),...,c(Nc) on a single line real ( r64 ) :: a , b , c (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcvdv ( a , b , c , d , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c(1),...,c(Nc),d(1),...,d(Nd) on a single line real ( r64 ) :: a , b , c (:), d (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdv ( a , b , c , d , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d(1),...,d(Nd) on a single line real ( r64 ) :: a , b , c , d (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdvev ( a , b , c , d , e , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d(1),...,d(Nd),e(1),...,e(Ne) on a single line real ( r64 ) :: a , b , c , d (:), e (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdev ( a , b , c , d , e , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e(1),...,e(Ne) on a single line real ( r64 ) :: a , b , c , d , e (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdevfv ( a , b , c , d , e , f , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e(1),...,e(Ne) on a single line real ( r64 ) :: a , b , c , d , e (:), f (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdefv ( a , b , c , d , e , f , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e,f(1),...,f(Nf) on a single line real ( r64 ) :: a , b , c , d , e , f (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdefvgv ( a , b , c , d , e , f , g , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e,f(1),...,f(Nf),g(1),...,g(Ng) on a single line real ( r64 ) :: a , b , c , d , e , f (:), g (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) // str ( g ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) // str ( g ) endif end subroutine !====================================================================! end module","loc":"sourcefile/m_write.f90.html"},{"tags":"","title":"m_maths.f90 – Fortran Program","text":"Modules m_maths Source Code m_maths.f90 Source Code module m_maths !! Math routines use variableKind implicit none private public :: crossproduct interface crossproduct !! Compute the cross product between two arrays of length 2 or 3 module function crossproduct_r1D ( a , b ) result ( res ) !! Interfaced with crossproduct() real ( r32 ), intent ( in ) :: a ( 3 ) !! 1D Array real ( r32 ), intent ( in ) :: b ( 3 ) !! 1D Array real ( r32 ) :: res ( 3 ) !! cross product end function module function crossproduct_d1D ( a , b ) result ( res ) !! Interfaced with crossproduct() real ( r64 ), intent ( in ) :: a ( 3 ) !! 1D Array real ( r64 ), intent ( in ) :: b ( 3 ) !! 1D Array real ( r64 ) :: res ( 3 ) !! cross product end function end interface public :: cumprod interface cumprod !! Compute the variance of an array module function cumprod_r1D ( this ) result ( res ) !! Interfaced with cumprod() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res ( size ( this )) !! Cumulative product end function module function cumprod_d1D ( this ) result ( res ) !! Interfaced with cumprod() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res ( size ( this )) !! Cumulative product end function module function cumprod_i1D ( this ) result ( res ) !! Interfaced with cumprod() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res ( size ( this )) !! Cumulative product end function module function cumprod_id1D ( this ) result ( res ) !! Interfaced with cumprod() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res ( size ( this )) !! Cumulative product end function end interface public :: cumsum interface cumsum !! Compute the variance of an array module function cumsum_r1D ( this ) result ( res ) !! Interfaced with cumsum() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res ( size ( this )) !! Cumulative sum end function module function cumsum_d1D ( this ) result ( res ) !! Interfaced with cumsum() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res ( size ( this )) !! Cumulative sum end function module function cumsum_i1D ( this ) result ( res ) !! Interfaced with cumsum() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res ( size ( this )) !! Cumulative sum end function module function cumsum_id1D ( this ) result ( res ) !! Interfaced with cumsum() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res ( size ( this )) !! Cumulative sum end function end interface public :: fastTwoDiff interface fastTwoDiff !! Compute the difference two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoDiff routine module function fastTwoDiff_r ( a , b ) result ( res ) !! Interfaced with fastTwoDiff() real ( r32 ), intent ( in ) :: a !! First number real ( r32 ), intent ( in ) :: b !! Second number real ( r32 ) :: res ( 2 ) !! Result and its error end function module function fastTwoDiff_d ( a , b ) result ( res ) !! Interfaced with fastTwoDiff() real ( r64 ), intent ( in ) :: a !! First number real ( r64 ), intent ( in ) :: b !! Second number real ( r64 ) :: res ( 2 ) !! Result and its error end function end interface public :: fastTwoSum interface fastTwoSum !! Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoSum routine module function fastTwoSum_r ( a , b ) result ( res ) !! Interfaced with fastTwoSum() real ( r32 ), intent ( in ) :: a !! First number real ( r32 ), intent ( in ) :: b !! Second number real ( r32 ) :: res ( 2 ) !! Result and its error end function module function fastTwoSum_d ( a , b ) result ( res ) !! Interfaced with fastTwoSum() real ( r64 ), intent ( in ) :: a !! First number real ( r64 ), intent ( in ) :: b !! Second number real ( r64 ) :: res ( 2 ) !! Result and its error end function end interface public :: geometricMean interface geometricMean !! Compute the geometric mean of a vector module function geometricMean_r1D ( this ) result ( res ) !! Interfaced with geometricMean() real ( r32 ), intent ( in ) :: this (:) real ( r64 ) :: res end function module function geometricMean_d1D ( this ) result ( res ) !! Interfaced with geometricMean() real ( r64 ), intent ( in ) :: this (:) real ( r64 ) :: res end function module function geometricMean_i1D ( this ) result ( res ) !! Interfaced with geometricMean() integer ( i32 ), intent ( in ) :: this (:) real ( r64 ) :: res end function module function geometricMean_id1D ( this ) result ( res ) !! Interfaced with geometricMean() integer ( i64 ), intent ( in ) :: this (:) real ( r64 ) :: res end function end interface public :: mean interface mean !! Compute the mean module function mean_r1D ( this ) result ( res ) !! Interfaced with mean() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function module function mean_d1D ( this ) result ( res ) !! Interfaced with mean() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function module function mean_i1D ( this ) result ( res ) !! Interfaced with mean() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function module function mean_id1D ( this ) result ( res ) !! Interfaced with mean() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function end interface public :: median interface median !! Compute the median of a set of numbers module function median_r1D ( this ) result ( res ) !! Interfaced with median() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res !! median end function module function median_d1D ( this ) result ( res ) !! Interfaced with median() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! median end function module function median_i1D ( this ) result ( res ) !! Interfaced with median() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! median end function module function median_id1D ( this ) result ( res ) !! Interfaced with median() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! median end function end interface public :: norm1 interface norm1 !! Compute the L1 norm of a set of numbers module function norm1_r1D ( this ) result ( res ) !! Interfaced with norm1() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res !! L1 norm end function module function norm1_d1D ( this ) result ( res ) !! Interfaced with norm1() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! L1 norm end function module function norm1_i1D ( this ) result ( res ) !! Interfaced with norm1() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! L1 norm end function module function norm1_id1D ( this ) result ( res ) !! Interfaced with norm1() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! L1 norm end function end interface public :: normI interface normI !! Compute the Linfinity norm of a set of numbers module function normI_r1D ( this ) result ( res ) !! Interfaced with normI() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res !! Linfinity norm end function module function normI_d1D ( this ) result ( res ) !! Interfaced with normI() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! Linfinity norm end function module function normI_i1D ( this ) result ( res ) !! Interfaced with normI() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res !! Linfinity norm end function module function normI_id1D ( this ) result ( res ) !! Interfaced with normI() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res !! Linfinity norm end function end interface public :: project interface project !! Project a vector a onto vector b module function project_r1D ( a , b ) result ( c ) !! Interfaced with project() real ( r32 ), intent ( in ) :: a (:) !! 1D array real ( r32 ), intent ( in ) :: b ( size ( a )) !! 1D array real ( r32 ) :: c ( size ( a )) !! 1D array end function module function project_d1D ( a , b ) result ( c ) !! Interfaced with project() real ( r64 ), intent ( in ) :: a (:) !! 1D array real ( r64 ), intent ( in ) :: b ( size ( a )) !! 1D array real ( r64 ) :: c ( size ( a )) !! 1D array end function end interface public :: trimmedmean interface trimmedmean !! Compute the Trimmed mean of an array,  alpha is a percent value to trim from either end module function trimmedmean_r1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function module function trimmedmean_d1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function module function trimmedmean_i1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function module function trimmedmean_id1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function end interface public :: twoDiff interface twoDiff !! Compute the difference between two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! If you know that the magnitude of a is greater than or equal to b, use fastTwoDiff module function twoDiff_r ( a , b ) result ( res ) !! Interfaced with twoDiff() real ( r32 ), intent ( in ) :: a !! First number real ( r32 ), intent ( in ) :: b !! Second number real ( r32 ) :: res ( 2 ) !! Result and its error end function module function twoDiff_d ( a , b ) result ( res ) !! Interfaced with twoDiff() real ( r64 ), intent ( in ) :: a !! First number real ( r64 ), intent ( in ) :: b !! Second number real ( r64 ) :: res ( 2 ) !! Result and its error end function end interface public :: twoSum interface twoSum !! Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! If you know that the magnitude of a is greater than or equal to b, use fastTwoSum module function twoSum_r ( a , b ) result ( res ) !! Interfaced with twoSum() real ( r32 ), intent ( in ) :: a !! First number in sum real ( r32 ), intent ( in ) :: b !! Second number in sum real ( r32 ) :: res ( 2 ) !! The sum and its error end function module function twoSum_d ( a , b ) result ( res ) !! Interfaced with twoSum() real ( r64 ), intent ( in ) :: a !! First number in sum real ( r64 ), intent ( in ) :: b !! Second number in sum real ( r64 ) :: res ( 2 ) !! The sum and its error end function end interface public :: std interface std !! Compute the standard deviation of an array module function std_r1D ( this ) result ( res ) !! Interfaced with std() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function module function std_d1D ( this ) result ( res ) !! Interfaced with std() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function module function std_i1D ( this ) result ( res ) !! Interfaced with std() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function module function std_id1D ( this ) result ( res ) !! Interfaced with std() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function end interface public :: variance interface variance !! Compute the variance of an array module function variance_r1D ( this ) result ( res ) !! Interfaced with variance() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function module function variance_d1D ( this ) result ( res ) !! Interfaced with variance() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function module function variance_i1D ( this ) result ( res ) !! Interfaced with variance() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function module function variance_id1D ( this ) result ( res ) !! Interfaced with variance() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function end interface end module","loc":"sourcefile/m_maths.f90.html"},{"tags":"","title":"m_random.f90 – Fortran Program","text":"Modules m_random Source Code m_random.f90 Source Code module m_random !! Routines for random number generation.  The original code is provided via Netlib at http://www.netlib.org/random/random.f90 use iso_fortran_env , only : output_unit use variableKind use m_errors use m_strings , only : printOptions , str use m_indexing , only : ind2sub implicit none ! Original Version ! Author: Alan Miller ! Updated version: ! Version 2.00, 11 November 2016 ! Increased precision to double ! Added seed setters ! Added overloaded operations for single number, nD arrays !     Author: Leon Foks private public :: setRNG interface setRNG !! Sets the random number with or without a seed module procedure :: setRNG_Wseed , setRNG_WOseed end interface public shuffle interface shuffle !! Perform Knuth shuffling on an array module subroutine shuffle_r1D ( this ) !! Interfaced with shuffle() real ( r32 ) :: this (:) !! 1D array end subroutine module subroutine shuffle_d1D ( this ) !! Interfaced with shuffle() real ( r64 ) :: this (:) !! 1D array end subroutine module subroutine shuffle_i1D ( this ) !! Interfaced with shuffle() integer ( i32 ) :: this (:) !! 1D array end subroutine module subroutine shuffle_id1D ( this ) !! Interfaced with shuffle() integer ( i64 ) :: this (:) !! 1D array end subroutine end interface public :: rngInteger interface rngInteger module procedure :: rngInteger_i1 , rngInteger_i1D end interface public :: rngWeibull interface rngWeibull module procedure :: rngWeibull_d1 , rngWeibull_d1D end interface public :: rngExponential interface rngExponential module procedure :: rngExponential_d1 , rngExponential_d1D end interface public rngChisq interface rngChisq module procedure :: rngChisq_d1 , rngChisq_d1D end interface public :: rngGamma interface rngGamma module procedure :: rngGamma_d1 , rngGamma_d1D end interface public :: rngNormal interface rngNormal module procedure :: rngNormal_d1 , rngNormal_d1D , rngNormal_d2D , rngNormal_d3D end interface public :: rngUniform interface rngUniform module procedure :: rngUniform_d1 , rngUniform_d1D , rngUniform_d2D end interface logical , protected :: isInitialized = . false . real ( r64 ), protected :: zero = 0. d0 , half = 0.5 d0 , one = 1. d0 , two = 2. d0 real ( r64 ), protected :: vsmall = TINY ( 1. d0 ), vlarge = HUGE ( 1. d0 ) contains !====================================================================! subroutine rngInteger_i1D ( this , imin ) !! Generate size(this) random integers starting from imin !====================================================================! integer ( i32 ) :: this (:) integer ( i32 ) :: imin integer ( i32 ) :: i , j , k , N N = size ( this ) this = [( imin + ( i - 1 ), i = 1 , N )] do i = 1 , N call rngInteger_I1 ( j , 1 , i ) k = this ( i ) this ( i ) = this ( j ) this ( j ) = k end do end subroutine !====================================================================! !====================================================================! subroutine rngInteger_i1 ( this , imin , imax ) !! Generate a random integer from imin to imax !====================================================================! integer ( i32 ) :: this integer ( i32 ) :: imin , imax real ( r64 ) :: wk call rngUniform ( wk ) this = imin + idnint ( wk * dble ( imax - imin )) end subroutine !====================================================================! !====================================================================! subroutine rngUniform_d2D ( this , rmin , rmax ) !====================================================================! real ( r64 ) :: this (:,:) real ( r64 ), optional :: rmin , rmax call RANDOM_NUMBER ( this ) if ( present ( rmax )) this = rmin + ( rmax - rmin ) * this end subroutine !====================================================================! !====================================================================! subroutine rngUniform_d1D ( this , rmin , rmax ) !====================================================================! real ( r64 ) :: this (:) real ( r64 ), optional :: rmin , rmax call RANDOM_NUMBER ( this ) if ( present ( rmax )) this = rmin + ( rmax - rmin ) * this end subroutine !====================================================================! !====================================================================! subroutine rngUniform_d1 ( this , rmin , rmax ) !====================================================================! real ( r64 ), intent ( inout ) :: this real ( r64 ), intent ( in ), optional :: rmin , rmax call RANDOM_NUMBER ( this ) if ( present ( rmax )) this = rmin + ( rmax - rmin ) * this end subroutine !====================================================================! !====================================================================! subroutine rngNormal_d3D ( this , mean , std ) !====================================================================! real ( r64 ) :: this (:,:,:) real ( r64 ), optional :: mean , std integer :: i , iSub ( 3 ) integer :: n , nSub ( 3 ) nSub = shape ( this ) n = size ( this ) do i = 1 , n iSub = ind2sub ( i , nSub ) call rngNormal_d1 ( this ( iSub ( 1 ), iSub ( 2 ), iSub ( 3 )), mean , std ) enddo end subroutine !====================================================================! !====================================================================! subroutine rngNormal_d2D ( this , mean , std ) !====================================================================! real ( r64 ) :: this (:,:) real ( r64 ), optional :: mean , std integer :: i , iSub ( 2 ) integer :: n , nSub ( 2 ) nSub = shape ( this ) n = size ( this ) do i = 1 , n iSub = ind2sub ( i , nSub ) call rngNormal_d1 ( this ( iSub ( 1 ), iSub ( 2 )), mean , std ) enddo end subroutine !====================================================================! !====================================================================! subroutine rngNormal_d1D ( this , mean , std ) !====================================================================! real ( r64 ) :: this (:) real ( r64 ), optional :: mean , std integer :: i , N N = size ( this ) do i = 1 , N call rngNormal ( this ( i ), mean , std ) end do end subroutine !====================================================================! !====================================================================! subroutine rngNormal_d1 ( this , mean , std ) !====================================================================! !====================================================================! ! Adapted from the following Fortran 77 code !      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM. !      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE, !      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435. !  The function random_normal() returns a normally distributed pseudo-random !  number with zero mean and unit variance. !  The algorithm uses the ratio of uniforms method of A.J. Kinderman !  and J.F. Monahan augmented with quadratic bounding curves. !     Generate P = (u,v) uniform in rectangle enclosing acceptance region !====================================================================! real ( r64 ), intent ( inout ) :: this real ( r64 ), intent ( in ), optional :: mean , std ! Local variables real ( r64 ) :: s real ( r64 ) :: t real ( r64 ) :: a real ( r64 ) :: b real ( r64 ) :: q real ( r64 ) :: r1 real ( r64 ) :: r2 real ( r64 ) :: u real ( r64 ) :: v real ( r64 ) :: x real ( r64 ) :: y s = 0.449871 d0 t = - 0.386595 d0 a = 0.196 d0 b = 0.25472 d0 r1 = 0.27597 d0 r2 = 0.27846 d0 DO CALL rngUniform ( u ) CALL rngUniform ( v ) v = 1.7156 d0 * ( v - half ) !     Evaluate the quadratic form x = u - s y = dABS ( v ) - t q = x ** 2 d0 + y * ( a * y - b * x ) !     Accept P if inside inner ellipse IF ( q < r1 ) EXIT !     Reject P if outside outer ellipse IF ( q > r2 ) CYCLE !     Reject P if outside acceptance region IF ( v ** 2. d0 < - 4. d0 * dLOG ( u ) * u ** 2. d0 ) EXIT END DO !     Return ratio of P's coordinates as the normal deviate this = v / u if ( present ( std )) then if (. not . present ( mean )) call eMsg ( 'rngNormal : Need both mean and standard deviation' ) this = ( std * this ) + mean end if end subroutine !====================================================================! !====================================================================! subroutine rngGamma_d1D ( this , s , first ) !====================================================================! real ( r64 ) :: this (:) real ( r64 ), INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first integer :: i , N N = size ( this ) call rngGamma ( this ( 1 ), s , first ) do i = 2 , N ; call rngGamma ( this ( i ), s ,. false .); enddo end subroutine !====================================================================! !====================================================================! subroutine rngGamma_d1 ( this , s , first ) !====================================================================! !====================================================================! ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 !     FUNCTION GENERATES A RANDOM GAMMA VARIATE. !     CALLS EITHER random_gamma1 (S > 1.0) !     OR random_exponential (S = 1.0) !     OR random_gamma2 (S < 1.0). !     S = SHAPE PARAMETER OF DISTRIBUTION (0 < real(r64)). !====================================================================! real ( r64 ) :: this real ( r64 ), INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first IF ( s <= zero ) call Emsg ( 'rngGamma : shape parameter must be positive' ) IF ( s > one ) THEN this = rngGamma1 ( s , first ) ELSE IF ( s < one ) THEN this = rngGamma2 ( s , first ) ELSE call rngExponential ( this ) END IF END subroutine !====================================================================! !====================================================================! function rngGamma1 ( s , first ) result ( this ) !====================================================================! ! Uses the algorithm in ! Marsaglia, G. and Tsang, W.W. (2000) `A simple method for generating ! gamma variables', Trans. om Math. Software (TOMS), vol.26(3), pp.363-372. ! Generates a random gamma deviate for shape parameter s >= 1. real ( r64 ) :: this real ( r64 ), INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first ! Local variables real ( r64 ), SAVE :: c , d real ( r64 ) :: u , v , x IF ( first ) THEN d = s - one / 3. d0 c = one / dSQRT ( 9. d0 * d ) END IF ! Start of main loop DO ! Generate v = (1+cx)&#94;3 where x is random normal; repeat if v <= 0. DO call rngNormal ( x ) v = ( one + c * x ) ** 3. d0 IF ( v > zero ) EXIT END DO ! Generate uniform variable U call rngUniform ( u ) IF ( u < one - 0.0331 d0 * x ** 4. d0 ) THEN this = d * v EXIT ELSE IF ( dLOG ( u ) < half * x ** 2. d0 + d * ( one - v + dLOG ( v ))) THEN this = d * v EXIT END IF END DO END FUNCTION !====================================================================! !====================================================================! function rngGamma2 ( s , first ) RESULT ( this ) !====================================================================! ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM ! A GAMMA DISTRIBUTION WITH DENSITY PROPORTIONAL TO ! GAMMA2**(S-1) * EXP(-GAMMA2), ! USING A SWITCHING METHOD. !    S = SHAPE PARAMETER OF DISTRIBUTION !          (real(r64) < 1.0) real ( r64 ) :: this real ( r64 ), INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first !     Local variables real ( r64 ) :: r , x , w real ( r64 ), SAVE :: a , p , c , uf , vr , d IF ( s <= zero . OR . s >= one ) call Emsg ( 'rngGamma2 : shape parameter outside (0 1)' ) IF ( first ) THEN ! Initialization, if necessary a = one - s p = a / ( a + s * dEXP ( - a )) IF ( s < vsmall ) call Emsg ( 'rngGamma2 : shape parameter too small' ) c = one / s uf = p * ( vsmall / a ) ** s vr = one - vsmall d = a * dLOG ( a ) END IF DO CALL rngUniform ( r ) IF ( r >= vr ) THEN CYCLE ELSE IF ( r > p ) THEN x = a - dLOG (( one - r ) / ( one - p )) w = a * dLOG ( x ) - d ELSE IF ( r > uf ) THEN x = a * ( r / p ) ** c w = x ELSE this = zero RETURN END IF CALL rngUniform ( r ) IF ( one - r <= w . AND . r > zero ) THEN IF ( r * ( w + one ) >= one ) CYCLE IF ( - dLOG ( r ) <= w ) CYCLE END IF EXIT END DO this = x END FUNCTION !====================================================================! !====================================================================! subroutine rngChisq_d1D ( this , ndf , first ) !====================================================================! real ( r64 ) :: this (:) INTEGER , INTENT ( IN ) :: ndf LOGICAL , INTENT ( IN ) :: first integer :: i , N N = size ( this ) call rngChisq ( this ( 1 ), ndf , first ) do i = 2 , N call rngChisq ( this ( i ), ndf ,. false .) end do end subroutine !====================================================================! !====================================================================! subroutine rngChisq_d1 ( this , ndf , first ) !====================================================================! ! Generates a random variate from the chi-squared distribution with ! ndf degrees of freedom INTEGER , INTENT ( IN ) :: ndf LOGICAL , INTENT ( IN ) :: first real ( r64 ) :: this call rngGamma ( this , half * dble ( ndf ), first ) this = two * this END subroutine !====================================================================! !====================================================================! subroutine rngExponential_d1D ( this ) !====================================================================! real ( r64 ) :: this (:) integer :: i , N N = size ( this ) do i = 1 , N call rngExponential ( this ( i )) end do end subroutine !====================================================================! !====================================================================! subroutine rngExponential_d1 ( this ) !====================================================================! ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM ! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL ! TO EXP(-random_exponential), USING INVERSION. real ( r64 ) :: this !     Local variable real ( r64 ) :: r DO CALL rngUniform ( r ) IF ( r > zero ) EXIT END DO this = - dLOG ( r ) end subroutine !====================================================================! !====================================================================! subroutine rngWeibull_d1D ( this , den ) !====================================================================! real ( r64 ) :: this (:) real ( r64 ), intent ( in ) :: den integer :: i , N N = size ( this ) do i = 1 , N call rngWeibull ( this ( i ), den ) end do end subroutine !====================================================================! !====================================================================! subroutine rngWeibull_d1 ( this , den ) !====================================================================! !     Generates a random variate from the Weibull distribution with !     probability density: !                      a !               a-1  -x !     f(x) = a.x    e real ( r64 ) :: this real ( r64 ), intent ( in ) :: den if ( den == 0. d0 . or . dabs ( den ) < 1. d - 16 ) call Emsg ( 'rngWeibull : density is v.small' ) call rngExponential ( this ) this = this ** ( one / den ) end subroutine !====================================================================! !====================================================================! subroutine setRNG_Wseed ( seed ) !! Interfaced to setRNG() !! Sets the seed of the random number generator with a specified seed !====================================================================! integer :: seed (:) integer :: n if ( isInitialized ) return call random_seed ( size = n ) if ( size ( seed ) /= n ) call Emsg ( 'setRNG : Seed muse be size ' // str ( n )) call random_seed ( put = seed ) isInitialized = . true . end subroutine !====================================================================! !====================================================================! subroutine setRNG_WOseed ( display ) !! Interfaced to setRNG() !! 'Randomly' sets the seed of the random number generator !====================================================================! integer , allocatable :: seed (:) integer :: n , istat logical :: display if ( isInitialized ) return call random_seed ( size = n ) allocate ( seed ( n ), stat = istat ); call Merr ( istat , 'setRNG : Seed' , 1 ) call randomizeSeed ( seed ) call random_seed ( put = seed ) if ( display ) then istat = printOptions % threshold printOptions % threshold = 0 write ( output_unit , '(a)' ) 'Random Seed: ' // str ( seed ) printOptions % threshold = istat end if isInitialized = . true . end subroutine !====================================================================! !====================================================================! subroutine randomizeSeed ( seed ) !! Randomizes the seed for the random number generator !====================================================================! integer :: seed (:) integer :: i , n , un , istat , dt ( 8 ) integer ( i64 ) :: t n = size ( seed ) if ( size ( seed ) /= n ) call Emsg ( 'setRNG : Seed muse be size ' // str ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then read ( un ) seed close ( un ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_i64 * 86400000 & + dt ( 2 ) * 31_i64 * 86400000 & + dt ( 3 ) * 86400000 & + dt ( 5 ) * 3600000 & + dt ( 6 ) * 60000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if ! Getpid is a Gnu function.  Intel must use ifport, but the integer is only int*4 :( !pid = getpid() !t = ieor(t, int(pid, kind(t))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if contains !====================================================================! !====================================================================! function lcg ( s ) result ( res ) !! This simple PRNG might not be good enough for real work, but is !! sufficient for seeding a better PRNG. !====================================================================! integer ( i32 ) :: res integer ( i64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_i64 ) end if s = mod ( s * 279470273_i64 , 4294967291_i64 ) res = int ( mod ( s , int ( huge ( 0 ), i64 )), kind ( 0 )) end function end subroutine !====================================================================! !====================================================================! ! EXTRA CODES TO BE TRANSLATED LATER!!! !====================================================================! ! ! !  FUNCTION random_beta(aa, bb, first) RESULT(fn_val) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM VARIATE IN [0,1] !! FROM A BETA DISTRIBUTION WITH DENSITY !! PROPORTIONAL TO BETA**(AA-1) * (1-BETA)**(BB-1). !! USING CHENG'S LOG LOGISTIC METHOD. ! !!     AA = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) !!     BB = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) ! !REAL, INTENT(IN)    :: aa, bb !LOGICAL, INTENT(IN) :: first !REAL                :: fn_val ! !!     Local variables !REAL, PARAMETER  :: aln4 = 1.3862944 !REAL             :: a, b, g, r, s, x, y, z !REAL, SAVE       :: d, f, h, t, c !LOGICAL, SAVE    :: swap ! !IF (aa <= zero .OR. bb <= zero) THEN !  WRITE(*, *) 'IMPERMISSIBLE SHAPE PARAMETER VALUE(S)' !  STOP !END IF ! !IF (first) THEN                        ! Initialization, if necessary !  a = aa !  b = bb !  swap = b > a !  IF (swap) THEN !    g = b !    b = a !    a = g !  END IF !  d = a/b !  f = a+b !  IF (b > one) THEN !    h = SQRT((two*a*b - f)/(f - two)) !    t = one !  ELSE !    h = b !    t = one/(one + (a/(vlarge*b))**b) !  END IF !  c = a+h !END IF ! !DO !  CALL RANDOM_NUMBER(r) !  CALL RANDOM_NUMBER(x) !  s = r*r*x !  IF (r < vsmall .OR. s <= zero) CYCLE !  IF (r < t) THEN !    x = LOG(r/(one - r))/h !    y = d*EXP(x) !    z = c*x + f*LOG((one + d)/(one + y)) - aln4 !    IF (s - one > z) THEN !      IF (s - s*z > one) CYCLE !      IF (LOG(s) > z) CYCLE !    END IF !    fn_val = y/(one + y) !  ELSE !    IF (4.0*s > (one + one/d)**f) CYCLE !    fn_val = one !  END IF !  EXIT !END DO ! !IF (swap) fn_val = one - fn_val !RETURN !END FUNCTION random_beta ! ! ! !FUNCTION random_t(m) RESULT(fn_val) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM VARIATE FROM A !! T DISTRIBUTION USING KINDERMAN AND MONAHAN'S RATIO METHOD. ! !!     M = DEGREES OF FREEDOM OF DISTRIBUTION !!           (1 <= 1NTEGER) ! !INTEGER, INTENT(IN) :: m !REAL                :: fn_val ! !!     Local variables !REAL, SAVE      :: s, c, a, f, g !REAL            :: r, x, v ! !REAL, PARAMETER :: three = 3.0, four = 4.0, quart = 0.25,   & !                   five = 5.0, sixteen = 16.0 !INTEGER         :: mm = 0 ! !IF (m < 1) THEN !  WRITE(*, *) 'IMPERMISSIBLE DEGREES OF FREEDOM' !  STOP !END IF ! !IF (m /= mm) THEN                    ! Initialization, if necessary !  s = m !  c = -quart*(s + one) !  a = four/(one + one/s)**c !  f = sixteen/a !  IF (m > 1) THEN !    g = s - one !    g = ((s + one)/g)**c*SQRT((s+s)/g) !  ELSE !    g = one !  END IF !  mm = m !END IF ! !DO !  CALL RANDOM_NUMBER(r) !  IF (r <= zero) CYCLE !  CALL RANDOM_NUMBER(v) !  x = (two*v - one)*g/r !  v = x*x !  IF (v > five - a*r) THEN !    IF (m >= 1 .AND. r*(v + three) > f) CYCLE !    IF (r > (one + v/s)**c) CYCLE !  END IF !  EXIT !END DO ! !fn_val = x !RETURN !END FUNCTION random_t ! ! ! !SUBROUTINE random_mvnorm(n, h, d, f, first, x, ier) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! N.B. An extra argument, ier, has been added to Dagpunar's routine ! !!     SUBROUTINE GENERATES AN N VARIATE RANDOM NORMAL !!     VECTOR USING A CHOLESKY DECOMPOSITION. ! !! ARGUMENTS: !!        N = NUMBER OF VARIATES IN VECTOR !!           (INPUT,INTEGER >= 1) !!     H(J) = J'TH ELEMENT OF VECTOR OF MEANS !!           (INPUT,REAL) !!     X(J) = J'TH ELEMENT OF DELIVERED VECTOR !!           (OUTPUT,REAL) !! !!    D(J*(J-1)/2+I) = (I,J)'TH ELEMENT OF VARIANCE MATRIX (J> = I) !!            (INPUT,REAL) !!    F((J-1)*(2*N-J)/2+I) = (I,J)'TH ELEMENT OF LOWER TRIANGULAR !!           DECOMPOSITION OF VARIANCE MATRIX (J <= I) !!            (OUTPUT,REAL) ! !!    FIRST = .TRUE. IF THIS IS THE FIRST CALL OF THE ROUTINE !!    OR IF THE DISTRIBUTION HAS CHANGED SINCE THE LAST CALL OF THE ROUTINE. !!    OTHERWISE SET TO .FALSE. !!            (INPUT,LOGICAL) ! !!    ier = 1 if the input covariance matrix is not +ve definite !!        = 0 otherwise ! !INTEGER, INTENT(IN)   :: n !REAL, INTENT(IN)      :: h(:), d(:)   ! d(n*(n+1)/2) !REAL, INTENT(IN OUT)  :: f(:)         ! f(n*(n+1)/2) !REAL, INTENT(OUT)     :: x(:) !LOGICAL, INTENT(IN)   :: first !INTEGER, INTENT(OUT)  :: ier ! !!     Local variables !INTEGER       :: j, i, m !REAL          :: y, v !INTEGER, SAVE :: n2 ! !IF (n < 1) THEN !  WRITE(*, *) 'SIZE OF VECTOR IS NON POSITIVE' !  STOP !END IF ! !ier = 0 !IF (first) THEN                        ! Initialization, if necessary !  n2 = 2*n !  IF (d(1) < zero) THEN !    ier = 1 !    RETURN !  END IF ! !  f(1) = SQRT(d(1)) !  y = one/f(1) !  DO j = 2,n !    f(j) = d(1+j*(j-1)/2) * y !  END DO ! !  DO i = 2,n !    v = d(i*(i-1)/2+i) !    DO m = 1,i-1 !      v = v - f((m-1)*(n2-m)/2+i)**2 !    END DO ! !    IF (v < zero) THEN !      ier = 1 !      RETURN !    END IF ! !    v = SQRT(v) !    y = one/v !    f((i-1)*(n2-i)/2+i) = v !    DO j = i+1,n !      v = d(j*(j-1)/2+i) !      DO m = 1,i-1 !        v = v - f((m-1)*(n2-m)/2+i)*f((m-1)*(n2-m)/2 + j) !      END DO ! m = 1,i-1 !      f((i-1)*(n2-i)/2 + j) = v*y !    END DO ! j = i+1,n !  END DO ! i = 2,n !END IF ! !x(1:n) = h(1:n) !DO j = 1,n !  y = random_normal() !  DO i = j,n !    x(i) = x(i) + f((j-1)*(n2-j)/2 + i) * y !  END DO ! i = j,n !END DO ! j = 1,n ! !RETURN !END SUBROUTINE random_mvnorm ! ! ! !FUNCTION random_inv_gauss(h, b, first) RESULT(fn_val) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY] FROM !! A REPARAMETERISED GENERALISED INVERSE GAUSSIAN (GIG) DISTRIBUTION !! WITH DENSITY PROPORTIONAL TO  GIG**(H-1) * EXP(-0.5*B*(GIG+1/GIG)) !! USING A RATIO METHOD. ! !!     H = PARAMETER OF DISTRIBUTION (0 <= REAL) !!     B = PARAMETER OF DISTRIBUTION (0 < REAL) ! !REAL, INTENT(IN)    :: h, b !LOGICAL, INTENT(IN) :: first !REAL                :: fn_val ! !!     Local variables !REAL            :: ym, xm, r, w, r1, r2, x !REAL, SAVE      :: a, c, d, e !REAL, PARAMETER :: quart = 0.25 ! !IF (h < zero .OR. b <= zero) THEN !  WRITE(*, *) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' !  STOP !END IF ! !IF (first) THEN                        ! Initialization, if necessary !  IF (h > quart*b*SQRT(vlarge)) THEN !    WRITE(*, *) 'THE RATIO H:B IS TOO SMALL' !    STOP !  END IF !  e = b*b !  d = h + one !  ym = (-d + SQRT(d*d + e))/b !  IF (ym < vsmall) THEN !    WRITE(*, *) 'THE VALUE OF B IS TOO SMALL' !    STOP !  END IF ! !  d = h - one !  xm = (d + SQRT(d*d + e))/b !  d = half*d !  e = -quart*b !  r = xm + one/xm !  w = xm*ym !  a = w**(-half*h) * SQRT(xm/ym) * EXP(-e*(r - ym - one/ym)) !  IF (a < vsmall) THEN !    WRITE(*, *) 'THE VALUE OF H IS TOO LARGE' !    STOP !  END IF !  c = -d*LOG(xm) - e*r !END IF ! !DO !  CALL RANDOM_NUMBER(r1) !  IF (r1 <= zero) CYCLE !  CALL RANDOM_NUMBER(r2) !  x = a*r2/r1 !  IF (x <= zero) CYCLE !  IF (LOG(r1) < d*LOG(x) + e*(x + one/x) + c) EXIT !END DO ! !fn_val = x ! !RETURN !END FUNCTION random_inv_gauss ! ! ! !FUNCTION random_Poisson(mu, first) RESULT(ival) !!********************************************************************** !!     Translated to Fortran 90 by Alan Miller from: !!                           RANLIB !! !!     Library of Fortran Routines for Random Number Generation !! !!                    Compiled and Written by: !! !!                         Barry W. Brown !!                          James Lovato !! !!             Department of Biomathematics, Box 237 !!             The University of Texas, M.D. Anderson Cancer Center !!             1515 Holcombe Boulevard !!             Houston, TX      77030 !! !! This work was supported by grant CA-16672 from the National Cancer Institute. ! !!                    GENerate POIsson random deviate ! !!                            Function ! !! Generates a single random deviate from a Poisson distribution with mean mu. ! !!                            Arguments ! !!     mu --> The mean of the Poisson distribution from which !!            a random deviate is to be generated. !!                              REAL mu ! !!                              Method ! !!     For details see: ! !!               Ahrens, J.H. and Dieter, U. !!               Computer Generation of Poisson Deviates !!               From Modified Normal Distributions. !!               ACM Trans. Math. Software, 8, 2 !!               (June 1982),163-179 ! !!     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT !!     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL ! !!     SEPARATION OF CASES A AND B ! !!     .. Scalar Arguments .. !REAL, INTENT(IN)    :: mu !LOGICAL, INTENT(IN) :: first !INTEGER             :: ival !!     .. !!     .. Local Scalars .. !REAL          :: b1, b2, c, c0, c1, c2, c3, del, difmuk, e, fk, fx, fy, g,  & !                 omega, px, py, t, u, v, x, xx !REAL, SAVE    :: s, d, p, q, p0 !INTEGER       :: j, k, kflag !LOGICAL, SAVE :: full_init !INTEGER, SAVE :: l, m !!     .. !!     .. Local Arrays .. !REAL, SAVE    :: pp(35) !!     .. !!     .. Data statements .. !REAL, PARAMETER :: a0 = -.5, a1 = .3333333, a2 = -.2500068, a3 = .2000118,  & !                   a4 = -.1661269, a5 = .1421878, a6 = -.1384794,   & !                   a7 = .1250060 ! !REAL, PARAMETER :: fact(10) = (/ 1., 1., 2., 6., 24., 120., 720., 5040.,  & !                                 40320., 362880. /) ! !!     .. !!     .. Executable Statements .. !IF (mu > 10.0) THEN !!     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED) ! !  IF (first) THEN !    s = SQRT(mu) !    d = 6.0*mu*mu ! !!             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL !!             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484) !!             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 . ! !    l = mu - 1.1484 !    full_init = .false. !  END IF ! ! !!     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE ! !  g = mu + s*random_normal() !  IF (g > 0.0) THEN !    ival = g ! !!     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH ! !    IF (ival>=l) RETURN ! !!     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U ! !    fk = ival !    difmuk = mu - fk !    CALL RANDOM_NUMBER(u) !    IF (d*u >= difmuk*difmuk*difmuk) RETURN !  END IF ! !!     STEP P. PREPARATIONS FOR STEPS Q AND H. !!             (RECALCULATIONS OF PARAMETERS IF NECESSARY) !!             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7. !!             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE !!             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK. !!             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION. ! !  IF (.NOT. full_init) THEN !    omega = .3989423/s !    b1 = .4166667E-1/mu !    b2 = .3*b1*b1 !    c3 = .1428571*b1*b2 !    c2 = b2 - 15.*c3 !    c1 = b1 - 6.*b2 + 45.*c3 !    c0 = 1. - b1 + 3.*b2 - 15.*c3 !    c = .1069/mu !    full_init = .true. !  END IF ! !  IF (g < 0.0) GO TO 50 ! !!             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN) ! !  kflag = 0 !  GO TO 70 ! !!     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE) ! !  40 IF (fy-u*fy <= py*EXP(px-fx)) RETURN ! !!     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL !!             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT' !!             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.) ! !  50 e = random_exponential() !  CALL RANDOM_NUMBER(u) !  u = u + u - one !  t = 1.8 + SIGN(e, u) !  IF (t <= (-.6744)) GO TO 50 !  ival = mu + s*t !  fk = ival !  difmuk = mu - fk ! !!             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN) ! !  kflag = 1 !  GO TO 70 ! !!     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION) ! !  60 IF (c*ABS(u) > py*EXP(px+e) - fy*EXP(fx+e)) GO TO 50 !  RETURN ! !!     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY. !!             CASE ival < 10 USES FACTORIALS FROM TABLE FACT ! !  70 IF (ival>=10) GO TO 80 !  px = -mu !  py = mu**ival/fact(ival+1) !  GO TO 110 ! !!             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION !!             A0-A7 FOR ACCURACY WHEN ADVISABLE !!             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5) ! !  80 del = .8333333E-1/fk !  del = del - 4.8*del*del*del !  v = difmuk/fk !  IF (ABS(v)>0.25) THEN !    px = fk*LOG(one + v) - difmuk - del !  ELSE !    px = fk*v*v* (((((((a7*v+a6)*v+a5)*v+a4)*v+a3)*v+a2)*v+a1)*v+a0) - del !  END IF !  py = .3989423/SQRT(fk) !  110 x = (half - difmuk)/s !  xx = x*x !  fx = -half*xx !  fy = omega* (((c3*xx + c2)*xx + c1)*xx + c0) !  IF (kflag <= 0) GO TO 40 !  GO TO 60 ! !!--------------------------------------------------------------------------- !!     C A S E  B.    mu < 10 !!     START NEW TABLE AND CALCULATE P0 IF NECESSARY ! !ELSE !  IF (first) THEN !    m = MAX(1, INT(mu)) !    l = 0 !    p = EXP(-mu) !    q = p !    p0 = p !  END IF ! !!     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD ! !  DO !    CALL RANDOM_NUMBER(u) !    ival = 0 !    IF (u <= p0) RETURN ! !!     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE !!             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES !!             (0.458=PP(9) FOR MU=10) ! !    IF (l == 0) GO TO 150 !    j = 1 !    IF (u > 0.458) j = MIN(l, m) !    DO k = j, l !      IF (u <= pp(k)) GO TO 180 !    END DO !    IF (l == 35) CYCLE ! !!     STEP C. CREATION OF NEW POISSON PROBABILITIES P !!             AND THEIR CUMULATIVES Q=PP(K) ! !    150 l = l + 1 !    DO k = l, 35 !      p = p*mu / k !      q = q + p !      pp(k) = q !      IF (u <= q) GO TO 170 !    END DO !    l = 35 !  END DO ! !  170 l = k !  180 ival = k !  RETURN !END IF ! !RETURN !END FUNCTION random_Poisson ! ! ! !FUNCTION random_binomial1(n, p, first) RESULT(ival) ! !! FUNCTION GENERATES A RANDOM BINOMIAL VARIATE USING C.D.Kemp's method. !! This algorithm is suitable when many random variates are required !! with the SAME parameter values for n & p. ! !!    P = BERNOULLI SUCCESS PROBABILITY !!           (0 <= REAL <= 1) !!    N = NUMBER OF BERNOULLI TRIALS !!           (1 <= INTEGER) !!    FIRST = .TRUE. for the first call using the current parameter values !!          = .FALSE. if the values of (n,p) are unchanged from last call ! !! Reference: Kemp, C.D. (1986). `A modal method for generating binomial !!            variables', Commun. Statist. - Theor. Meth. 15(3), 805-813. ! !INTEGER, INTENT(IN) :: n !REAL, INTENT(IN)    :: p !LOGICAL, INTENT(IN) :: first !INTEGER             :: ival ! !!     Local variables ! !INTEGER         :: ru, rd !INTEGER, SAVE   :: r0 !REAL            :: u, pd, pu !REAL, SAVE      :: odds_ratio, p_r !REAL, PARAMETER :: zero = 0.0, one = 1.0 ! !IF (first) THEN !  r0 = (n+1)*p !  p_r = bin_prob(n, p, r0) !  odds_ratio = p / (one - p) !END IF ! !CALL RANDOM_NUMBER(u) !u = u - p_r !IF (u < zero) THEN !  ival = r0 !  RETURN !END IF ! !pu = p_r !ru = r0 !pd = p_r !rd = r0 !DO !  rd = rd - 1 !  IF (rd >= 0) THEN !    pd = pd * (rd+1) / (odds_ratio * (n-rd)) !    u = u - pd !    IF (u < zero) THEN !      ival = rd !      RETURN !    END IF !  END IF ! !  ru = ru + 1 !  IF (ru <= n) THEN !    pu = pu * (n-ru+1) * odds_ratio / ru !    u = u - pu !    IF (u < zero) THEN !      ival = ru !      RETURN !    END IF !  END IF !END DO ! !!     This point should not be reached, but just in case: ! !ival = r0 !RETURN ! !END FUNCTION random_binomial1 ! ! ! !FUNCTION bin_prob(n, p, r) RESULT(fn_val) !!     Calculate a binomial probability ! !INTEGER, INTENT(IN) :: n, r !REAL, INTENT(IN)    :: p !REAL                :: fn_val ! !!     Local variable !REAL                :: one = 1.0 ! !fn_val = EXP( lngamma(DBLE(n+1)) - lngamma(DBLE(r+1)) - lngamma(DBLE(n-r+1)) & !              + r*LOG(p) + (n-r)*LOG(one - p) ) !RETURN ! !END FUNCTION bin_prob ! ! ! !FUNCTION lngamma(x) RESULT(fn_val) ! !! Logarithm to base e of the gamma function. !! !! Accurate to about 1.e-14. !! Programmer: Alan Miller ! !! Latest revision of Fortran 77 version - 28 February 1988 ! !REAL (dp), INTENT(IN) :: x !REAL (dp)             :: fn_val ! !!       Local variables ! !REAL (dp) :: a1 = -4.166666666554424D-02, a2 = 2.430554511376954D-03,  & !             a3 = -7.685928044064347D-04, a4 = 5.660478426014386D-04,  & !             temp, arg, product, lnrt2pi = 9.189385332046727D-1,       & !             pi = 3.141592653589793D0 !LOGICAL   :: reflect ! !!       lngamma is not defined if x = 0 or a negative integer. ! !IF (x > 0.d0) GO TO 10 !IF (x /= INT(x)) GO TO 10 !fn_val = 0.d0 !RETURN ! !!       If x < 0, use the reflection formula: !!               gamma(x) * gamma(1-x) = pi * cosec(pi.x) ! !10 reflect = (x < 0.d0) !IF (reflect) THEN !  arg = 1.d0 - x !ELSE !  arg = x !END IF ! !!       Increase the argument, if necessary, to make it > 10. ! !product = 1.d0 !20 IF (arg <= 10.d0) THEN !  product = product * arg !  arg = arg + 1.d0 !  GO TO 20 !END IF ! !!  Use a polynomial approximation to Stirling's formula. !!  N.B. The real Stirling's formula is used here, not the simpler, but less !!       accurate formula given by De Moivre in a letter to Stirling, which !!       is the one usually quoted. ! !arg = arg - 0.5D0 !temp = 1.d0/arg**2 !fn_val = lnrt2pi + arg * (LOG(arg) - 1.d0 + & !                  (((a4*temp + a3)*temp + a2)*temp + a1)*temp) - LOG(product) !IF (reflect) THEN !  temp = SIN(pi * x) !  fn_val = LOG(pi/temp) - fn_val !END IF !RETURN !END FUNCTION lngamma ! ! ! !FUNCTION random_binomial2(n, pp, first) RESULT(ival) !!********************************************************************** !!     Translated to Fortran 90 by Alan Miller from: !!                              RANLIB !! !!     Library of Fortran Routines for Random Number Generation !! !!                      Compiled and Written by: !! !!                           Barry W. Brown !!                            James Lovato !! !!               Department of Biomathematics, Box 237 !!               The University of Texas, M.D. Anderson Cancer Center !!               1515 Holcombe Boulevard !!               Houston, TX      77030 !! !! This work was supported by grant CA-16672 from the National Cancer Institute. ! !!                    GENerate BINomial random deviate ! !!                              Function ! !!     Generates a single random deviate from a binomial !!     distribution whose number of trials is N and whose !!     probability of an event in each trial is P. ! !!                              Arguments ! !!     N  --> The number of trials in the binomial distribution !!            from which a random deviate is to be generated. !!                              INTEGER N ! !!     P  --> The probability of an event in each trial of the !!            binomial distribution from which a random deviate !!            is to be generated. !!                              REAL P ! !!     FIRST --> Set FIRST = .TRUE. for the first call to perform initialization !!               the set FIRST = .FALSE. for further calls using the same pair !!               of parameter values (N, P). !!                              LOGICAL FIRST ! !!     random_binomial2 <-- A random deviate yielding the number of events !!                from N independent trials, each of which has !!                a probability of event P. !!                              INTEGER random_binomial ! !!                              Method ! !!     This is algorithm BTPE from: ! !!         Kachitvichyanukul, V. and Schmeiser, B. W. !!         Binomial Random Variate Generation. !!         Communications of the ACM, 31, 2 (February, 1988) 216. ! !!********************************************************************** ! !!*****DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY ! !!     .. !!     .. Scalar Arguments .. !REAL, INTENT(IN)    :: pp !INTEGER, INTENT(IN) :: n !LOGICAL, INTENT(IN) :: first !INTEGER             :: ival !!     .. !!     .. Local Scalars .. !REAL            :: alv, amaxp, f, f1, f2, u, v, w, w2, x, x1, x2, ynorm, z, z2 !REAL, PARAMETER :: zero = 0.0, half = 0.5, one = 1.0 !INTEGER         :: i, ix, ix1, k, mp !INTEGER, SAVE   :: m !REAL, SAVE      :: p, q, xnp, ffm, fm, xnpq, p1, xm, xl, xr, c, al, xll,  & !                   xlr, p2, p3, p4, qn, r, g ! !!     .. !!     .. Executable Statements .. ! !!*****SETUP, PERFORM ONLY WHEN PARAMETERS CHANGE ! !IF (first) THEN !  p = MIN(pp, one-pp) !  q = one - p !  xnp = n * p !END IF ! !IF (xnp > 30.) THEN !  IF (first) THEN !    ffm = xnp + p !    m = ffm !    fm = m !    xnpq = xnp * q !    p1 = INT(2.195*SQRT(xnpq) - 4.6*q) + half !    xm = fm + half !    xl = xm - p1 !    xr = xm + p1 !    c = 0.134 + 20.5 / (15.3 + fm) !    al = (ffm-xl) / (ffm - xl*p) !    xll = al * (one + half*al) !    al = (xr - ffm) / (xr*q) !    xlr = al * (one + half*al) !    p2 = p1 * (one + c + c) !    p3 = p2 + c / xll !    p4 = p3 + c / xlr !  END IF ! !!*****GENERATE VARIATE, Binomial mean at least 30. ! !  20 CALL RANDOM_NUMBER(u) !  u = u * p4 !  CALL RANDOM_NUMBER(v) ! !!     TRIANGULAR REGION ! !  IF (u <= p1) THEN !    ix = xm - p1 * v + u !    GO TO 110 !  END IF ! !!     PARALLELOGRAM REGION ! !  IF (u <= p2) THEN !    x = xl + (u-p1) / c !    v = v * c + one - ABS(xm-x) / p1 !    IF (v > one .OR. v <= zero) GO TO 20 !    ix = x !  ELSE ! !!     LEFT TAIL ! !    IF (u <= p3) THEN !      ix = xl + LOG(v) / xll !      IF (ix < 0) GO TO 20 !      v = v * (u-p2) * xll !    ELSE ! !!     RIGHT TAIL ! !      ix = xr - LOG(v) / xlr !      IF (ix > n) GO TO 20 !      v = v * (u-p3) * xlr !    END IF !  END IF ! !!*****DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST ! !  k = ABS(ix-m) !  IF (k <= 20 .OR. k >= xnpq/2-1) THEN ! !!     EXPLICIT EVALUATION ! !    f = one !    r = p / q !    g = (n+1) * r !    IF (m < ix) THEN !      mp = m + 1 !      DO i = mp, ix !        f = f * (g/i-r) !      END DO ! !    ELSE IF (m > ix) THEN !      ix1 = ix + 1 !      DO i = ix1, m !        f = f / (g/i-r) !      END DO !    END IF ! !    IF (v > f) THEN !      GO TO 20 !    ELSE !      GO TO 110 !    END IF !  END IF ! !!     SQUEEZING USING UPPER AND LOWER BOUNDS ON LOG(F(X)) ! !  amaxp = (k/xnpq) * ((k*(k/3. + .625) + .1666666666666)/xnpq + half) !  ynorm = -k * k / (2.*xnpq) !  alv = LOG(v) !  IF (alv<ynorm - amaxp) GO TO 110 !  IF (alv>ynorm + amaxp) GO TO 20 ! !!     STIRLING'S (actually de Moivre's) FORMULA TO MACHINE ACCURACY FOR !!     THE FINAL ACCEPTANCE/REJECTION TEST ! !  x1 = ix + 1 !  f1 = fm + one !  z = n + 1 - fm !  w = n - ix + one !  z2 = z * z !  x2 = x1 * x1 !  f2 = f1 * f1 !  w2 = w * w !  IF (alv - (xm*LOG(f1/x1) + (n-m+half)*LOG(z/w) + (ix-m)*LOG(w*p/(x1*q)) +    & !      (13860.-(462.-(132.-(99.-140./f2)/f2)/f2)/f2)/f1/166320. +               & !      (13860.-(462.-(132.-(99.-140./z2)/z2)/z2)/z2)/z/166320. +                & !      (13860.-(462.-(132.-(99.-140./x2)/x2)/x2)/x2)/x1/166320. +               & !      (13860.-(462.-(132.-(99.-140./w2)/w2)/w2)/w2)/w/166320.) > zero) THEN !    GO TO 20 !  ELSE !    GO TO 110 !  END IF ! !ELSE !!     INVERSE CDF LOGIC FOR MEAN LESS THAN 30 !  IF (first) THEN !    qn = q ** n !    r = p / q !    g = r * (n+1) !  END IF ! !  90 ix = 0 !  f = qn !  CALL RANDOM_NUMBER(u) !  100 IF (u >= f) THEN !    IF (ix > 110) GO TO 90 !    u = u - f !    ix = ix + 1 !    f = f * (g/ix - r) !    GO TO 100 !  END IF !END IF ! !110 IF (pp > half) ix = n - ix !ival = ix !RETURN ! !END FUNCTION random_binomial2 ! ! ! ! !FUNCTION random_neg_binomial(sk, p) RESULT(ival) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM NEGATIVE BINOMIAL VARIATE USING UNSTORED !! INVERSION AND/OR THE REPRODUCTIVE PROPERTY. ! !!    SK = NUMBER OF FAILURES REQUIRED (Dagpunar's words!) !!       = the `power' parameter of the negative binomial !!           (0 < REAL) !!    P = BERNOULLI SUCCESS PROBABILITY !!           (0 < REAL < 1) ! !! THE PARAMETER H IS SET SO THAT UNSTORED INVERSION ONLY IS USED WHEN P <= H, !! OTHERWISE A COMBINATION OF UNSTORED INVERSION AND !! THE REPRODUCTIVE PROPERTY IS USED. ! !REAL, INTENT(IN)   :: sk, p !INTEGER            :: ival ! !!     Local variables !! THE PARAMETER ULN = -LOG(MACHINE'S SMALLEST REAL NUMBER). ! !REAL, PARAMETER    :: h = 0.7 !REAL               :: q, x, st, uln, v, r, s, y, g !INTEGER            :: k, i, n ! !IF (sk <= zero .OR. p <= zero .OR. p >= one) THEN !  WRITE(*, *) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' !  STOP !END IF ! !q = one - p !x = zero !st = sk !IF (p > h) THEN !  v = one/LOG(p) !  k = st !  DO i = 1,k !    DO !      CALL RANDOM_NUMBER(r) !      IF (r > zero) EXIT !    END DO !    n = v*LOG(r) !    x = x + n !  END DO !  st = st - k !END IF ! !s = zero !uln = -LOG(vsmall) !IF (st > -uln/LOG(q)) THEN !  WRITE(*, *) ' P IS TOO LARGE FOR THIS VALUE OF SK' !  STOP !END IF ! !y = q**st !g = st !CALL RANDOM_NUMBER(r) !DO !  IF (y > r) EXIT !  r = r - y !  s = s + one !  y = y*p*g/s !  g = g + one !END DO ! !ival = x + s + half !RETURN !END FUNCTION random_neg_binomial ! ! ! !FUNCTION random_von_Mises(k, first) RESULT(fn_val) ! !!     Algorithm VMD from: !!     Dagpunar, J.S. (1990) `Sampling from the von Mises distribution via a !!     comparison of random numbers', J. of Appl. Statist., 17, 165-168. ! !!     Fortran 90 code by Alan Miller !!     CSIRO Division of Mathematical & Information Sciences ! !!     Arguments: !!     k (real)        parameter of the von Mises distribution. !!     first (logical) set to .TRUE. the first time that the function !!                     is called, or the first time with a new value !!                     for k.   When first = .TRUE., the function sets !!                     up starting values and may be very much slower. ! !REAL, INTENT(IN)     :: k !LOGICAL, INTENT(IN)  :: first !REAL                 :: fn_val ! !!     Local variables ! !INTEGER          :: j, n !INTEGER, SAVE    :: nk !REAL, PARAMETER  :: pi = 3.14159265 !REAL, SAVE       :: p(20), theta(0:20) !REAL             :: sump, r, th, lambda, rlast !REAL (dp)        :: dk ! !IF (first) THEN                        ! Initialization, if necessary !  IF (k < zero) THEN !    WRITE(*, *) '** Error: argument k for random_von_Mises = ', k !    RETURN !  END IF ! !  nk = k + k + one !  IF (nk > 20) THEN !    WRITE(*, *) '** Error: argument k for random_von_Mises = ', k !    RETURN !  END IF ! !  dk = k !  theta(0) = zero !  IF (k > half) THEN ! !!     Set up array p of probabilities. ! !    sump = zero !    DO j = 1, nk !      IF (j < nk) THEN !        theta(j) = ACOS(one - j/k) !      ELSE !        theta(nk) = pi !      END IF ! !!     Numerical integration of e&#94;[k.cos(x)] from theta(j-1) to theta(j) ! !      CALL integral(theta(j-1), theta(j), p(j), dk) !      sump = sump + p(j) !    END DO !    p(1:nk) = p(1:nk) / sump !  ELSE !    p(1) = one !    theta(1) = pi !  END IF                         ! if k > 0.5 !END IF                           ! if first ! !CALL RANDOM_NUMBER(r) !DO j = 1, nk !  r = r - p(j) !  IF (r < zero) EXIT !END DO !r = -r/p(j) ! !DO !  th = theta(j-1) + r*(theta(j) - theta(j-1)) !  lambda = k - j + one - k*COS(th) !  n = 1 !  rlast = lambda ! !  DO !    CALL RANDOM_NUMBER(r) !    IF (r > rlast) EXIT !    n = n + 1 !    rlast = r !  END DO ! !  IF (n .NE. 2*(n/2)) EXIT         ! is n even? !  CALL RANDOM_NUMBER(r) !END DO ! !fn_val = SIGN(th, (r - rlast)/(one - rlast) - half) !RETURN !END FUNCTION random_von_Mises ! ! ! !SUBROUTINE integral(a, b, result, dk) ! !!     Gaussian integration of exp(k.cosx) from a to b. ! !REAL (dp), INTENT(IN) :: dk !REAL, INTENT(IN)      :: a, b !REAL, INTENT(OUT)     :: result ! !!     Local variables ! !REAL (dp)  :: xmid, range, x1, x2,                                    & !  x(3) = (/0.238619186083197_dp, 0.661209386466265_dp, 0.932469514203152_dp/), & !  w(3) = (/0.467913934572691_dp, 0.360761573048139_dp, 0.171324492379170_dp/) !INTEGER    :: i ! !xmid = (a + b)/2._dp !range = (b - a)/2._dp ! !result = 0._dp !DO i = 1, 3 !  x1 = xmid + x(i)*range !  x2 = xmid - x(i)*range !  result = result + w(i)*(EXP(dk*COS(x1)) + EXP(dk*COS(x2))) !END DO ! !result = result * range !RETURN !END SUBROUTINE integral ! ! ! !FUNCTION random_Cauchy() RESULT(fn_val) ! !!     Generate a random deviate from the standard Cauchy distribution ! !REAL     :: fn_val ! !!     Local variables !REAL     :: v(2) ! !DO !  CALL RANDOM_NUMBER(v) !  v = two*(v - half) !  IF (ABS(v(2)) < vsmall) CYCLE               ! Test for zero !  IF (v(1)**2 + v(2)**2 < one) EXIT !END DO !fn_val = v(1) / v(2) ! !RETURN !END FUNCTION random_Cauchy end module","loc":"sourcefile/m_random.f90.html"},{"tags":"","title":"m_BinarySearch.f90 – Fortran Program","text":"Modules m_BinarySearch Source Code m_BinarySearch.f90 Source Code module m_BinarySearch !! Contains routines to perform a simple binary search on a vector use variableKind implicit none private public :: binarySearch public :: binarySearch_wNeighbours interface binarySearch !! Perform a binary search !! !! Example usage !!```fortran !!use variableKind !!use m_BinarySearch, only: binarySearch !!real(r64) :: arr(20) !!integer(i32) :: i !!integer(i32) :: j !!arr=[(dble(i), i = 1, 20)] !!j = binarySearch(arr, 10.d0, 1, 20) !!write(*,*) 'Location of 10.0 in arr is 10? ',j == 10 !!``` module procedure :: binarySearch_r1D , binarySearch_d1D , binarySearch_i1D , binarySearch_id1D end interface interface binarySearch_wNeighbours !! Perform a binary search but also return the neighbours. !! This is useful if you need to find a number that is not contained in the array and you want the interval !! !! Example usage !!```fortran !!use variableKind !!use m_BinarySearch, only: binarySearch_wNeighbours !!real(r64) :: arr(20) !!integer(i32) :: i !!integer(i32) :: j(3) !!arr=[(dble(i), i = 1, 20)] !!j = binarySearch_wNeighbours(arr, 10.5d0, 1, 20) !!write(*,*) 'Location of 10.5 in arr is -1? ',j(1) == -1 !!write(*,*) 'The interval containing 10.5 is [10,11]? ',j(2:3) == [10,11] !!``` module procedure :: binarySearch_wNeighbours_r1D , binarySearch_wNeighbours_d1D , binarySearch_wNeighbours_i1D , binarySearch_wNeighbours_id1D end interface contains !====================================================================! recursive function binarySearch_i1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! integer ( i32 ) :: this (:) !! Vector to search within integer ( i32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present if ( imax < imin ) then iout =- 1 return else ! Cut the search in half iout = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ) > v ) then ! Result is in lower subset iout = binarySearch_i1D ( this , v , imin , iout - 1 ) elseif ( this ( iout ) < v ) then ! Result is in upper subset iout = binarySearch_i1D ( this , v , iout + 1 , imax ) else ! Result has been found return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_id1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! integer ( i64 ) :: this (:) !! Vector to search within integer ( i64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present if ( imax < imin ) then iout =- 1 return else ! Cut the search in half iout = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ) > v ) then ! Result is in lower subset iout = binarySearch_id1D ( this , v , imin , iout - 1 ) elseif ( this ( iout ) < v ) then ! Result is in upper subset iout = binarySearch_id1D ( this , v , iout + 1 , imax ) else ! Result has been found return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_r1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! real ( r32 ) :: this (:) !! Vector to search within real ( r32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present if ( imax < imin ) then iout =- 1 return else ! Cut the search in half iout = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ) > v ) then ! Result is in lower subset iout = binarySearch_r1D ( this , v , imin , iout - 1 ) elseif ( this ( iout ) < v ) then ! Result is in upper subset iout = binarySearch_r1D ( this , v , iout + 1 , imax ) else ! Result has been found return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_d1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! real ( r64 ) :: this (:) !! Vector to search within real ( r64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present if ( imax < imin ) then iout =- 1 return else ! Cut the search in half iout = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ) > v ) then ! Result is in lower subset iout = binarySearch_d1D ( this , v , imin , iout - 1 ) elseif ( this ( iout ) < v ) then ! Result is in upper subset iout = binarySearch_d1D ( this , v , iout + 1 , imax ) else ! Result has been found return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_wNeighbours_i1D ( this , v , imin , imax ) result ( iout ) !! Perform a binary search on an integer vector !! Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours !! The first entry of iout is -1 if the value is not present in the vector !! Assumes this is sorted! !====================================================================! integer ( i32 ) :: this (:) !! Vector to search within integer ( i32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval if ( imax < imin ) then iout ( 2 ) = imax ; iout ( 3 ) = imin iout ( 1 ) =- 1 return else ! Cut the search in half iout ( 1 ) = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ( 1 )) > v ) then ! Result is in lower subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_i1D ( this , v , imin , iout ( 1 ) - 1 ) elseif ( this ( iout ( 1 )) < v ) then ! Result is in upper subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_i1D ( this , v , iout ( 1 ) + 1 , imax ) else ! Result has been found iout ( 2 ) = iout ( 1 ) - 1 iout ( 2 ) = max ( 1 , iout ( 2 )) iout ( 3 ) = iout ( 1 ) + 1 iout ( 3 ) = min ( size ( this ), iout ( 3 )) return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_wNeighbours_id1D ( this , v , imin , imax ) result ( iout ) !! Perform a binary search on an integer vector !! Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours !! The first entry of iout is -1 if the value is not present in the vector !! Assumes this is sorted! !====================================================================! integer ( i64 ) :: this (:) !! Vector to search within integer ( i64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval if ( imax < imin ) then iout ( 2 ) = imax ; iout ( 3 ) = imin iout ( 1 ) =- 1 return else ! Cut the search in half iout ( 1 ) = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ( 1 )) > v ) then ! Result is in lower subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_id1D ( this , v , imin , iout ( 1 ) - 1 ) elseif ( this ( iout ( 1 )) < v ) then ! Result is in upper subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_id1D ( this , v , iout ( 1 ) + 1 , imax ) else ! Result has been found iout ( 2 ) = iout ( 1 ) - 1 iout ( 2 ) = max ( 1 , iout ( 2 )) iout ( 3 ) = iout ( 1 ) + 1 iout ( 3 ) = min ( size ( this ), iout ( 3 )) return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_wNeighbours_r1D ( this , v , imin , imax ) result ( iout ) !! Perform a binary search on a double precision vector !! Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours !! The first entry of iout is -1 if the value is not present in the vector !! Assumes this is sorted! !====================================================================! real ( r32 ) :: this (:) !! Vector to search within real ( r32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval if ( imax < imin ) then iout ( 2 ) = imax ; iout ( 3 ) = imin iout ( 1 ) =- 1 return else ! Cut the search in half iout ( 1 ) = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ( 1 )) > v ) then ! Result is in lower subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_r1D ( this , v , imin , iout ( 1 ) - 1 ) elseif ( this ( iout ( 1 )) < v ) then ! Result is in upper subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_r1D ( this , v , iout ( 1 ) + 1 , imax ) else ! Result has been found iout ( 2 ) = iout ( 1 ) - 1 iout ( 2 ) = max ( 1 , iout ( 2 )) iout ( 3 ) = iout ( 1 ) + 1 iout ( 3 ) = min ( size ( this ), iout ( 3 )) return endif endif end function !====================================================================! !====================================================================! recursive function binarySearch_wNeighbours_d1D ( this , v , imin , imax ) result ( iout ) !! Perform a binary search on a double precision vector !! Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours !! The first entry of iout is -1 if the value is not present in the vector !! Assumes this is sorted! !====================================================================! real ( r64 ) :: this (:) !! Vector to search within real ( r64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval if ( imax < imin ) then iout ( 2 ) = imax ; iout ( 3 ) = imin iout ( 1 ) =- 1 return else ! Cut the search in half iout ( 1 ) = ( imax + imin ) / 2 ! Three-Way Comparison if ( this ( iout ( 1 )) > v ) then ! Result is in lower subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_d1D ( this , v , imin , iout ( 1 ) - 1 ) elseif ( this ( iout ( 1 )) < v ) then ! Result is in upper subset iout ( 2 ) = imin ; iout ( 3 ) = imax iout = binarySearch_wNeighbours_d1D ( this , v , iout ( 1 ) + 1 , imax ) else ! Result has been found iout ( 2 ) = iout ( 1 ) - 1 iout ( 2 ) = max ( 1 , iout ( 2 )) iout ( 3 ) = iout ( 1 ) + 1 iout ( 3 ) = min ( size ( this ), iout ( 3 )) return endif endif end function !====================================================================! end module","loc":"sourcefile/m_binarysearch.f90.html"},{"tags":"","title":"m_SimpleSearch.f90 – Fortran Program","text":"Modules m_simpleSearch Source Code m_SimpleSearch.f90 Source Code module m_simpleSearch !! Contains simple search routines implicit none private public simpleSearch interface simpleSearch module procedure :: simpleSearch_i1D end interface contains !====================================================================! function simpleSearch_i1D ( this , i ) result ( iout ) !! Simple search over an integer vector !====================================================================! integer ( i32 ) :: this (:) !! Search this vector integer ( i32 ) :: i !! Number to find in the vector integer ( i32 ) :: iout !! Location of i in this integer ( i32 ) :: ii integer ( i32 ) :: N N = size ( this ) iout =- 1 do ii = 1 , N if ( this ( ii ) == i ) then iout = ii return endif enddo end function !====================================================================! end module","loc":"sourcefile/m_simplesearch.f90.html"},{"tags":"","title":"m_medianOf3.f90 – Fortran Program","text":"Modules m_medianOf3 Source Code m_medianOf3.f90 Source Code module m_medianOf3 !! Given three numbers, find their median and sort at the same time use variableKind use m_swap , only : swap implicit none private public medianOf3 interface medianOf3 !! Sort three numbers in an array and return the location of the median module procedure :: medianOf3_r1D , medianOf3_d1D , medianOf3_i1D , medianOf3_id1D end interface public argMedianOf3 interface argMedianOf3 !! Sort the indices of three numbers into an array and return the location of the median module procedure :: argMedianOf3_r1D , argMedianOf3_d1D , argMedianOf3_i1D , argMedianOf3_id1D end interface contains !====================================================================! subroutine medianOf3_r1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! real ( r32 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine medianOf3_d1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! real ( r64 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine medianOf3_i1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! integer ( i32 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine medianOf3_id1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! integer ( i64 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_r1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! real ( r32 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_d1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! real ( r64 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_i1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! integer ( i32 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_id1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! integer ( i64 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! end module","loc":"sourcefile/m_medianof3.f90.html"},{"tags":"","title":"m_select.f90 – Fortran Program","text":"Modules m_select Source Code m_select.f90 Source Code module m_select !! Perform a quickselect on an array. Quick select finds the kth smallest number in an array. It also puts values lower than the kth on the left, and those higher on the right !! This makes it perfect for finding the median. use variableKind implicit none private public :: select interface select !!Use an in-place quick select on an array of numbers !! !!Example usage !!```fortran !!program selectTest !!use variableKind !!use m_strings, only: str !!use m_allocate, only: allocate !!use m_random, only: rngInteger,rngNormal !!use m_select, only: select !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32) :: k !!real(r64) :: dv !!integer(i32) :: iv !! !!write(*,'(a)') 'Select the kth smallest element from a 10000 length array of random double precision numbers' !!call allocate(d1D, 10000) !!call rngNormal(d1D) !!k = (1+size(d1D))/2 !!dv = select(d1D,k) !!write(*,'(a)') 'kth element? '//str(dv) !!write(*,'(a)') 'Select the kth smallest element from a 10000 length array of random integers'' !!call allocate(i1D, 10000) !!call rngInteger(i1D) !!iv = select(i1D, k) !!write(*,'(a)') 'kth element? '//str(iv) !!end program !!``` module subroutine quickSelect_i1D ( this , k , res ) !! Interfaced with select() integer ( i32 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res end subroutine module subroutine quickSelect_id1D ( this , k , res ) !! Interfaced with select() integer ( i64 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i64 ) :: res end subroutine module subroutine quickSelect_r1D ( this , k , res ) !! Interfaced with select() real ( r32 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element real ( r32 ) :: res end subroutine module subroutine quickSelect_d1D ( this , k , res ) !! Interfaced with select() real ( r64 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element real ( r64 ) :: res end subroutine end interface public :: argSelect interface argSelect !!Use an indirect introspection sort on an array of numbers !! !!Example usage !!```fortran !!program argSortTest !!use variableKind !!use m_strings, only: str !!use m_random, only: rngInteger,rngNormal !!use m_arrays, only: isSorted !!use m_Sort, only: argSort !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32),allocatable :: indx(:) !!integer(i32) :: i, k, N !!N = 10000 !!call allocate(indx,N) !!call arange(indx, 1, N) !!call allocate(d1D,N) !!call rngNormal(d1D) !!k = (size(d1D)+1)/2 !!call argSelect(d1D, indx, k) !!write(*,'(a)') 'Double array is indirectly sorted? '//str(isSorted(d1D(indx))) !! !!call arange(indx, 1, N) !!call allocate(i1D,N) !!call rngInteger(i1D) !!call argSelectt(i1D, indx, k) !!write(*,'(a)') 'Integer array is indirectly sorted? '//str(isSorted(i1D(indx))) !!end program !!``` module subroutine argQuickSelect_i1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine module subroutine argQuickSelect_id1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine module subroutine argQuickSelect_r1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() real ( r32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine module subroutine argQuickSelect_d1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() real ( r64 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine end interface end module","loc":"sourcefile/m_select.f90.html"},{"tags":"","title":"m_sort.f90 – Fortran Program","text":"Modules m_sort Source Code m_sort.f90 Source Code module m_sort !! Module containing in-place and indirect routines to sort an array of numbers. !! !! Uses an introspective sort on a set of number. See this http://www.geeksforgeeks.org/know-your-sorting-algorithm-set-2-introsort-cs-sorting-weapon/ for more information !! !! To begin, a quicksort with a median of three pivot is used until the size of the array is less than 16.  At this point, an insertion sort is used to reduce cache overhead and tail recursion. !! Unfortunately, a quicksort is not ideal for sorted/almost sorted arrays or arrays with duplicate values.  Therefore if the number of iterations exceededs a threshold, a heapsort is used instead. !! This provides a robust sorting algorithm that is still very fast for almost sorted arrays. !! !! In this implementation, the quicksort and heapsort are unstable sorts. A stable merge sort is therefore provided as an alternative but it has an order(N) memory overhead. !! !! Often, the numbers wish to be maintained in their given order, so with an O(N) memory overhead we can sort an integer array instead by calling argsort() !! !! See [[sort]] and [[argSort]] for more information. use variableKind implicit none private public :: sort interface sort !!Use an in-place introspection sort on an array of numbers !! !!Example usage !!```fortran !!program sortTest !!use variableKind, only: i32, r64 !!use m_strings, only: str !!use m_allocate, only: allocate !!use m_random, only: rngInteger, rngNormal !!use m_arrays, only: arange, isSorted !!use m_sort, only: sort !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32) :: N !! !!N = 10000 !!write(*,'(a)') 'In-place sort a 10000 length array of random double precision numbers' !!call allocate(d1D,N) !!call rngNormal(d1D) !!call sort(d1D) !!write(*,'(a)') 'Double array is sorted? '//str(isSorted(d1D)) !!write(*,'(a)') 'In-place sort a 10000 length array of random integers'' !!call allocate(i1D,N) !!call rngInteger(i1D) !!call sort(i1D) !!write(*,'(a)') 'Integer array is sorted? '//str(isSorted(i1D)) !!end program !!``` module subroutine sort_i1D ( this , stable ) !! Interfaced with [[sort]] integer ( i32 ) :: this (:) logical , optional :: stable end subroutine module subroutine sort_id1D ( this , stable ) !! Interfaced with [[sort]] integer ( i64 ) :: this (:) logical , optional :: stable end subroutine module subroutine sort_r1D ( this , stable ) !! Interfaced with [[sort]] real ( r32 ) :: this (:) logical , optional :: stable end subroutine module subroutine sort_d1D ( this , stable ) !! Interfaced with [[sort]] real ( r64 ) :: this (:) logical , optional :: stable end subroutine end interface private :: sort_i1D , sort_id1D , sort_r1D , sort_d1D public :: argSort interface argSort !!Use an indirect introspection sort on an array of numbers !! !!Example usage !!```fortran !!program argSortTest !!use variableKind !!use m_strings, only: str !!use m_random, only: rngInteger, rngNormal !!use m_arrays, only: arange, isSorted !!use m_Sort, only: argSort !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32),allocatable :: indx(:) !!integer(i32) :: i, N !! !!N=10000 !!call allocate(indx, N) !!call arange(indx, 1, N) !!call allocate(d1D, N) !!call rngNormal(d1D) !!call argSort(d1D, indx) !!write(*,'(a)') 'Double array is indirectly sorted? '//str(isSorted(d1D(indx))) !! !!call arange(indx, 1, N) !!call allocate(i1D,N) !!call rngInteger(i1D) !!call argSort(i1D, indx) !!write(*,'(a)') 'Integer array is indirectly sorted? '//str(isSorted(i1D(indx))) !!end program !!``` module subroutine argSort_i1D ( this , i , stable ) !! Interfaced with [[argSort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine module subroutine argSort_id1D ( this , i , stable ) !! Interfaced with [[argSort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine module subroutine argSort_r1D ( this , i , stable ) !! Interfaced with [[argSort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine module subroutine argSort_d1D ( this , i , stable ) !! Interfaced with [[argSort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine end interface private :: argSort_i1D , argSort_id1D , argSort_r1D , argSort_d1D private :: introsort interface introsort !! Perform an in-place introspective sort on an array module subroutine introsort_r1D ( this ) !! Interfaced with [[introsort]] real ( r32 ) :: this (:) !! 1D array end subroutine module subroutine introsort_d1D ( this ) !! Interfaced with [[introsort]] real ( r64 ) :: this (:) !! 1D array end subroutine module subroutine introsort_i1D ( this ) !! Interfaced with [[introsort]] integer ( i32 ) :: this (:) !! 1D array end subroutine module subroutine introsort_id1D ( this ) !! Interfaced with [[introsort]] integer ( i64 ) :: this (:) !! 1D array end subroutine end interface private :: argIntrosort interface argintrosort !! Perform an indirect introsort on an array module subroutine argintrosort_r1D ( this , i ) !! Interfaced with [[argIntrosort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argintrosort_d1D ( this , i ) !! Interfaced with [[argIntrosort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argintrosort_i1D ( this , i ) !! Interfaced with [[argIntrosort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argintrosort_id1D ( this , i ) !! Interfaced with [[argIntrosort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine end interface interface MergeSort !! Perform an in-place stable merge sort on an array module subroutine mergesort_r1D ( this ) !! Interf aced with [[mergesort]] real ( r32 ) :: this (:) !! 1D array end subroutine module subroutine mergesort_d1D ( this ) !! Interfaced with [[mergesort]] real ( r64 ) :: this (:) !! 1D array end subroutine module subroutine mergesort_i1D ( this ) !! Interfaced with [[mergesort]] integer ( i32 ) :: this (:) !! 1D array end subroutine module subroutine mergesort_id1D ( this ) !! Interfaced with [[mergesort]] integer ( i64 ) :: this (:) !! 1D array end subroutine end interface interface argMergeSort !! Perform an indirect stable merge sort on an array module subroutine argmergesort_r1D ( this , i ) !! Interfaced with [[argmergesort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argmergesort_d1D ( this , i ) !! Interfaced with [[argmergesort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argmergesort_i1D ( this , i ) !! Interfaced with [[argmergesort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argmergesort_id1D ( this , i ) !! Interfaced with [[argmergesort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine end interface public :: insertionSort interface insertionsort !! Perform an in-place insertion sort on an array module subroutine insertionsort_r1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine insertionsort_d1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine insertionsort_i1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine insertionsort_id1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine end interface private :: insertionsort_r1D , insertionsort_d1D , insertionsort_i1D , insertionsort_id1D public :: argInsertionsort interface argInsertionsort !! Perform an indirect insertion sort on an array module subroutine argInsertionsort_r1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine argInsertionsort_d1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine argInsertionsort_i1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine argInsertionsort_id1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine end interface private :: argInsertionsort_r1D , argInsertionsort_d1D , argInsertionsort_i1D , argInsertionsort_id1D private :: heapsort interface heapsort !! Perform an in-place heapsort on an array module subroutine heapsort_r1D ( this ) !! Interfaced with heapsort() real ( r32 ) :: this ( 0 :) !! 1D array end subroutine module subroutine heapsort_d1D ( this ) !! Interfaced with heapsort() real ( r64 ) :: this ( 0 :) !! 1D array end subroutine module subroutine heapsort_i1D ( this ) !! Interfaced with heapsort() integer ( i32 ) :: this ( 0 :) !! 1D array end subroutine module subroutine heapsort_id1D ( this ) !! Interfaced with heapsort() integer ( i64 ) :: this ( 0 :) !! 1D array end subroutine end interface private :: argHeapsort interface argHeapsort !! Perform an indirect heapsort on an array module subroutine argHeapsort_r1D ( this , indx ) !! Interfaced with argHeapsort() real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine module subroutine argHeapsort_d1D ( this , indx ) !! Interfaced with argHeapsort() real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine module subroutine argHeapsort_i1D ( this , indx ) !! Interfaced with argHeapsort() integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine module subroutine argHeapsort_id1D ( this , indx ) !! Interfaced with argHeapsort() integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine end interface end module","loc":"sourcefile/m_sort.f90.html"},{"tags":"","title":"m_KdTree.f90 – Fortran Program","text":"Modules m_KdTree Source Code m_KdTree.f90 Source Code module m_KdTree !!Module contains classes to create K-dimensional trees in 2, 3, and N dimensions. !! !!This KdTree is balanced, in that splits are made along the dimension with the largest variance. A quickselect is used to find the median in that split dimension as the splitting value. !! !!After the tree is initialized, for a given set of points, a search class can be used to perform nearest neighbour, range search, k nearest neighbours etc. !!The searches are thread safe and can be used in a parallel region if multiple are needed. !! !!Once a tree is generated, the point coordinates should not be changed, otherwise the tree will no longer be correct. !! !!Generating the tree does not modify the incoming point coordinates. !! !!Example !!```fortran !!program kdTree_test !!use variableKind, only: r64 !!use m_allocate, only: allocate !!use m_deallocate, only: deallocate !!use m_random, only: rngNormal !!use m_KdTree, only: KdTree, KdTreeSearch !!use m_string, only: str !!implicit none !!real(r64), allocatable :: x(:), y(:) !!integer(i32) :: N !!type(KdTree) :: tree !!type(KdSearch) :: search !! !!N = 1d6 !!call allocate(x, N) !!call allocate(y, N) !!call rngNormal(x) !!call rngNormal(y) !!call tree%init(x, y) !!ia = search%kNearest(tree, x, y, xQuery=0.d0, yQuery=0.d0) !!write(*,'(3a)')'Nearest point to the query location: ', str(x(ia)), str(y(ia)) !!call tree%deallocate() !!call deallocate(x) !!call deallocate(y) !!end program !!``` use variableKind , only : i32 , r64 use m_errors , only : mErr use m_allocate , only : allocate use m_deallocate , only : deallocate use m_array1D , only : arange use m_random , only : rngNormal use m_select , only : argSelect use m_maths , only : variance implicit none private !====================================================================! ! Type Definitions !====================================================================! !====================================================================! type , private :: KdTreebranch private !! A branch of the tree, could be a leaf, or branch integer ( i32 ) :: splitAlong !index of median in dat d real ( r64 ) :: median !median value in dat x integer ( i32 ) :: left , right ! left and right indices type ( KdTreeBranch ), pointer :: buds (:) => null () contains procedure :: init => init_branch procedure :: deallocate => deallocate_branch end type !====================================================================! !====================================================================! type , public :: KdTree !!KdTree in 2, 3, or N dimensions.  See [[m_KdTree]] for more information on how to use this class. private type ( KdTreebranch ) :: trunk integer ( i32 ), allocatable :: indx (:) integer ( i32 ) :: nDims integer ( i32 ) :: N logical ( i32 ) :: set = . false . contains generic , public :: init => ikdt2 !! KdTree%init() - Initialize the class procedure , private :: ikdt2 => init2D_KdTree !  procedure :: isSet => isSet_KdTree procedure , public :: deallocate => deallocate_KdTree !! kdTree%deallocate() - deallocate the recursive pointers end type !====================================================================! !====================================================================! type , public :: KdTreeSearch !!Class to search a KdTree.  See [[m_KdTree]] for more information on how to use this class. private integer ( i32 ) :: currentNearest real ( r64 ) :: distance contains procedure , public :: init => init_KdTreeSearch !! Initialize the class generic , public :: kNearest => kNearest2D !! Perform a k nearest neighbour search procedure , private :: kNearest2D => kNearest_2D end type !====================================================================! !====================================================================! ! Interface definitions !====================================================================! interface !====================================================================! module subroutine init_branch ( this , left , right ) !! Overloaded Type bound procedure KdTreeBranch%init() !====================================================================! class ( KdTreebranch ) :: this !! KdTreeBranch class integer ( i32 ), intent ( in ) :: left !! Left index, first call normally = 1 integer ( i32 ), intent ( in ) :: right !! Right index, first call normally = size of coordinates end subroutine !====================================================================! end interface interface !====================================================================! module recursive subroutine deallocate_branch ( this ) !====================================================================! class ( KdTreebranch ) :: this !! KdTreeBranch class end subroutine !====================================================================! end interface interface !====================================================================! module subroutine init2D_KdTree ( this , x , y ) !! Overloaded Type bound procedure KdTree%init() !====================================================================! class ( kdTree ) :: this !! KdTree Class real ( r64 ), intent ( in ) :: x (:) !! x-coordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y-coordinates of the points end subroutine !====================================================================! end interface interface !====================================================================! module subroutine deallocate_KdTree ( this ) !! Overloaded Type bound procedure KdTree%deallocate() !====================================================================! class ( KdTree ) :: this !! KdTree Class end subroutine !====================================================================! end interface interface !====================================================================! module subroutine init_KdTreeSearch ( this ) !! Overloaded Type bound procedure KdTreeSearch%init() !====================================================================! class ( KdTreeSearch ) :: this !! KdTreeSearch class end subroutine !====================================================================! end interface interface !====================================================================! module function kNearest_2D ( search , tree , x , y , xQuery , yQuery ) result ( nearest ) !! Overloaded Type bound procedure KdTreeSearch%kNearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points real ( r64 ), intent ( in ) :: xQuery !! x co-ordinate of the query location real ( r64 ), intent ( in ) :: yQuery !! y co-ordinate of the query location integer ( i32 ) :: nearest !! Index of the nearest point to the query location end function !====================================================================! end interface !  !====================================================================! !  !====================================================================! !  ! 3-Dimensional KD tree using 3 1D arrays as input !  !====================================================================! !  !====================================================================! !  !====================================================================! !  function SearchKD_3D(srch,kd,x,y,z,xq,yq,zq) result(iNear) !  !====================================================================! !  class(kdSearch) :: srch !  class(kdTree),intent(in) :: kd !  real(r64),intent(in) :: x(:),y(:),z(:) !  real(r64),intent(in) :: xq,yq,zq !  integer :: iNear !  call srch%set() !  iNear=findNearestFast(kd%trunk, x,y,z, kd%indx, xq,yq,zq, srch%cn, srch%cndiff) !  iNear=kd%indx(iNear) !  end function !  !====================================================================! !  !====================================================================! !  subroutine setTree_3D(this,x,y,z) !  !====================================================================! !  class(kdTree) :: this !  real(r64),intent(in) :: x(:),y(:),z(:) ! !  integer :: i,istat !  ! Initialize the number of entries and dimensions of the tree !  this%N=size(x);this%nDims=3 !  ! Set the root node !  call this%trunk%set(1,this%N) !  ! Allocated and initialize the indexer !  if (allocated(this%indx)) deallocate(this%indx) !  allocate(this%indx(this%N),stat=istat) !  call Merr(istat,'setTree','indx') !  this%indx=[(i,i=1,this%N)] !  ! Grow the KD tree !  call growTree(this%trunk,x,y,z,this%indx) !  this%kdSet=.true. !  end subroutine !  !====================================================================! !  !====================================================================! !  recursive subroutine growTree_3D(root, x,y,z, indx) !  !====================================================================! !  class(node) :: root !  real(r64),intent(in) :: x(:),y(:),z(:) !  integer :: indx(:) ! !  integer :: bucketMax, d, nDims, medIndex, sz !  real(r64) :: spreadMax, var ! !  bucketMax = 5 !  nDims = 3 !  sz = trunk%maxx-trunk%minn+1 !  medIndex = (trunk%minn+trunk%maxx)/2 !  if (sz>bucketMax) then !    spreadMax=0.d0 !    var=variance(x(trunk%minn:trunk%maxx)) !    if (var>spreadMax) then !      spreadMax=var !      d=1 !    end if !    var=variance(y(trunk%minn:trunk%maxx)) !    if (var>spreadMax) then !      spreadMax=var !      d=2 !    end if !    var=variance(z(trunk%minn:trunk%maxx)) !    if (var>spreadMax) then !      spreadMax=var !      d=3 !    end if !    trunk%d = d !    select case(d) !    case(1) !      ! Quick sort the current chunk of the data !      call partialQuickSort(x,indx, trunk%minn, trunk%maxx, medIndex-trunk%minn) !      trunk%x = x(indx(medIndex)) !    case(2) !      call partialQuickSort(y,indx, trunk%minn, trunk%maxx, medIndex-trunk%minn) !      trunk%x = y(indx(medIndex)) !    case(3) !      call partialQuickSort(z,indx, trunk%minn, trunk%maxx, medIndex-trunk%minn) !      trunk%x = z(indx(medIndex)) !    end select ! !    ! Allocate the children nodes !    allocate(trunk%kiddos(2)) !    ! Initialize the children nodes !    call trunk%kiddos(1)%set(trunk%minn,medIndex) !    call trunk%kiddos(2)%set(medIndex+1,trunk%maxx) !    ! Grow the tree through the new branches !    call growTree(trunk%kiddos(1),x,y,z,indx) !    call growTree(trunk%kiddos(2),x,y,z,indx) !  end if !  end subroutine !  !====================================================================! !  !====================================================================! !  recursive function findNearestFast_3D(root,x,y,z,indx,xq,yq,zq,cn,cndiff) result(nrst) !  !====================================================================! !  class(node),intent(in) :: root !  real(r64),intent(in) :: x(:),y(:),z(:) !  integer,intent(in) :: indx(:) !  real(r64),intent(in) :: xq,yq,zq !  integer :: cn !  real(r64) :: cndiff !  integer :: nrst ! !  real(r64) :: cnsqdiff,q ! !  ! If the node is not associated, we are at a leaf. !  ! Cycle through its buds !  if (.not. associated(trunk%kiddos)) then !    cn = findNearestSLOW(x,y,z, indx, trunk%minn, trunk%maxx,xq,yq,zq, cn) ! !    cnsqdiff=(xq-x(indx(cn)))**2.d0+(yq-y(indx(cn)))**2.d0+(zq-z(indx(cn)))**2.d0 !    cndiff = dsqrt(cnsqdiff) !  else !    q=xq !    select case(trunk%d) !    case(1) !      q=xq !    case(2) !      q=yq !    case(3) !      q=zq !    end select !    if (q<=trunk%x) then !      cn = findNearestFAST(trunk%kiddos(1), x,y,z, indx, xq,yq,zq, cn, cndiff) !      if ((q+cndiff)>=trunk%x) then !        cn = findNearestFAST(trunk%kiddos(2), x,y,z, indx, xq,yq,zq, cn, cndiff) !      end if !    else !      cn = findNearestFAST(trunk%kiddos(2), x,y,z, indx, xq,yq,zq, cn, cndiff) !      if ((q-cndiff)<=trunk%x) then !        cn = findNearestFAST(trunk%kiddos(1), x,y,z, indx, xq,yq,zq, cn, cndiff) !      end if !    end if !  end if !  nrst = cn !  end function !  !====================================================================! !  !====================================================================! !  function findNearestSLOW_3D (x,y,z, indx, minn, maxx,xq,yq,zq, cn) result(nrst) !  !====================================================================! !  real(r64),intent(in) :: x(:),y(:),z(:) !  integer,intent(in) :: indx(:) !  integer,intent(in) :: maxx,minn !  real(r64),intent(in) :: xq,yq,zq !  integer,intent(in) :: cn !  integer :: nrst ! !  integer :: i,nDims !  real(r64) ::  sqdiff,minsqdiff ! !  ! Get the number of dimensions in the KD tree !  nDims=3 ! !  ! If cn is zero, we went straight to a leaf node !  if (cn==0) then !    i=minn !  else !    i=cn !  end if ! !  sqdiff=(xq-x(indx(i)))**2.d0+(yq-y(indx(i)))**2.d0+(zq-z(indx(i)))**2.d0 ! !  minsqdiff = sqdiff !  nrst = i ! !  do i=minn, maxx !    sqdiff=(xq-x(indx(i)))**2.d0+(yq-y(indx(i)))**2.d0+(zq-z(indx(i)))**2.d0 !    if (sqdiff<minsqdiff) then !      minsqdiff=sqdiff !      nrst=i !    end if !  end do !  end function !  !====================================================================! !  !====================================================================! !  !====================================================================! !  ! N-Dimensional KD tree using a 2D array as input !  !====================================================================! !  !====================================================================! !  !====================================================================! !  function SearchKD_nD(srch,kd,this,q) result(iNear) !  !====================================================================! !  class(kdSearch) :: srch !  class(kdTree),intent(in) :: kd !  real(r64),intent(in) :: this(:,:) !  real(r64),intent(in) :: q(:) !  integer :: iNear !  call srch%set() !  iNear=findNearestFast(kd%trunk, this, kd%indx, q, srch%cn, srch%cndiff) !  iNear=kd%indx(iNear) !  end function !  !====================================================================! !  !====================================================================! !  subroutine setTree_nD(this,arr) !  !====================================================================! !  class(kdTree) :: this !  real(r64),intent(in) :: arr(:,:) ! !  integer :: i,istat !  ! Initialize the number of entries and dimensions of the tree !  this%N=size(arr,1);this%nDims=size(arr,2) !  ! Set the root node !  call this%trunk%set(1,this%N) !  ! Allocated and initialize the indexer !  if (allocated(this%indx)) deallocate(this%indx) !  allocate(this%indx(this%N),stat=istat) !  call Merr(istat,'setTree','indx') !  this%indx=[(i,i=1,this%N)] !  ! Grow the KD tree !  call growTree(this%trunk,arr,this%indx) !  this%kdSet=.true. !  end subroutine !  !====================================================================! !  !====================================================================! !  recursive subroutine growTree_nD(root, dat, indx) !  !====================================================================! !  class(node) :: root !  real(r64),intent(in) :: dat(:,:) !  integer :: indx(:) ! !  integer :: bucketMax, j, d, nDims, medIndex, sz !  real(r64) :: spreadMax, var ! !  bucketMax = 5 !  nDims = size(dat,2) !  sz = trunk%maxx-trunk%minn+1 !  if (sz>bucketMax) then !    d=1 !    if(nDims/=1) then !      spreadMax=0.d0 !      do j=1,nDims !        var=variance(dat(trunk%minn:trunk%maxx,j)) !        if (var>spreadMax) then !          spreadMax=var !          d=j !        end if !      end do !    endif !    medIndex = (trunk%minn+trunk%maxx)/2 !    ! Quick sort the current chunk of the data !    call partialQuickSort(dat(:,d),indx, trunk%minn, trunk%maxx, medIndex-trunk%minn) !    trunk%d = d !    trunk%x = dat(indx(medIndex),d) !    ! Allocate the children nodes !    allocate(trunk%kiddos(2)) !    ! Initialize the children nodes !    call trunk%kiddos(1)%set(trunk%minn,medIndex) !    call trunk%kiddos(2)%set(medIndex+1,trunk%maxx) !    ! Grow the tree through the new branches !    call growTree(trunk%kiddos(1),dat,indx) !    call growTree(trunk%kiddos(2),dat,indx) !  end if !  end subroutine !  !====================================================================! !  !====================================================================! !  recursive function findNearestFast_nD(root, dat, indx, q, cn, cndiff) result(nrst) !  !====================================================================! !  class(node),intent(in) :: root !  real(r64),intent(in) :: dat(:,:) !  integer,intent(in) :: indx(:) !  real(r64),intent(in) :: q(:) !  integer :: cn !  real(r64) :: cndiff !  integer :: nrst ! !  real(r64) :: cnsqdiff ! !  ! If the node is not associated, we are at a leaf. !  ! Cycle through its buds !  if (.not. associated(trunk%kiddos)) then !    cn = findNearestSLOW(dat, indx, trunk%minn, trunk%maxx, q, cn) ! !    cnsqdiff=sum((q-dat(indx(cn),:))**2.d0) !    cndiff = dsqrt(cnsqdiff) !  else !    if (q(trunk%d)<=trunk%x) then !      cn = findNearestFAST(trunk%kiddos(1), dat, indx, q, cn, cndiff) !      if ((q(trunk%d)+cndiff)>=trunk%x) then !        cn = findNearestFAST(trunk%kiddos(2), dat, indx, q, cn, cndiff) !      end if !    else !      cn = findNearestFAST(trunk%kiddos(2), dat, indx, q, cn, cndiff) !      if ((q(trunk%d)-cndiff)<=trunk%x) then !        cn = findNearestFAST(trunk%kiddos(1), dat, indx, q, cn, cndiff) !      end if !    end if !  end if !  nrst = cn !  end function !  !====================================================================! !  !====================================================================! !  function findNearestSLOW_nD (dat, indx, minn, maxx, q, cn) result(nrst) !  !====================================================================! !  real(r64),intent(in) :: dat(:,:) !  integer,intent(in) :: indx(:) !  integer,intent(in) :: maxx,minn !  real(r64),intent(in) :: q(:) !  integer,intent(in) :: cn !  integer :: nrst ! !  integer :: i,nDims !  real(r64) ::  sqdiff,minsqdiff ! !  ! Get the number of dimensions in the KD tree !  nDims=size(dat,2) ! !  ! If cn is zero, we went straight to a leaf node !  if (cn==0) then !    i=minn !  else !    i=cn !  end if ! !  sqdiff=sum((q-dat(indx(i),:))**2.d0) ! !  minsqdiff = sqdiff !  nrst = i ! !  do i=minn, maxx !    sqdiff=sum((q-dat(indx(i),:))**2.d0) !    if (sqdiff<minsqdiff) then !      minsqdiff=sqdiff !      nrst=i !    end if !  end do !  end function !  !====================================================================! end module","loc":"sourcefile/m_kdtree.f90.html"},{"tags":"","title":"m_time.f90 – Fortran Program","text":"Modules m_time Source Code m_time.f90 Source Code module m_time !! Contains functions that handle time use variableKind implicit none contains !=====================================================================! function timeinseconds ( values ) result ( res ) !! Convert hours minutes seconds etc. to seconds !=====================================================================! integer ( i32 ) :: values ( 8 ) !! values containing amounts of days hours etc. real ( r64 ) :: res !! time in seconds res = dble (( 86400 * values ( 3 )) + ( 3600 * values ( 5 )) + ( 60 * values ( 6 )) + values ( 7 ))& + ( 0.001 d0 * dble ( values ( 8 ))) end function !=====================================================================! !=====================================================================! function daysinMonth ( month , year ) result ( days ) !! Get the number of days in a month. Accounts for leap years !=====================================================================! integer ( i32 ) :: month !! How many days in this month integer ( i32 ), optional :: year !! Check if a leap year? integer ( i32 ) :: days !! Number of days days = 0 select case ( month ) case ( 1 , 3 , 5 , 7 , 8 , 10 , 12 ) days = 31 case ( 2 ) days = 28 if ( present ( year )) then if ( isLeapYear ( year )) days = 29 endif case ( 4 , 6 , 9 , 11 ) days = 30 end select end function !=====================================================================! !=====================================================================! function daysinYear ( year ) result ( days ) !! Get the number of days in a year, accounts for leap years !=====================================================================! integer ( i32 ) :: year !! How many days in this year integer ( i32 ) :: days !! Number of days days = 365 if ( isLeapYear ( year )) days = 366 end function !=====================================================================! !=====================================================================! function isLeapYear ( year ) result ( yes ) !! Determine whether the year is a leap year !=====================================================================! integer ( i32 ) :: year !! Year to check logical :: yes !! is a leap year yes = . false . if ( iand ( year , 3 ) == 0 . and . ( mod ( year , 25 ) /= 0 . or . iand ( year , 15 ) == 0 )) yes = . true . end function !=====================================================================! !=====================================================================! function absTimetoHMS ( t ) result ( res ) !! Convert an absolute time to HH:MM:SS.MSEC !=====================================================================! real ( r64 ) :: t !! Time in seconds character ( len = 22 ) :: res !! Resulting string contains the time integer ( i32 ) :: days , hrs , min , sec , msec real ( r64 ) :: tmp days = floor ( t / 8640 0. d0 ); tmp = t - ( dble ( days * 86400 )) hrs = floor ( tmp / 360 0. d0 ); tmp = tmp - ( dble ( hrs * 3600 )) hrs = hrs + ( 24 * days ) min = floor ( tmp / 6 0. d0 ); tmp = tmp - ( dble ( min * 60 )) sec = floor ( tmp ); msec = int ( 1000 * ( tmp - ( dble ( sec )))) write ( res , 10 ) hrs , min , sec , msec 10 format ( i0 , ':' , i2 , ':' , i2 , '.' , i3 , ' (h:m:s)' ) end function !=====================================================================! end module","loc":"sourcefile/m_time.f90.html"},{"tags":"","title":"ProgressBar_Class.f90 – Fortran Program","text":"Modules ProgressBar_Class Source Code ProgressBar_Class.f90 Source Code module ProgressBar_Class !! An inline and updateable command prompt progress bar !! !! Example usage !!```fortran !!use variableKind !!use ProgressBar_Class !!type(ProgressBar) :: P !!integer(i32) :: i, N !!N = 100000 !!call P%set(N, time = .false.) !!call P%print(0) !!do i = 1, N !!  Compute some stuff !!  call P%print(i) !!enddo !!call P%set(N, time = .true.) !!call P%print(0) !!do i = 1, N !!  Compute some stuff !!  call P%print(i) !!enddo !!``` use iso_fortran_env , only : output_unit use variableKind , only : i32 , i64 , r32 , r64 use Stopwatch_Class use m_time , only : absTimetoHMS implicit none private type , public :: ProgressBar !! A progress bar that displays a moving counter with percentage and optional estimated time remaining private type ( Stopwatch ) :: clk !! Stopwatch to estimate time remaining character ( len = 14 ) :: title !! Give a title for the progress bar integer ( i64 ) :: N !! Total number of iterations integer ( i32 ) :: old1p !! 1% counter integer ( i32 ) :: old10p !! 10% counter integer ( i32 ) :: next1p !! 1% counter integer ( i32 ) :: next10p !! 10% counter logical :: time !! Provide an estimated time remaining? integer ( i32 ) :: iTime !! Counter to estimate time real ( r64 ) :: cumTime !! Cumulative time character ( len = 88 ) :: bar !! String to write the progress bar to output contains !generic, public :: set => set_i1_ProgressBar_,set_id1_ProgressBar_ !! Print the progress Bar !procedure, private :: set_i1_ProgressBar_ => set_i1_ProgressBar !procedure, private :: set_id1_ProgressBar_ => set_id1_ProgressBar !! Initialize the Progress Bar generic , public :: print => print_i1_ProgressBar_ , print_id1_ProgressBar_ !! Print the progress Bar procedure , private :: print_i1_ProgressBar_ => print_i1_ProgressBar procedure , private :: print_id1_ProgressBar_ => print_id1_ProgressBar end type interface ProgressBar module procedure ProgressBar_i1 !! Interfaced with class instantiation ProgressBar() module procedure ProgressBar_id1 !! Interfaced with class instantiation ProgressBar() end interface contains !====================================================================! function ProgressBar_i1 ( N , title , time ) result ( res ) !! Interfaced with class instantiation ProgressBar() !====================================================================! integer ( i32 ), intent ( in ) :: N !! Maximum expected number of iterations character ( len =* ), intent ( in ), optional :: title !! Title to give the progress bar logical , intent ( in ), optional :: time !! Show an estimated time to completion? type ( ProgressBar ) :: res res = ProgressBar_id1 ( int ( N , i64 ), title , time ) end function !====================================================================! !====================================================================! function ProgressBar_id1 ( N , title , time ) result ( res ) !! Interfaced with class instantiation ProgressBar() !====================================================================! integer ( i64 ), intent ( in ) :: N !! Maximum expected number of iterations character ( len =* ), intent ( in ), optional :: title !! Title to give the progress bar logical , intent ( in ), optional :: time !! Show an estimated time to completion? type ( ProgressBar ) :: res res % old1p = 0 res % old10p = 0 res % N = N write ( res % title , '(14x)' ) if ( present ( title )) res % title = title res % time = . false . if ( present ( time )) then res % time = time !    call res%clk%start() res % cumTime = 0. d0 res % iTime = 0 end if if ( res % time ) then res % bar = '     Completed:' // res % title // '-    % |          | Est. Remaining --:--:--.--- (h:m:s)' write ( output_unit , '(a1,a88)' , advance = 'no' ) char ( 13 ), res % bar else res % bar = '     Completed:' // res % title // '-    % |          |' write ( output_unit , '(a1,a48)' , advance = 'no' ) char ( 13 ), res % bar endif flush ( output_unit ) end function !====================================================================! !====================================================================! subroutine print_i1_ProgressBar ( this , i ) !! Interfaced with ProgressBar%print() !====================================================================! class ( ProgressBar ) :: this !! ProgressBar Class integer ( i32 ), intent ( in ) :: i !! Current iteration number call print_id1_ProgressBar ( this , int ( i , i64 )) end subroutine !====================================================================! !====================================================================! subroutine print_id1_ProgressBar ( this , i ) !! Interfaced with ProgressBar%print() !====================================================================! class ( ProgressBar ) :: this !! ProgressBar Class integer ( i64 ), intent ( in ) :: i !! Current iteration number integer ( i32 ) :: kk real ( r64 ) :: tmp real ( r64 ) :: avgTime integer ( i64 ) :: iTmp logical :: printMe ! If we are estimating the time left till completion printMe = . false . tmp = dble ( i ) / dble ( this % N ) ! Get the current 1% discretization this % next1p = int ( tmp * 10 0. d0 ) ! Current 1% ! Get the current 10% discretization this % next10p = int ( mod ( tmp * 1 0. d0 , 1 0. d0 )) ! Current 10% ! Check for 100% if ( this % next1p == 100 ) this % next10p = 10 ! Avoids write out error ! If the 10% level has changed, add a counter to the progress bar kk = 37 + this % next10p if ( this % next10p > this % old10p ) then this % bar ( kk : kk ) = '=' ! Write the bar this % old10p = this % next10p end if ! If the 1% has changed, update the bar and print if ( this % next1p > this % old1p ) then ! Write % to the bar write ( this % bar ( 32 : 34 ), '(i3)' ) this % next1p ! Update the output this % old1p = this % next1p printMe = . true . end if if ( this % time ) then this % iTime = this % iTime + 1 iTmp = this % N / 200 if ( this % iTime == iTmp ) then ! Get the time for this many iterations this % cumTime = this % cumTime + this % clk % lapInSeconds () ! Get the average time per iteration avgTime = this % cumTime / dble ( i ) ! Estimate time left my multiplying average time by iterations left. avgTime = avgTime * dble ( this % N - i ) if ( avgTime > 1. d - 7 ) write ( this % bar ( 65 : 88 ), '(a22)' ) absTimetoHMS ( avgTime ) printMe = . true . endif if ( this % iTime > iTmp ) this % iTime = 0 if ( this % next10p == 10 ) this % bar ( 50 : 88 ) = 'Finished in ' // this % clk % elapsed () end if if ( printMe ) then if ( this % time ) then write ( output_unit , '(a1,a88)' , advance = 'no' ) char ( 13 ), this % bar else write ( output_unit , '(a1,a48)' , advance = 'no' ) char ( 13 ), this % bar endif flush ( output_unit ) endif if ( this % next10p == 10 ) write ( output_unit , * ) end subroutine !====================================================================! end module","loc":"sourcefile/progressbar_class.f90.html"},{"tags":"","title":"Stopwatch_Class.f90 – Fortran Program","text":"Modules Stopwatch_Class Source Code Stopwatch_Class.f90 Source Code module Stopwatch_Class !! Contains code timing capabilities !! !! Example usage !!```fortran !!program stopwatch_test !!use variableKind, only: i32 !!use Stopwatch_Class, only: Stopwatch !!type(Stopwatch) :: clk !!integer(i32) :: i, N !!call clk%start('Some Title') !!N = 100000 !!do i = 1, N !!  Compute some stuff !!enddo !!call clk%stop() !!call clk%elapsed() !!write(*,'(a)') 'Finished on '//clk%datetime() !!end program !!``` use iso_fortran_env , only : output_unit use variableKind , only : i32 , r64 use m_strings , only : str use m_time , only : absTimetoHMS , timeinseconds implicit none private type , public :: Stopwatch !! Class for timing sections of code, See the Stopwatch_Class module documentation for usage. private logical :: running = . false . integer ( i32 ) :: LapTime_ ( 8 ) = 0 integer ( i32 ) :: startTime_ ( 8 ) = 0 integer ( i32 ) :: stopTime_ ( 8 ) = 0 contains procedure , public :: start => start_Stopwatch !! Start the Stopwatch procedure , public :: stop => stop_Stopwatch !! Stop the Stopwatch procedure , public :: reset => reset_Stopwatch !! Reset the Stopwatch procedure , public :: restart => restart_Stopwatch !! Restart the Stopwatch procedure , public :: time => time_Stopwatch !! Get the current or stopped time procedure , public :: lap => lap_Stopwatch !! Lap the Stopwatch procedure , public :: lapInSeconds => lapInSeconds_Stopwatch !! Get the lap time in seconds procedure , public :: elapsed => elapsed_Stopwatch !! Get the current elapsed time procedure , public :: elapsedInSeconds => elapsedInSeconds_Stopwatch !! Get the elapsed time in seconds procedure , public :: date => date_Stopwatch !! Print the date procedure , public :: dateAndTime => dateAndTime_Stopwatch !! Print the date and time end type contains !=====================================================================! subroutine start_Stopwatch ( this , title , iunit ) !! Start the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len =* ), optional :: title !! Name to label the start of the stopwatch integer ( i32 ), optional :: iunit !! File ID to write to if (. not . this % running ) then this % running = . true . call date_and_time ( values = this % StartTime_ ) this % LapTime_ = this % StartTime_ if ( present ( title )) then if ( present ( iunit )) then write ( iunit , '(a)' ) trim ( title ) // ' started on: ' // trim ( this % dateAndTime ()) write ( output_unit , '(a)' ) trim ( title ) // ' started on: ' // trim ( this % dateAndTime ()) else write ( output_unit , '(a)' ) trim ( title ) // ' started on: ' // trim ( this % dateAndTime ()) endif endif endif end subroutine !=====================================================================! !=====================================================================! subroutine stop_Stopwatch ( this , title , iunit ) !! Stop the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len =* ), optional :: title !! Name to label the stopped stopwatch integer ( i32 ), optional :: iunit !! File ID to write to if ( this % running ) then call date_and_time ( values = this % StopTime_ ) this % running = . false . if ( present ( title )) then if ( present ( iunit )) then write ( iunit , '(a)' ) trim ( title ) // ' finished on: ' // trim ( this % date ()) // ' in ' // str ( this % elapsedInSeconds ()) // '(s)' write ( output_unit , '(a)' ) trim ( title ) // ' finished on: ' // trim ( this % date ()) // ' in ' // str ( this % elapsedInSeconds ()) // '(s)' else write ( output_unit , '(a)' ) trim ( title ) // ' finished on: ' // trim ( this % date ()) // ' in ' // str ( this % elapsedInSeconds ()) // '(s)' endif endif endif end subroutine !=====================================================================! !=====================================================================! subroutine reset_Stopwatch ( this ) !! Reset the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class call this % stop () this % StartTime_ = 0 ; this % LapTime_ = 0 ; this % StopTime_ = 0 end subroutine !=====================================================================! subroutine restart_Stopwatch ( this ) !! Restart the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class call this % reset () call this % start () end subroutine !=====================================================================! !=====================================================================! function elapsed_Stopwatch ( this ) result ( res ) !! Get the elapsed time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Elapsed time in format HH:MM:SS.MSEC res = absTimetoHMS ( this % elapsedInSeconds ()) end function !=====================================================================! !=====================================================================! function lap_Stopwatch ( this ) result ( res ) !! Get the lap time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Lap time in format HH:MM:SS.MSEC res = absTimetoHMS ( this % lapInSeconds ()) end function !=====================================================================! !=====================================================================! function lapInSeconds_Stopwatch ( this ) result ( res ) !! Get the lap time in seconds !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class real ( r64 ) :: res !! Laptime in seconds integer ( i32 ) :: tmp ( 8 ) if ( this % running ) then call date_and_time ( values = tmp ) res = timeinseconds ( tmp ) - timeinseconds ( this % lapTime_ ) this % laptime_ = tmp else res = timeinseconds ( this % StopTime_ ) - timeinseconds ( this % lapTime_ ) endif end function !=====================================================================! !=====================================================================! function elapsedInSeconds_Stopwatch ( this ) result ( res ) !! Get the elapsed time in seconds !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class real ( r64 ) :: res !! Elapsed time in seconds integer ( i32 ) :: tmp ( 8 ) if ( this % running ) then call date_and_time ( values = tmp ) res = timeinseconds ( tmp ) - timeinseconds ( this % StartTime_ ) else res = timeinseconds ( this % StopTime_ ) - timeinseconds ( this % StartTime_ ) endif end function !=====================================================================! !=====================================================================! function dateAndTime_Stopwatch ( this ) result ( res ) !! Get the date and time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Date and time in format DD/MM/YYYY HH:MM:SS.MSEC res = trim ( this % date ()) // ' at ' // trim ( this % time ()) end function !=====================================================================! !=====================================================================! function date_Stopwatch ( this ) result ( res ) !! Get the date !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Date in format DD/MM/YYYY integer ( i32 ) :: tmp ( 8 ) res = '' if ( this % running ) then call date_and_time ( values = tmp ) res = trim ( str ( tmp ( 3 ))) // '/' // trim ( str ( tmp ( 2 ))) // '/' // trim ( str ( tmp ( 1 ))) else res = trim ( str ( this % StopTime_ ( 3 ))) // '/' // trim ( str ( this % StopTime_ ( 2 ))) // '/' // trim ( str ( this % StopTime_ ( 1 ))) endif end function !=====================================================================! !=====================================================================! function time_Stopwatch ( this ) result ( res ) !! Get the time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Time in format HH:MM:SS.MSEC integer :: tmp ( 8 ) res = '' if ( this % running ) then call date_and_time ( values = tmp ) res = trim ( str ( tmp ( 5 ))) // ':' // trim ( str ( tmp ( 6 ))) // ':' // trim ( str ( tmp ( 7 ))) // '.' // trim ( str ( tmp ( 8 ))) else res = trim ( str ( this % StopTime_ ( 5 ))) // ':' // trim ( str ( this % StopTime_ ( 6 ))) // ':' // trim ( str ( this % StopTime_ ( 7 ))) // '.' // trim ( str ( this % StopTime_ ( 8 ))) endif end function !=====================================================================! end module","loc":"sourcefile/stopwatch_class.f90.html"},{"tags":"","title":"c_printOptions – Fortran Program ","text":"type, public :: c_printOptions Print options similar to numpy's print_options Variables precision threshold edgeitems nanstr infstr Components Type Visibility Attributes Name Initial integer(kind=i32), public :: precision = 3 Force this precision on the written number integer(kind=i32), public :: threshold = 10 Omit the middle entries if the size is greater than threshold integer(kind=i32), public :: edgeitems = 3 Only write the first and last threshold elements from rows and/or columns character(len=32), public :: nanstr = 'nan' Print NAN as this character(len=32), public :: infstr = 'inf' Print infinity as this","loc":"type/c_printoptions.html"},{"tags":"","title":"KdTree – Fortran Program ","text":"type, public :: KdTree KdTree in 2, 3, or N dimensions.  See m_KdTree for more information on how to use this class. Type-Bound Procedures init deallocate Type-Bound Procedures generic, public :: init => ikdt2 KdTree%init() - Initialize the class private interface init2D_KdTree() Arguments None procedure, public :: deallocate => deallocate_KdTree kdTree%deallocate() - deallocate the recursive pointers private interface deallocate_KdTree() Arguments None","loc":"type/kdtree.html"},{"tags":"","title":"KdTreeSearch – Fortran Program ","text":"type, public :: KdTreeSearch Class to search a KdTree.  See m_KdTree for more information on how to use this class. Type-Bound Procedures init kNearest Type-Bound Procedures procedure, public :: init => init_KdTreeSearch Initialize the class private interface init_KdTreeSearch() Arguments None generic, public :: kNearest => kNearest2D Perform a k nearest neighbour search private interface kNearest_2D() Arguments None","loc":"type/kdtreesearch.html"},{"tags":"","title":"ProgressBar – Fortran Program ","text":"type, public :: ProgressBar A progress bar that displays a moving counter with percentage and optional estimated time remaining\n Print the progress Bar Initialize the Progress Bar Constructor ProgressBar Type-Bound Procedures print Constructor public interface ProgressBar private function ProgressBar_i1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) private function ProgressBar_id1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) Type-Bound Procedures generic, public :: print => print_i1_ProgressBar_, print_id1_ProgressBar_ Print the progress Bar private subroutine print_i1_ProgressBar(this, i) Interfaced with ProgressBar%print() Arguments Type Intent Optional Attributes Name class( ProgressBar ) :: this ProgressBar Class integer(kind=i32), intent(in) :: i Current iteration number private subroutine print_id1_ProgressBar(this, i) Interfaced with ProgressBar%print() Arguments Type Intent Optional Attributes Name class( ProgressBar ) :: this ProgressBar Class integer(kind=i64), intent(in) :: i Current iteration number","loc":"type/progressbar.html"},{"tags":"","title":"Stopwatch – Fortran Program ","text":"type, public :: Stopwatch Class for timing sections of code, See the Stopwatch_Class module documentation for usage. Type-Bound Procedures start stop reset restart time lap lapInSeconds elapsed elapsedInSeconds date dateAndTime Type-Bound Procedures procedure, public :: start => start_Stopwatch Start the Stopwatch private subroutine start_Stopwatch(this, title, iunit) Start the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class character(len=*), optional :: title Name to label the start of the stopwatch integer(kind=i32), optional :: iunit File ID to write to procedure, public :: stop => stop_Stopwatch Stop the Stopwatch private subroutine stop_Stopwatch(this, title, iunit) Stop the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class character(len=*), optional :: title Name to label the stopped stopwatch integer(kind=i32), optional :: iunit File ID to write to procedure, public :: reset => reset_Stopwatch Reset the Stopwatch private subroutine reset_Stopwatch(this) Reset the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class procedure, public :: restart => restart_Stopwatch Restart the Stopwatch private subroutine restart_Stopwatch(this) Restart the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class procedure, public :: time => time_Stopwatch Get the current or stopped time private function time_Stopwatch(this) result(res) Get the time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Time in format HH:MM:SS.MSEC procedure, public :: lap => lap_Stopwatch Lap the Stopwatch private function lap_Stopwatch(this) result(res) Get the lap time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Lap time in format HH:MM:SS.MSEC procedure, public :: lapInSeconds => lapInSeconds_Stopwatch Get the lap time in seconds private function lapInSeconds_Stopwatch(this) result(res) Get the lap time in seconds Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value real(kind=r64) Laptime in seconds procedure, public :: elapsed => elapsed_Stopwatch Get the current elapsed time private function elapsed_Stopwatch(this) result(res) Get the elapsed time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Elapsed time in format HH:MM:SS.MSEC procedure, public :: elapsedInSeconds => elapsedInSeconds_Stopwatch Get the elapsed time in seconds private function elapsedInSeconds_Stopwatch(this) result(res) Get the elapsed time in seconds Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value real(kind=r64) Elapsed time in seconds procedure, public :: date => date_Stopwatch Print the date private function date_Stopwatch(this) result(res) Get the date Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Date in format DD/MM/YYYY procedure, public :: dateAndTime => dateAndTime_Stopwatch Print the date and time private function dateAndTime_Stopwatch(this) result(res) Get the date and time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Date and time in format DD/MM/YYYY HH:MM:SS.MSEC","loc":"type/stopwatch.html"},{"tags":"","title":"arange – Fortran Program","text":"public interface arange Create a 1D array from start to stop in given increments of 1 or optionally step Example Usage program arangeTest use variableKind , only : i32 , i64 , r32 , r64 use m_allocatable , only : allocatable use m_array1D , only : arange real ( r32 ), allocatable :: a (:) integer ( i32 ), allocatable :: b (:) real ( r64 ), allocatable :: c (:) integer ( i64 ), allocatable :: d (:) integer :: N N = 10000 call allocate ( a , N ) call allocate ( b , N ) call allocate ( c , N ) call allocate ( d , N ) call arange ( a , 1 , N ) call arange ( b , 1 , N ) call arange ( c , 1 , N ) call arange ( d , 1 , N ) call deallocate ( a ) call deallocate ( b ) call deallocate ( c ) call deallocate ( d ) end program Subroutines arange_r1D arange_d1D arange_i1D arange_id1D Subroutines public subroutine arange_r1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: res (:) real(kind=r32), intent(in) :: start Start from here real(kind=r32), intent(in) :: stp Stop here real(kind=r32), intent(in), optional :: step Step size public subroutine arange_d1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: res (:) real(kind=r64), intent(in) :: start Start from here real(kind=r64), intent(in) :: stp Stop here real(kind=r64), intent(in), optional :: step Step size public subroutine arange_i1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: res (:) integer(kind=i32), intent(in) :: start Start from here integer(kind=i32), intent(in) :: stp Stop here integer(kind=i32), intent(in), optional :: step Step size public subroutine arange_id1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: res (:) integer(kind=i64), intent(in) :: start Start from here integer(kind=i64), intent(in) :: stp Stop here integer(kind=i64), intent(in), optional :: step Step size","loc":"interface/arange.html"},{"tags":"","title":"diff – Fortran Program","text":"public interface diff Compute the difference along an array Example Usage program arangeTest use variableKind , only : i32 , i64 , r32 , r64 use m_allocatable , only : allocatable use m_array1D , only : arange , diff real ( r32 ), allocatable :: a (:) integer ( i32 ), allocatable :: b (:) real ( r64 ), allocatable :: c (:) integer ( i64 ), allocatable :: d (:) integer :: N N = 10000 call allocate ( a , N ) call allocate ( b , N ) call allocate ( c , N ) call allocate ( d , N ) call arange ( a , 1 , N ) call arange ( b , 1 , N ) call arange ( c , 1 , N ) call arange ( d , 1 , N ) call diff ( a , 1 , N ) call diff ( b , 1 , N ) call diff ( c , 1 , N ) call diff ( d , 1 , N ) call deallocate ( a ) call deallocate ( b ) call deallocate ( c ) call deallocate ( d ) end program Subroutines diff_r1D diff_d1D diff_i1D diff_id1D Subroutines public subroutine diff_r1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32) :: res (:) Difference along array public subroutine diff_d1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64) :: res (:) Difference along array public subroutine diff_i1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32) :: res (:) Difference along array public subroutine diff_id1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i64) :: res (:) Difference along array","loc":"interface/diff.html"},{"tags":"","title":"isSorted – Fortran Program","text":"public interface isSorted Check that a 1D array is sorted Example Usage program arangeTest use variableKind , only : i32 , i64 , r32 , r64 use m_allocatable , only : allocatable use m_array1D , only : arange , isSorted real ( r32 ), allocatable :: a (:) integer ( i32 ), allocatable :: b (:) real ( r64 ), allocatable :: c (:) integer ( i64 ), allocatable :: d (:) integer :: N N = 10000 call allocate ( a , N ) call allocate ( b , N ) call allocate ( c , N ) call allocate ( d , N ) call arange ( a , 1 , N ) call arange ( b , 1 , N ) call arange ( c , 1 , N ) call arange ( d , 1 , N ) call diff ( a , 1 , N ) call diff ( b , 1 , N ) call diff ( c , 1 , N ) call diff ( d , 1 , N ) call deallocate ( a ) call deallocate ( b ) call deallocate ( c ) call deallocate ( d ) end program Functions isSorted_r1D isSorted_d1D isSorted_i1D isSorted_id1D Functions public function isSorted_r1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_d1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_i1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_id1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value logical isSorted","loc":"interface/issorted.html"},{"tags":"","title":"repeat – Fortran Program","text":"public interface repeat Repeat each element nRepeat times Subroutines repeat_r1D repeat_d1D repeat_i1D repeat_id1D Subroutines public subroutine repeat_r1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r32), allocatable :: res (:) public subroutine repeat_d1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r64), allocatable :: res (:) public subroutine repeat_i1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i32), allocatable :: res (:) public subroutine repeat_id1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i64), allocatable :: res (:)","loc":"interface/repeat.html"},{"tags":"","title":"allocate – Fortran Program","text":"public interface allocate Allocate an allocatable array. If the array is already allocated, memory is reallocated to the given size, unless no size change will occur.\n The allocated memory is NOT initialized to any value, so be sure to do so afterwards if you call allocate. Does not overload the intrinsic allocate function. This way, calling allocate makes the user aware that checks are being made, and memory will be re-allocated. Checks for an error during allocation, and will stop the code if there is one. Example usage use variableKind use m_allocate , only : allocate real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) call allocate ( a1D , 20 ) call allocate ( a2D , [ 20 , 20 ]) call allocate ( a3D , [ 20 , 20 , 20 ]) write ( * , '(a)' ) 'Shape of a3D is [20,20,20]? ' // all ( shape ( a3D ) == [ 20 , 20 , 20 ]) Subroutines allocate_r1D allocate_r2D allocate_r3D allocate_d1D allocate_d2D allocate_d3D allocate_i1D allocate_i2D allocate_i3D allocate_id1D allocate_id2D allocate_id3D allocate_c1D allocate_c2D allocate_c3D allocate_z1D allocate_z2D allocate_z3D allocate_l1D allocate_l2D allocate_l3D Subroutines public subroutine allocate_r1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_r2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_r3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_d1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_d2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_d3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_i1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_i2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_i3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_id1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_id2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_id3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_c1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_c2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_c3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_z1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_z2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_z3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_l1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_l2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_l3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size","loc":"interface/allocate.html"},{"tags":"","title":"compare_d1 – Fortran Program","text":"public function compare_d1(this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32)","loc":"proc/compare_d1.html"},{"tags":"","title":"compare – Fortran Program","text":"public interface compare Module Procedures compare_d1 Module Procedures public function compare_d1 (this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32)","loc":"interface/compare.html"},{"tags":"","title":"copy – Fortran Program","text":"public interface copy Copies an array to new memory (no pointers), The output array size will be changed to match the copy. Example usage use variableKind , only : r64 use m_allocate , only : allocate use m_copy , only : copy real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) real ( r64 ), allocatable :: b1D (:), b2D (:,:), b3D (:,:,:) call allocate ( a1D , 20 ) call allocate ( a2D , [ 20 , 20 ]) call allocate ( a3D , [ 20 , 20 , 20 ]) a1D = 1. d0 a2D = 2. d0 a3D = 3. d0 call copy ( a1D , b1D ) call copy ( a2D , b2D ) call copy ( a3D , b3D ) write ( * , '(a)' ) 'a1D equals b1D: ' // str ( all ( a1D == b1D )) write ( * , '(a)' ) 'a2D equals b2D: ' // str ( all ( a2D == b2D )) write ( * , '(a)' ) 'a3D equals b3D: ' // str ( all ( a3D == b3D )) call deallocate ( a1D ) call deallocate ( a2D ) call deallocate ( a3D ) call deallocate ( b1D ) call deallocate ( b2D ) call deallocate ( b3D ) Subroutines copy_r1D copy_r2D copy_r3D copy_d1D copy_d2D copy_d3D copy_i1D copy_i2D copy_i3D copy_id1D copy_id2D copy_id3D copy_c1D copy_c2D copy_c3D copy_z1D copy_z2D copy_z3D copy_l1D copy_l2D copy_l3D Subroutines public subroutine copy_r1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_r2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_r3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_d1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_d2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_d3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_i1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_i2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_i3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_id1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_id2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_id3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_c1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_c2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_c3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_z1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_z2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_z3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_l1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:) Copy this array logical, intent(inout), allocatable :: that (:) Copy of this public subroutine copy_l2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:) Copy this array logical, intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_l3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:,:) Copy this array logical, intent(inout), allocatable :: that (:,:,:) Copy of this","loc":"interface/copy.html"},{"tags":"","title":"deallocate – Fortran Program","text":"public interface deallocate Deallocate an allocatable array. Contains fundamental routines to deallocate allocatable arrays of different types and shapes.\n Does not overload the intrinsic deallocate function. This way, calling deallocate makes the user aware that checks are being made and errors are handled with a message. Checks for an error during allocation, and will stop the code if there is one. Example usage use variableKind use m_allocate , only : allocate use m_deallocate , only : deallocate ! Could be other intrinsic types too, integer(i32), complex(r32), etc. real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) call allocate ( a1D , 20 ) call allocate ( a2D , [ 20 , 20 ]) call allocate ( a3D , [ 20 , 20 , 20 ]) write ( * , '(a)' ) 'Shape of a3D is [20,20,20]? ' // all ( shape ( a3D ) == [ 20 , 20 , 20 ]) call deallocate ( a1D ) call deallocate ( a2D ) call deallocate ( a3D ) Subroutines deallocate_r1D deallocate_r2D deallocate_r3D deallocate_d1D deallocate_d2D deallocate_d3D deallocate_i1D deallocate_i2D deallocate_i3D deallocate_id1D deallocate_id2D deallocate_id3D deallocate_c1D deallocate_c2D deallocate_c3D deallocate_z1D deallocate_z2D deallocate_z3D deallocate_l1D deallocate_l2D deallocate_l3D Subroutines public subroutine deallocate_r1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_r2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_r3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_d1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_d2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_d3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_i1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_i2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_i3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_id1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_id2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_id3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_c1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_c2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_c3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_z1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_z2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_z3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_l1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_l2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_l3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array","loc":"interface/deallocate.html"},{"tags":"","title":"debug_s – Fortran Program","text":"public subroutine debug_s(name) Arguments Type Intent Optional Attributes Name character(len=*) :: name","loc":"proc/debug_s.html"},{"tags":"","title":"debug – Fortran Program","text":"public interface debug Interface for printing primitives with a name for debug purposes\n All may be called using 'call debug(args)' Module Procedures debug_d debug_d1D debug_i debug_i1D Module Procedures private subroutine debug_D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var private subroutine debug_D1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var (:) private subroutine debug_I(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var private subroutine debug_I1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var (:)","loc":"interface/debug.html"},{"tags":"","title":"mErr – Fortran Program","text":"public subroutine mErr(istat, aMsg, alloc, iunit) Checks for successful (de)allocation.  Stops the code. Use this after an allocate/deallocate statement\n allocate(x(nz,ny,nx), stat=istat); call mErr(istat,'x',1)\n deallocate(x, stat=istat); call mErr(istat,'x',2) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat results of stat=istat in (de)allocate character(len=*), intent(in) :: aMsg Message associated with the (de)allocate integer(kind=i32), intent(in) :: alloc 1 = allocate, 2 = deallocate integer(kind=i32), intent(in), optional :: iunit Optional file id to write the message to","loc":"proc/merr.html"},{"tags":"","title":"msg – Fortran Program","text":"public subroutine msg(aMsg, iunit) Write a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to","loc":"proc/msg.html"},{"tags":"","title":"wMsg – Fortran Program","text":"public subroutine wMsg(aMsg, iunit) Write a Warning message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to","loc":"proc/wmsg.html"},{"tags":"","title":"eMsg – Fortran Program","text":"public subroutine eMsg(aMsg, iunit) Write an Error message. Stops the code Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to","loc":"proc/emsg.html"},{"tags":"","title":"fErr – Fortran Program","text":"public subroutine fErr(istat, fname, flg, iunit) Checks for a file error Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat Result of iostat=istat for open,read,write,close character(len=*), intent(in) :: fname Name of the file integer(kind=i32), intent(in) :: flg 1=Open, 2=Read, 3=Write, 4=Close integer(kind=i32), intent(in), optional :: iunit file id to write the error to","loc":"proc/ferr.html"},{"tags":"","title":"fileExists – Fortran Program","text":"public function fileExists(fName) result(yes) Checks whether the file with name fName exists on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name to check Return Value logical Exists?","loc":"proc/fileexists.html"},{"tags":"","title":"hasExtension – Fortran Program","text":"public function hasExtension(fName, extension) result(yes) Checks if a file 'fname' is of type 'extension' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name character(len=3), intent(in) :: extension Extension to find Return Value logical Has this extension?","loc":"proc/hasextension.html"},{"tags":"","title":"isOpen – Fortran Program","text":"public function isOpen(fname) result(yes) Is the file open or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name Return Value logical Is the file open?","loc":"proc/isopen.html"},{"tags":"","title":"getFileSize – Fortran Program","text":"public function getFileSize(fName) result(that) Get the file size in Bytes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value integer(kind=i32) Size of the file","loc":"proc/getfilesize.html"},{"tags":"","title":"getNFileLines – Fortran Program","text":"public function getNFileLines(fName, nHeader) result(N) Counts the number of lines in a file after the number of specified header lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name integer(kind=i32), intent(in), optional :: nHeader Skip this number of lines at the top of the file Return Value integer(kind=i32) Number of lines in the file","loc":"proc/getnfilelines.html"},{"tags":"","title":"getExtension – Fortran Program","text":"public function getExtension(fName) result(that) Get the extension of a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File extension","loc":"proc/getextension.html"},{"tags":"","title":"trimExtension – Fortran Program","text":"public function trimExtension(fName) result(that) Trims the extension of a filename Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File name without the extension","loc":"proc/trimextension.html"},{"tags":"","title":"checkIsOpen – Fortran Program","text":"public subroutine checkIsOpen(fName) Checks whether a file is open with an error message if not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name","loc":"proc/checkisopen.html"},{"tags":"","title":"openFile – Fortran Program","text":"public subroutine openFile(fname, iunit, stat, istat) Open a file and perform necessary checks for failure\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error flag","loc":"proc/openfile.html"},{"tags":"","title":"openBinaryFile – Fortran Program","text":"public subroutine openBinaryFile(fname, iunit, stat, istat) Open an unformatted binary file\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File Name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error Flag","loc":"proc/openbinaryfile.html"},{"tags":"","title":"closeFile – Fortran Program","text":"public subroutine closeFile(fname, iunit, stat, istat) Close a file and perform any necessary checks Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are closing integer(kind=i32), intent(out) :: istat Error Flag","loc":"proc/closefile.html"},{"tags":"","title":"deleteFile – Fortran Program","text":"public subroutine deleteFile(fname) Deletes a file on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name to delete","loc":"proc/deletefile.html"},{"tags":"","title":"skipFileLines – Fortran Program","text":"public subroutine skipFileLines(iunit, N) Skip N lines in a file Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit Unit number to skip integer(kind=i32), intent(in) :: N Number of lines to skip","loc":"proc/skipfilelines.html"},{"tags":"","title":"ind2sub – Fortran Program","text":"public function ind2sub(iG, nSub) result(iSub) Compute the indices in each dimension from the global index Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iG Index into a global vector integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32)\n  (size(nSub)) Indices in each dimension to return","loc":"proc/ind2sub.html"},{"tags":"","title":"sub2ind – Fortran Program","text":"public function sub2ind(iSub, nSub) result(iG) Given component indices, get the global vector location. Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iSub (:) Indices in each dimension. The first entry in iL is the left most index integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32) Index in the global vector","loc":"proc/sub2ind.html"},{"tags":"","title":"integerBin – Fortran Program","text":"public function integerBin(this, n, bound) result(i) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer(kind=i32) :: n logical :: bound Return Value integer(kind=i32)","loc":"proc/integerbin.html"},{"tags":"","title":"partition – Fortran Program","text":"public interface partition Partitioning used for quickSort and quickSelect routines Subroutines partition_r1D partition_d1D partition_i1D partition_id1D Subroutines public subroutine partition_r1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_d1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_i1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot public subroutine partition_id1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot","loc":"interface/partition.html"},{"tags":"","title":"argPartition – Fortran Program","text":"public interface argPartition Partitioning used for argQuicksort routines Subroutines argPartition_r1D argPartition_d1D argPartition_i1D argPartition_id1D Subroutines public subroutine argPartition_r1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_d1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_i1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_id1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i","loc":"interface/argpartition.html"},{"tags":"","title":"partition3way_d1D – Fortran Program","text":"public subroutine partition3way_d1D(this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index","loc":"proc/partition3way_d1d.html"},{"tags":"","title":"partition3way – Fortran Program","text":"public interface partition3way Partitioning used for quicksort routines Module Procedures partition3way_d1D Module Procedures public subroutine partition3way_d1D (this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index","loc":"interface/partition3way.html"},{"tags":"","title":"readline – Fortran Program","text":"public interface readline Read in multiple items from a line Example usage use variableKind use m_readline character ( len = :), allocatable :: s real ( r64 ) :: a , b , c real ( r64 ) :: a1D ( 3 ) s = '1.0 2.0 3.0' call readline ( a , b , c , 'No File Name' , 0 , s ) ! Read 3 scalars from a string write ( * , * ) 'a should equal 1.0 ' , a == 1. d0 write ( * , * ) 'b should equal 2.0 ' , b == 2. d0 write ( * , * ) 'c should equal 3.0 ' , c == 3. d0 call readline ( a1D , 'No File Name' , 0 , s ) ! Read a length 3 1D array from a string write ( * , * ) 'a1D should equal [1.0,2.0,3.0] ' , all ( a == [ 1. d0 , 2. d0 , 3. d0 ]) Module Procedures readLine_a readLine_ab readLine_abc readLine_abcd readLine_abcde readLine_av readLine_avbv readLine_avbvcv readLine_abv readLine_abvcv readLine_abcdev readLine_abcdv readLine_abcdvev readLine_abcv readLine_abcvdv readLine_abcdefv readLine_abcdefvgv Module Procedures private subroutine readLine_a(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_ab(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abc(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcd(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcde(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_av(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdvev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcvdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefv(a, b, c, d, e, f, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector real(kind=r64), intent(out) :: g (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file","loc":"interface/readline.html"},{"tags":"","title":"reallocate – Fortran Program","text":"public interface reallocate Reallocate an allocatable array Example usage use variableKind use m_reallocate real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) allocate ( a1D ( 5 )) allocate ( a2D ( 5 , 5 )) allocate ( a3D ( 5 , 5 , 5 )) write ( * , '(a)' ) 'Shape of a3D is [5,5,5]? ' // all ( shape ( a3D ) == [ 5 , 5 , 5 ]) call reallocate ( a1D , 20 ) call reallocate ( a2D , [ 20 , 20 ]) call reallocate ( a3D , [ 20 , 20 , 20 ]) write ( * , '(a)' ) 'Shape of a3D is [20,20,20]? ' // all ( shape ( a3D ) == [ 20 , 20 , 20 ]) Module Procedures reallocate_r1D reallocate_r2D reallocate_r3D reallocate_d1D reallocate_d2D reallocate_d3D reallocate_i1D reallocate_i2D reallocate_i3D reallocate_id1D reallocate_id2D reallocate_id3D reallocate_c1D reallocate_c2D reallocate_c3D reallocate_z1D reallocate_z2D reallocate_z3D reallocate_l1D reallocate_l2D reallocate_l3D Module Procedures private subroutine reallocate_r1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_r2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_r3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_d1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_d2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_d3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_i1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_i2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_i3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_id1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_id2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_id3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_c1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_c2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_c3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_z1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_z2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_z3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_l1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_l2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_l3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape","loc":"interface/reallocate.html"},{"tags":"","title":"hasNentries – Fortran Program","text":"public function hasNentries(this, N) result(yes) Check that a string has N entries Arguments Type Intent Optional Attributes Name character(len=*) :: this integer(kind=i32) :: N Return Value logical","loc":"proc/hasnentries.html"},{"tags":"","title":"countEntries – Fortran Program","text":"public function countEntries(this) result(N) Count the number of entries in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Return Value integer(kind=i32)","loc":"proc/countentries.html"},{"tags":"","title":"lowerCase – Fortran Program","text":"public function lowerCase(str) result(res) Convert a string to lowercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str))","loc":"proc/lowercase.html"},{"tags":"","title":"upperCase – Fortran Program","text":"public function upperCase(str) result(res) Convert a string to uppercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str))","loc":"proc/uppercase.html"},{"tags":"","title":"isString – Fortran Program","text":"public function isString(tmp1, tmp2, exact_) result(yes) Match two string together Arguments Type Intent Optional Attributes Name character(len=*) :: tmp1 Compare this string character(len=*) :: tmp2 Compare this string logical, optional :: exact_ Optional logical, if true, the strings are not converted to lowercase before comparison Return Value logical","loc":"proc/isstring.html"},{"tags":"","title":"appendString – Fortran Program","text":"public function appendString(this, that, delim) result(res) Append a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to append to character(len=*) :: that String to append character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Appended String","loc":"proc/appendstring.html"},{"tags":"","title":"prependString – Fortran Program","text":"public function prependString(this, that, delim) result(res) Prepend a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to prepend to character(len=*) :: that String to prepend character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Prepended String","loc":"proc/prependstring.html"},{"tags":"","title":"iachar1D – Fortran Program","text":"public function iachar1D(this) result(res) Use iachar on a full string Cannot overload to intrinsic iachar because of ambiguity Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this Return Value integer(kind=i32),\n  allocatable,(:)","loc":"proc/iachar1d.html"},{"tags":"","title":"read1Integer – Fortran Program","text":"public subroutine read1Integer(buf, N, istat) Get a single integer from a line, returns an error code if there is more than one entry Arguments Type Intent Optional Attributes Name character(len=*) :: buf String integer(kind=i32) :: N Single integer integer(kind=i32) :: istat istat > 0 if more than one entry is found","loc":"proc/read1integer.html"},{"tags":"","title":"read1Dble – Fortran Program","text":"public subroutine read1Dble(iunit, this, fname, vName, istat) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit real(kind=r64) :: this character(len=*) :: fname character(len=*) :: vName integer(kind=i32) :: istat","loc":"proc/read1dble.html"},{"tags":"","title":"compact – Fortran Program","text":"public subroutine compact(this) Replace tabs and spaces with a single space\n str must be a variable and not an explicit 'string'. Otherwise adjustl will fail. Arguments Type Intent Optional Attributes Name character(len=*) :: this","loc":"proc/compact.html"},{"tags":"","title":"removeComments – Fortran Program","text":"public elemental subroutine removeComments(this) Removes the text after the ! mark in a string Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: this","loc":"proc/removecomments.html"},{"tags":"","title":"replacedelim – Fortran Program","text":"public subroutine replacedelim(this, dlim, dlimr) Replace a single character length delimiter in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Replace delimiter in this character(len=*) :: dlim Find this delimiter character(len=*) :: dlimr Replace with this delimiter","loc":"proc/replacedelim.html"},{"tags":"","title":"str – Fortran Program","text":"public interface str Interface to print a string representation of a number\n The output format options can be set using the printOptions class Example usage use variableKind use m_strings real ( r64 ) :: arr ( 20 ) integer ( i32 ) :: i integer ( i32 ) :: j ( 5 ) arr = [( dble ( i ), i = 1 , 20 )] i = 12 j = [ 0 , 1 , 2 , 3 , 4 ] write ( * , '(a)' ) str ( i ) // str ( j ) write ( * , '(a)' ) str ( j ) // str ( arr ) write ( * , '(a)' ) str ( arr ) printOptions % threshold = 0 write ( * , '(a)' ) str ( arr ) Module Procedures str_r1 str_r1D str_d1 str_d1D str_d2D str_i1 str_i1D str_id1 str_id1D str_s1 str_s1D str_1L Module Procedures private function str_r1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_r1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d2D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:,:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_1L(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name logical, intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable","loc":"interface/str.html"},{"tags":"","title":"swap – Fortran Program","text":"public interface swap Swap the values of two variables Example usage use variableKind use m_strings , only : str use m_swap , only : swap real ( r64 ) :: a , b a = 1 0. d0 b = 10 0. d0 call swap ( a , b ) write ( * , '(a)' ) 'Values were swapped? ' // str ( a == 10 0. d0 . and . b == 1 0. d0 ) Module Procedures swap_i1 swap_id1 swap_r1 swap_d1 swap_c1 swap_z1 swap_l1 Module Procedures private subroutine swap_i1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this integer(kind=i32), intent(inout) :: that private subroutine swap_id1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this integer(kind=i64), intent(inout) :: that private subroutine swap_r1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this real(kind=r32), intent(inout) :: that private subroutine swap_d1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(inout) :: that private subroutine swap_c1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r32) :: this complex(kind=r32) :: that private subroutine swap_z1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r64) :: this complex(kind=r64) :: that private subroutine swap_l1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name logical :: this logical :: that","loc":"interface/swap.html"},{"tags":"","title":"writeline – Fortran Program","text":"public interface writeline Write multiple items to a line Example usage use variableKind use m_writeline use m_fileIO , only : openFile , closeFile character ( len = :), allocatable :: fName real ( r64 ) :: a , b , c real ( r64 ) :: a1D ( 3 ) integer ( i32 ) :: iunit , istat a = 1. d0 b = 2. d0 c = 3. d0 a1D = [ 1. d0 , 2. d0 , 3. d0 ] fName = 'writeline.txt' call openFile ( fName , iunit , 'unknown' , istat ) call writeline ( a , b , c , fName , iunit ) call writeline ( a1D , fName , iunit ) call closeFile ( fName , iunit , '' , istat ) Module Procedures writeLine_a writeLine_ab writeLine_abc writeLine_abcd writeLine_abcde writeLine_av writeLine_avbv writeLine_avbvcv writeLine_abv writeLine_abvcv writeLine_abcdev writeLine_abcdevfv writeLine_abcdv writeLine_abcdvev writeLine_abcv writeLine_abcvdv writeLine_abcdefv writeLine_abcdefvgv Module Procedures private subroutine writeLine_a(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_ab(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abc(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcd(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcde(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_av(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdevfv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdvev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcvdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) real(kind=r64) :: g (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit","loc":"interface/writeline.html"},{"tags":"","title":"crossproduct – Fortran Program","text":"public interface crossproduct Compute the cross product between two arrays of length 2 or 3 Functions crossproduct_r1D crossproduct_d1D Functions public function crossproduct_r1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (3) 1D Array real(kind=r32), intent(in) :: b (3) 1D Array Return Value real(kind=r32)\n  (3) cross product public function crossproduct_d1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (3) 1D Array real(kind=r64), intent(in) :: b (3) 1D Array Return Value real(kind=r64)\n  (3) cross product","loc":"interface/crossproduct.html"},{"tags":"","title":"cumprod – Fortran Program","text":"public interface cumprod Compute the variance of an array Functions cumprod_r1D cumprod_d1D cumprod_i1D cumprod_id1D Functions public function cumprod_r1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative product public function cumprod_d1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative product public function cumprod_i1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative product public function cumprod_id1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative product","loc":"interface/cumprod.html"},{"tags":"","title":"cumsum – Fortran Program","text":"public interface cumsum Compute the variance of an array Functions cumsum_r1D cumsum_d1D cumsum_i1D cumsum_id1D Functions public function cumsum_r1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative sum public function cumsum_d1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative sum public function cumsum_i1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative sum public function cumsum_id1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative sum","loc":"interface/cumsum.html"},{"tags":"","title":"fastTwoDiff – Fortran Program","text":"public interface fastTwoDiff Compute the difference two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoDiff routine Functions fastTwoDiff_r fastTwoDiff_d Functions public function fastTwoDiff_r(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoDiff_d(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error","loc":"interface/fasttwodiff.html"},{"tags":"","title":"fastTwoSum – Fortran Program","text":"public interface fastTwoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoSum routine Functions fastTwoSum_r fastTwoSum_d Functions public function fastTwoSum_r(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoSum_d(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error","loc":"interface/fasttwosum.html"},{"tags":"","title":"geometricMean – Fortran Program","text":"public interface geometricMean Compute the geometric mean of a vector Functions geometricMean_r1D geometricMean_d1D geometricMean_i1D geometricMean_id1D Functions public function geometricMean_r1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_d1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_i1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_id1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) Return Value real(kind=r64)","loc":"interface/geometricmean.html"},{"tags":"","title":"mean – Fortran Program","text":"public interface mean Compute the mean Functions mean_r1D mean_d1D mean_i1D mean_id1D Functions public function mean_r1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_d1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_i1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_id1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean","loc":"interface/mean.html"},{"tags":"","title":"median – Fortran Program","text":"public interface median Compute the median of a set of numbers Functions median_r1D median_d1D median_i1D median_id1D Functions public function median_r1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) median public function median_d1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_i1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_id1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median","loc":"interface/median.html"},{"tags":"","title":"norm1 – Fortran Program","text":"public interface norm1 Compute the L1 norm of a set of numbers Functions norm1_r1D norm1_d1D norm1_i1D norm1_id1D Functions public function norm1_r1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) L1 norm public function norm1_d1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_i1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_id1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm","loc":"interface/norm1.html"},{"tags":"","title":"normI – Fortran Program","text":"public interface normI Compute the Linfinity norm of a set of numbers Functions normI_r1D normI_d1D normI_i1D normI_id1D Functions public function normI_r1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) Linfinity norm public function normI_d1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) Linfinity norm public function normI_i1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32) Linfinity norm public function normI_id1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64) Linfinity norm","loc":"interface/normi.html"},{"tags":"","title":"project – Fortran Program","text":"public interface project Project a vector a onto vector b Functions project_r1D project_d1D Functions public function project_r1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (:) 1D array real(kind=r32), intent(in) :: b (size(a)) 1D array Return Value real(kind=r32)\n  (size(a)) 1D array public function project_d1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (:) 1D array real(kind=r64), intent(in) :: b (size(a)) 1D array Return Value real(kind=r64)\n  (size(a)) 1D array","loc":"interface/project.html"},{"tags":"","title":"trimmedmean – Fortran Program","text":"public interface trimmedmean Compute the Trimmed mean of an array,  alpha is a percent value to trim from either end Functions trimmedmean_r1D trimmedmean_d1D trimmedmean_i1D trimmedmean_id1D Functions public function trimmedmean_r1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_d1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_i1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_id1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean","loc":"interface/trimmedmean.html"},{"tags":"","title":"twoDiff – Fortran Program","text":"public interface twoDiff Compute the difference between two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoDiff Functions twoDiff_r twoDiff_d Functions public function twoDiff_r(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function twoDiff_d(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error","loc":"interface/twodiff.html"},{"tags":"","title":"twoSum – Fortran Program","text":"public interface twoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoSum Functions twoSum_r twoSum_d Functions public function twoSum_r(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number in sum real(kind=r32), intent(in) :: b Second number in sum Return Value real(kind=r32)\n  (2) The sum and its error public function twoSum_d(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number in sum real(kind=r64), intent(in) :: b Second number in sum Return Value real(kind=r64)\n  (2) The sum and its error","loc":"interface/twosum.html"},{"tags":"","title":"std – Fortran Program","text":"public interface std Compute the standard deviation of an array Functions std_r1D std_d1D std_i1D std_id1D Functions public function std_r1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_d1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_i1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_id1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation","loc":"interface/std.html"},{"tags":"","title":"variance – Fortran Program","text":"public interface variance Compute the variance of an array Functions variance_r1D variance_d1D variance_i1D variance_id1D Functions public function variance_r1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_d1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_i1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_id1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance","loc":"interface/variance.html"},{"tags":"","title":"setRNG – Fortran Program","text":"public interface setRNG Sets the random number with or without a seed Module Procedures setRNG_Wseed setRNG_WOseed Module Procedures private subroutine setRNG_Wseed(seed) Interfaced to setRNG()\n Sets the seed of the random number generator with a specified seed Arguments Type Intent Optional Attributes Name integer :: seed (:) private subroutine setRNG_WOseed(display) Interfaced to setRNG()\n 'Randomly' sets the seed of the random number generator Arguments Type Intent Optional Attributes Name logical :: display","loc":"interface/setrng.html"},{"tags":"","title":"shuffle – Fortran Program","text":"public interface shuffle Perform Knuth shuffling on an array Subroutines shuffle_r1D shuffle_d1D shuffle_i1D shuffle_id1D Subroutines public subroutine shuffle_r1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array public subroutine shuffle_d1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array public subroutine shuffle_i1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array public subroutine shuffle_id1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array","loc":"interface/shuffle.html"},{"tags":"","title":"rngInteger – Fortran Program","text":"public interface rngInteger Module Procedures rngInteger_i1 rngInteger_i1D Module Procedures private subroutine rngInteger_i1(this, imin, imax) Generate a random integer from imin to imax Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this integer(kind=i32) :: imin integer(kind=i32) :: imax private subroutine rngInteger_i1D(this, imin) Generate size(this) random integers starting from imin Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: imin","loc":"interface/rnginteger.html"},{"tags":"","title":"rngWeibull – Fortran Program","text":"public interface rngWeibull Module Procedures rngWeibull_d1 rngWeibull_d1D Module Procedures private subroutine rngWeibull_d1(this, den) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64), intent(in) :: den private subroutine rngWeibull_d1D(this, den) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), intent(in) :: den","loc":"interface/rngweibull.html"},{"tags":"","title":"rngExponential – Fortran Program","text":"public interface rngExponential Module Procedures rngExponential_d1 rngExponential_d1D Module Procedures private subroutine rngExponential_d1(this) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this private subroutine rngExponential_d1D(this) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:)","loc":"interface/rngexponential.html"},{"tags":"","title":"rngChisq – Fortran Program","text":"public interface rngChisq Module Procedures rngChisq_d1 rngChisq_d1D Module Procedures private subroutine rngChisq_d1(this, ndf, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer, intent(in) :: ndf logical, intent(in) :: first private subroutine rngChisq_d1D(this, ndf, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer, intent(in) :: ndf logical, intent(in) :: first","loc":"interface/rngchisq.html"},{"tags":"","title":"rngGamma – Fortran Program","text":"public interface rngGamma Module Procedures rngGamma_d1 rngGamma_d1D Module Procedures private subroutine rngGamma_d1(this, s, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64), intent(in) :: s logical, intent(in) :: first private subroutine rngGamma_d1D(this, s, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), intent(in) :: s logical, intent(in) :: first","loc":"interface/rnggamma.html"},{"tags":"","title":"rngNormal – Fortran Program","text":"public interface rngNormal Module Procedures rngNormal_d1 rngNormal_d1D rngNormal_d2D rngNormal_d3D Module Procedures private subroutine rngNormal_d1(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std private subroutine rngNormal_d1D(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), optional :: mean real(kind=r64), optional :: std private subroutine rngNormal_d2D(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:,:) real(kind=r64), optional :: mean real(kind=r64), optional :: std private subroutine rngNormal_d3D(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:,:,:) real(kind=r64), optional :: mean real(kind=r64), optional :: std","loc":"interface/rngnormal.html"},{"tags":"","title":"rngUniform – Fortran Program","text":"public interface rngUniform Module Procedures rngUniform_d1 rngUniform_d1D rngUniform_d2D Module Procedures private subroutine rngUniform_d1(this, rmin, rmax) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax private subroutine rngUniform_d1D(this, rmin, rmax) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), optional :: rmin real(kind=r64), optional :: rmax private subroutine rngUniform_d2D(this, rmin, rmax) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:,:) real(kind=r64), optional :: rmin real(kind=r64), optional :: rmax","loc":"interface/rnguniform.html"},{"tags":"","title":"binarySearch – Fortran Program","text":"public interface binarySearch Perform a binary search Example usage use variableKind use m_BinarySearch , only : binarySearch real ( r64 ) :: arr ( 20 ) integer ( i32 ) :: i integer ( i32 ) :: j arr = [( dble ( i ), i = 1 , 20 )] j = binarySearch ( arr , 1 0. d0 , 1 , 20 ) write ( * , * ) 'Location of 10.0 in arr is 10? ' , j == 10 Module Procedures binarySearch_r1D binarySearch_d1D binarySearch_i1D binarySearch_id1D Module Procedures private recursive function binarySearch_r1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present private recursive function binarySearch_d1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present private recursive function binarySearch_i1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present private recursive function binarySearch_id1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present","loc":"interface/binarysearch.html"},{"tags":"","title":"binarySearch_wNeighbours – Fortran Program","text":"public interface binarySearch_wNeighbours Perform a binary search but also return the neighbours.\n This is useful if you need to find a number that is not contained in the array and you want the interval Example usage use variableKind use m_BinarySearch , only : binarySearch_wNeighbours real ( r64 ) :: arr ( 20 ) integer ( i32 ) :: i integer ( i32 ) :: j ( 3 ) arr = [( dble ( i ), i = 1 , 20 )] j = binarySearch_wNeighbours ( arr , 1 0.5 d0 , 1 , 20 ) write ( * , * ) 'Location of 10.5 in arr is -1? ' , j ( 1 ) == - 1 write ( * , * ) 'The interval containing 10.5 is [10,11]? ' , j ( 2 : 3 ) == [ 10 , 11 ] Module Procedures binarySearch_wNeighbours_r1D binarySearch_wNeighbours_d1D binarySearch_wNeighbours_i1D binarySearch_wNeighbours_id1D Module Procedures private recursive function binarySearch_wNeighbours_r1D(this, v, imin, imax) result(iout) Perform a binary search on a double precision vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval private recursive function binarySearch_wNeighbours_d1D(this, v, imin, imax) result(iout) Perform a binary search on a double precision vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval private recursive function binarySearch_wNeighbours_i1D(this, v, imin, imax) result(iout) Perform a binary search on an integer vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval private recursive function binarySearch_wNeighbours_id1D(this, v, imin, imax) result(iout) Perform a binary search on an integer vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval","loc":"interface/binarysearch_wneighbours.html"},{"tags":"","title":"simpleSearch – Fortran Program","text":"public interface simpleSearch Module Procedures simpleSearch_i1D Module Procedures private function simpleSearch_i1D(this, i) result(iout) Simple search over an integer vector Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Search this vector integer(kind=i32) :: i Number to find in the vector Return Value integer(kind=i32) Location of i in this","loc":"interface/simplesearch.html"},{"tags":"","title":"medianOf3 – Fortran Program","text":"public interface medianOf3 Sort three numbers in an array and return the location of the median Module Procedures medianOf3_r1D medianOf3_d1D medianOf3_i1D medianOf3_id1D Module Procedures private subroutine medianOf3_r1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_d1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_i1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_id1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right","loc":"interface/medianof3.html"},{"tags":"","title":"argMedianOf3 – Fortran Program","text":"public interface argMedianOf3 Sort the indices of three numbers into an array and return the location of the median Module Procedures argMedianOf3_r1D argMedianOf3_d1D argMedianOf3_i1D argMedianOf3_id1D Module Procedures private subroutine argMedianOf3_r1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_d1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_i1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_id1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right","loc":"interface/argmedianof3.html"},{"tags":"","title":"select – Fortran Program","text":"public interface select Use an in-place quick select on an array of numbers Example usage program selectTest use variableKind use m_strings , only : str use m_allocate , only : allocate use m_random , only : rngInteger , rngNormal use m_select , only : select real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ) :: k real ( r64 ) :: dv integer ( i32 ) :: iv write ( * , '(a)' ) 'Select the kth smallest element from a 10000 length array of random double precision numbers' call allocate ( d1D , 10000 ) call rngNormal ( d1D ) k = ( 1 + size ( d1D )) / 2 dv = select ( d1D , k ) write ( * , '(a)' ) 'kth element? ' // str ( dv ) write ( * , '(a)' ) 'Select the kth smallest element from a 10000 length array of random integers'' call allocate(i1D, 10000) call rngInteger(i1D) iv = select(i1D, k) write(*,' ( a ) ') ' kth element ? ' // str ( iv ) end program Subroutines quickSelect_i1D quickSelect_id1D quickSelect_r1D quickSelect_d1D Subroutines public subroutine quickSelect_i1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res public subroutine quickSelect_id1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i64) :: res public subroutine quickSelect_r1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r32) :: res public subroutine quickSelect_d1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r64) :: res","loc":"interface/select.html"},{"tags":"","title":"argSelect – Fortran Program","text":"public interface argSelect Use an indirect introspection sort on an array of numbers Example usage program argSortTest use variableKind use m_strings , only : str use m_random , only : rngInteger , rngNormal use m_arrays , only : isSorted use m_Sort , only : argSort real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ), allocatable :: indx (:) integer ( i32 ) :: i , k , N N = 10000 call allocate ( indx , N ) call arange ( indx , 1 , N ) call allocate ( d1D , N ) call rngNormal ( d1D ) k = ( size ( d1D ) + 1 ) / 2 call argSelect ( d1D , indx , k ) write ( * , '(a)' ) 'Double array is indirectly sorted? ' // str ( isSorted ( d1D ( indx ))) call arange ( indx , 1 , N ) call allocate ( i1D , N ) call rngInteger ( i1D ) call argSelectt ( i1D , indx , k ) write ( * , '(a)' ) 'Integer array is indirectly sorted? ' // str ( isSorted ( i1D ( indx ))) end program Subroutines argQuickSelect_i1D argQuickSelect_id1D argQuickSelect_r1D argQuickSelect_d1D Subroutines public subroutine argQuickSelect_i1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_id1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_r1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_d1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right","loc":"interface/argselect.html"},{"tags":"","title":"sort – Fortran Program","text":"public interface sort Use an in-place introspection sort on an array of numbers Example usage program sortTest use variableKind , only : i32 , r64 use m_strings , only : str use m_allocate , only : allocate use m_random , only : rngInteger , rngNormal use m_arrays , only : arange , isSorted use m_sort , only : sort real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ) :: N N = 10000 write ( * , '(a)' ) 'In-place sort a 10000 length array of random double precision numbers' call allocate ( d1D , N ) call rngNormal ( d1D ) call sort ( d1D ) write ( * , '(a)' ) 'Double array is sorted? ' // str ( isSorted ( d1D )) write ( * , '(a)' ) 'In-place sort a 10000 length array of random integers'' call allocate(i1D,N) call rngInteger(i1D) call sort(i1D) write(*,' ( a ) ') ' Integer array is sorted ? ' // str ( isSorted ( i1D )) end program Subroutines sort_i1D sort_id1D sort_r1D sort_d1D Subroutines public subroutine sort_i1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) logical, optional :: stable public subroutine sort_id1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) logical, optional :: stable public subroutine sort_r1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) logical, optional :: stable public subroutine sort_d1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) logical, optional :: stable","loc":"interface/sort.html"},{"tags":"","title":"argSort – Fortran Program","text":"public interface argSort Use an indirect introspection sort on an array of numbers Example usage program argSortTest use variableKind use m_strings , only : str use m_random , only : rngInteger , rngNormal use m_arrays , only : arange , isSorted use m_Sort , only : argSort real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ), allocatable :: indx (:) integer ( i32 ) :: i , N N = 10000 call allocate ( indx , N ) call arange ( indx , 1 , N ) call allocate ( d1D , N ) call rngNormal ( d1D ) call argSort ( d1D , indx ) write ( * , '(a)' ) 'Double array is indirectly sorted? ' // str ( isSorted ( d1D ( indx ))) call arange ( indx , 1 , N ) call allocate ( i1D , N ) call rngInteger ( i1D ) call argSort ( i1D , indx ) write ( * , '(a)' ) 'Integer array is indirectly sorted? ' // str ( isSorted ( i1D ( indx ))) end program Subroutines argSort_i1D argSort_id1D argSort_r1D argSort_d1D Subroutines public subroutine argSort_i1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_id1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_r1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_d1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort?","loc":"interface/argsort.html"},{"tags":"","title":"insertionsort – Fortran Program","text":"public interface insertionsort Perform an in-place insertion sort on an array Subroutines insertionsort_r1D insertionsort_d1D insertionsort_i1D insertionsort_id1D Subroutines public subroutine insertionsort_r1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_d1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_i1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_id1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index","loc":"interface/insertionsort.html"},{"tags":"","title":"argInsertionsort – Fortran Program","text":"public interface argInsertionsort Perform an indirect insertion sort on an array Subroutines argInsertionsort_r1D argInsertionsort_d1D argInsertionsort_i1D argInsertionsort_id1D Subroutines public subroutine argInsertionsort_r1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_d1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_i1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_id1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index","loc":"interface/arginsertionsort.html"},{"tags":"","title":"timeinseconds – Fortran Program","text":"public function timeinseconds(values) result(res) Convert hours minutes seconds etc. to seconds Arguments Type Intent Optional Attributes Name integer(kind=i32) :: values (8) values containing amounts of days hours etc. Return Value real(kind=r64) time in seconds","loc":"proc/timeinseconds.html"},{"tags":"","title":"daysinMonth – Fortran Program","text":"public function daysinMonth(month, year) result(days) Get the number of days in a month. Accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: month How many days in this month integer(kind=i32), optional :: year Check if a leap year? Return Value integer(kind=i32) Number of days","loc":"proc/daysinmonth.html"},{"tags":"","title":"daysinYear – Fortran Program","text":"public function daysinYear(year) result(days) Get the number of days in a year, accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year How many days in this year Return Value integer(kind=i32) Number of days","loc":"proc/daysinyear.html"},{"tags":"","title":"isLeapYear – Fortran Program","text":"public function isLeapYear(year) result(yes) Determine whether the year is a leap year Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year Year to check Return Value logical is a leap year","loc":"proc/isleapyear.html"},{"tags":"","title":"absTimetoHMS – Fortran Program","text":"public function absTimetoHMS(t) result(res) Convert an absolute time to HH:MM:SS.MSEC Arguments Type Intent Optional Attributes Name real(kind=r64) :: t Time in seconds Return Value character(len=22) Resulting string contains the time","loc":"proc/abstimetohms.html"},{"tags":"","title":"ProgressBar – Fortran Program","text":"public interface ProgressBar Module Procedures ProgressBar_i1 ProgressBar_id1 Module Procedures private function ProgressBar_i1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) private function ProgressBar_id1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar )","loc":"interface/progressbar.html"},{"tags":"","title":"m_array1D – Fortran Program","text":"Uses: variableKind m_allocate 1D array routines See arange , diff , isSorted , repeat for more information. Interfaces arange diff isSorted repeat Interfaces public interface arange Create a 1D array from start to stop in given increments of 1 or optionally step public subroutine arange_r1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: res (:) real(kind=r32), intent(in) :: start Start from here real(kind=r32), intent(in) :: stp Stop here real(kind=r32), intent(in), optional :: step Step size public subroutine arange_d1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: res (:) real(kind=r64), intent(in) :: start Start from here real(kind=r64), intent(in) :: stp Stop here real(kind=r64), intent(in), optional :: step Step size public subroutine arange_i1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: res (:) integer(kind=i32), intent(in) :: start Start from here integer(kind=i32), intent(in) :: stp Stop here integer(kind=i32), intent(in), optional :: step Step size public subroutine arange_id1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: res (:) integer(kind=i64), intent(in) :: start Start from here integer(kind=i64), intent(in) :: stp Stop here integer(kind=i64), intent(in), optional :: step Step size public interface diff Compute the difference along an array public subroutine diff_r1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32) :: res (:) Difference along array public subroutine diff_d1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64) :: res (:) Difference along array public subroutine diff_i1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32) :: res (:) Difference along array public subroutine diff_id1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i64) :: res (:) Difference along array public interface isSorted Check that a 1D array is sorted public function isSorted_r1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_d1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_i1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_id1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value logical isSorted public interface repeat Repeat each element nRepeat times public subroutine repeat_r1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r32), allocatable :: res (:) public subroutine repeat_d1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r64), allocatable :: res (:) public subroutine repeat_i1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i32), allocatable :: res (:) public subroutine repeat_id1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i64), allocatable :: res (:)","loc":"module/m_array1d.html"},{"tags":"","title":"m_allocate – Fortran Program","text":"Uses: variableKind m_errors Contains fundamental interface to allocate allocatable arrays of different types and shapes See allocate for more information. Interfaces allocate Interfaces public interface allocate Allocate an allocatable array. If the array is already allocated, memory is reallocated to the given size, unless no size change will occur.\n The allocated memory is NOT initialized to any value, so be sure to do so afterwards if you call allocate. public subroutine allocate_r1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_r2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_r3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_d1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_d2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_d3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_i1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_i2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_i3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_id1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_id2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_id3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_c1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_c2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_c3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_z1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_z2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_z3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_l1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_l2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_l3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size","loc":"module/m_allocate.html"},{"tags":"","title":"m_compare – Fortran Program","text":"Uses: variableKind Interfaces compare Functions compare_d1 Interfaces public interface compare public function compare_d1 (this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32) Functions public function compare_d1 (this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32)","loc":"module/m_compare.html"},{"tags":"","title":"m_copy – Fortran Program","text":"Uses: variableKind m_errors m_allocate Contains fundamental routines to copy arrays to new memory locations while maintaining both copies See copy for more information. Interfaces copy Interfaces public interface copy Copies an array to new memory (no pointers), The output array size will be changed to match the copy. public subroutine copy_r1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_r2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_r3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_d1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_d2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_d3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_i1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_i2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_i3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_id1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_id2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_id3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_c1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_c2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_c3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_z1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_z2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_z3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_l1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:) Copy this array logical, intent(inout), allocatable :: that (:) Copy of this public subroutine copy_l2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:) Copy this array logical, intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_l3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:,:) Copy this array logical, intent(inout), allocatable :: that (:,:,:) Copy of this","loc":"module/m_copy.html"},{"tags":"","title":"m_deallocate – Fortran Program","text":"Uses: variableKind m_errors Contains fundamental interface to deallocate allocatable arrays of different types and shapes. See deallocate for more information. Interfaces deallocate Interfaces public interface deallocate Deallocate an allocatable array. public subroutine deallocate_r1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_r2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_r3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_d1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_d2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_d3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_i1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_i2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_i3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_id1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_id2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_id3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_c1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_c2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_c3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_z1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_z2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_z3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_l1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_l2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_l3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array","loc":"module/m_deallocate.html"},{"tags":"","title":"m_debugging – Fortran Program","text":"Uses: variableKind m_strings Contains routines for debugging Variables verbose debugLevel Interfaces debug Subroutines debug_s Variables Type Visibility Attributes Name Initial logical, public :: verbose = .false. Verbose option for debugging codes integer, public :: debugLevel Integer level for debug messages Interfaces public interface debug Interface for printing primitives with a name for debug purposes\n All may be called using 'call debug(args)' private subroutine debug_D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var private subroutine debug_D1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var (:) private subroutine debug_I(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var private subroutine debug_I1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var (:) Subroutines public subroutine debug_s (name) Arguments Type Intent Optional Attributes Name character(len=*) :: name","loc":"module/m_debugging.html"},{"tags":"","title":"m_errors – Fortran Program","text":"Uses: iso_fortran_env variableKind Module contains error handling procedures Subroutines mErr msg wMsg eMsg fErr Subroutines public subroutine mErr (istat, aMsg, alloc, iunit) Checks for successful (de)allocation.  Stops the code. Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat results of stat=istat in (de)allocate character(len=*), intent(in) :: aMsg Message associated with the (de)allocate integer(kind=i32), intent(in) :: alloc 1 = allocate, 2 = deallocate integer(kind=i32), intent(in), optional :: iunit Optional file id to write the message to public subroutine msg (aMsg, iunit) Write a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to public subroutine wMsg (aMsg, iunit) Write a Warning message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to public subroutine eMsg (aMsg, iunit) Write an Error message. Stops the code Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to public subroutine fErr (istat, fname, flg, iunit) Checks for a file error Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat Result of iostat=istat for open,read,write,close character(len=*), intent(in) :: fname Name of the file integer(kind=i32), intent(in) :: flg 1=Open, 2=Read, 3=Write, 4=Close integer(kind=i32), intent(in), optional :: iunit file id to write the error to","loc":"module/m_errors.html"},{"tags":"","title":"m_fileIO – Fortran Program","text":"Uses: variableKind m_strings m_errors Contains functions and subroutines that inquire and operate on files\n including reading and writing multiple entries to a file Functions fileExists hasExtension isOpen getFileSize getNFileLines getExtension trimExtension Subroutines checkIsOpen openFile openBinaryFile closeFile deleteFile skipFileLines Functions public function fileExists (fName) result(yes) Checks whether the file with name fName exists on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name to check Return Value logical Exists? public function hasExtension (fName, extension) result(yes) Checks if a file 'fname' is of type 'extension' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name character(len=3), intent(in) :: extension Extension to find Return Value logical Has this extension? public function isOpen (fname) result(yes) Is the file open or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name Return Value logical Is the file open? public function getFileSize (fName) result(that) Get the file size in Bytes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value integer(kind=i32) Size of the file public function getNFileLines (fName, nHeader) result(N) Counts the number of lines in a file after the number of specified header lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name integer(kind=i32), intent(in), optional :: nHeader Skip this number of lines at the top of the file Return Value integer(kind=i32) Number of lines in the file public function getExtension (fName) result(that) Get the extension of a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File extension public function trimExtension (fName) result(that) Trims the extension of a filename Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File name without the extension Subroutines public subroutine checkIsOpen (fName) Checks whether a file is open with an error message if not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name public subroutine openFile (fname, iunit, stat, istat) Open a file and perform necessary checks for failure\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error flag public subroutine openBinaryFile (fname, iunit, stat, istat) Open an unformatted binary file\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File Name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error Flag public subroutine closeFile (fname, iunit, stat, istat) Close a file and perform any necessary checks Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are closing integer(kind=i32), intent(out) :: istat Error Flag public subroutine deleteFile (fname) Deletes a file on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name to delete public subroutine skipFileLines (iunit, N) Skip N lines in a file Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit Unit number to skip integer(kind=i32), intent(in) :: N Number of lines to skip","loc":"module/m_fileio.html"},{"tags":"","title":"formatting – Fortran Program","text":"Uses: variableKind Contains routines that handle string formatting","loc":"module/formatting.html"},{"tags":"","title":"m_indexing – Fortran Program","text":"Uses: variableKind Contains routines to obtain packed and unpacked indices into arrays Functions ind2sub sub2ind integerBin Functions public function ind2sub (iG, nSub) result(iSub) Compute the indices in each dimension from the global index Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iG Index into a global vector integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32)\n  (size(nSub)) Indices in each dimension to return public function sub2ind (iSub, nSub) result(iG) Given component indices, get the global vector location. Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iSub (:) Indices in each dimension. The first entry in iL is the left most index integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32) Index in the global vector public function integerBin (this, n, bound) result(i) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer(kind=i32) :: n logical :: bound Return Value integer(kind=i32)","loc":"module/m_indexing.html"},{"tags":"","title":"m_parameters – Fortran Program","text":"Uses: variableKind Module contains user defined parameters for consistent use Variables inf NaN pi Variables Type Visibility Attributes Name Initial real(kind=r64), public, parameter :: inf = huge(0.d0) real(kind=r64), public, parameter :: NaN = transfer((/Z'00000000', Z'7FF80000'/), 1.0_8) real(kind=r64), public, parameter :: pi = dacos(-1.d0)","loc":"module/m_parameters.html"},{"tags":"","title":"m_partition – Fortran Program","text":"Uses: variableKind Contains Hoare's style partitioning algorithm used for quicksorting and quickselect routines. See partition and argPartition for more information. Interfaces partition argPartition Interfaces public interface partition Partitioning used for quickSort and quickSelect routines public subroutine partition_r1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_d1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_i1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot public subroutine partition_id1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot public interface argPartition Partitioning used for argQuicksort routines public subroutine argPartition_r1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_d1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_i1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_id1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i","loc":"module/m_partition.html"},{"tags":"","title":"m_partition3way – Fortran Program","text":"Uses: variableKind m_swap m_compare Contains Hoare's style partitioning algorithms used for quicksorting routines\n  n=(right+left)/2\n  call swap(idx(left),idx(n)) Interfaces partition3way Subroutines partition3way_d1D Interfaces public interface partition3way Partitioning used for quicksort routines public subroutine partition3way_d1D (this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index Subroutines public subroutine partition3way_d1D (this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index","loc":"module/m_partition3way.html"},{"tags":"","title":"m_readline – Fortran Program","text":"Uses: variableKind m_errors m_strings Contains core routines to read different combinations of scalars and 1D arrays from a file Interfaces readline Interfaces public interface readline Read in multiple items from a line private subroutine readLine_a(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_ab(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abc(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcd(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcde(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_av(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdvev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcvdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefv(a, b, c, d, e, f, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector real(kind=r64), intent(out) :: g (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file","loc":"module/m_readline.html"},{"tags":"","title":"m_reallocate – Fortran Program","text":"Uses: variableKind m_errors Contains routines to re-allocate allocatable arrays Copies the original values after reallocation. If you don't need to copy the values, use 'call allocate()' instead Interfaces reallocate Interfaces public interface reallocate Reallocate an allocatable array private subroutine reallocate_r1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_r2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_r3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_d1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_d2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_d3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_i1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_i2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_i3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_id1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_id2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_id3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_c1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_c2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_c3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_z1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_z2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_z3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_l1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_l2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_l3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape","loc":"module/m_reallocate.html"},{"tags":"","title":"m_strings – Fortran Program","text":"Uses: iso_fortran_env variableKind m_errors m_parameters Module provides string handling capabilities\n Replace a substring with another in a string Variables printOptions Interfaces str Derived Types c_printOptions Functions hasNentries countEntries lowerCase upperCase isString appendString prependString iachar1D Subroutines read1Integer read1Dble compact removeComments replacedelim Variables Type Visibility Attributes Name Initial type( c_printOptions ), public :: printOptions Interfaces public interface str Interface to print a string representation of a number\n The output format options can be set using the printOptions class private function str_r1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_r1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d2D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:,:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_1L(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name logical, intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable Derived Types type, public :: c_printOptions Print options similar to numpy's print_options Components Type Visibility Attributes Name Initial integer(kind=i32), public :: precision = 3 Force this precision on the written number integer(kind=i32), public :: threshold = 10 Omit the middle entries if the size is greater than threshold integer(kind=i32), public :: edgeitems = 3 Only write the first and last threshold elements from rows and/or columns character(len=32), public :: nanstr = 'nan' Print NAN as this character(len=32), public :: infstr = 'inf' Print infinity as this Functions public function hasNentries (this, N) result(yes) Check that a string has N entries Arguments Type Intent Optional Attributes Name character(len=*) :: this integer(kind=i32) :: N Return Value logical public function countEntries (this) result(N) Count the number of entries in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Return Value integer(kind=i32) public function lowerCase (str) result(res) Convert a string to lowercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str)) public function upperCase (str) result(res) Convert a string to uppercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str)) public function isString (tmp1, tmp2, exact_) result(yes) Match two string together Arguments Type Intent Optional Attributes Name character(len=*) :: tmp1 Compare this string character(len=*) :: tmp2 Compare this string logical, optional :: exact_ Optional logical, if true, the strings are not converted to lowercase before comparison Return Value logical public function appendString (this, that, delim) result(res) Append a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to append to character(len=*) :: that String to append character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Appended String public function prependString (this, that, delim) result(res) Prepend a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to prepend to character(len=*) :: that String to prepend character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Prepended String public function iachar1D (this) result(res) Use iachar on a full string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this Return Value integer(kind=i32),\n  allocatable, (:) Subroutines public subroutine read1Integer (buf, N, istat) Get a single integer from a line, returns an error code if there is more than one entry Arguments Type Intent Optional Attributes Name character(len=*) :: buf String integer(kind=i32) :: N Single integer integer(kind=i32) :: istat istat > 0 if more than one entry is found public subroutine read1Dble (iunit, this, fname, vName, istat) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit real(kind=r64) :: this character(len=*) :: fname character(len=*) :: vName integer(kind=i32) :: istat public subroutine compact (this) Replace tabs and spaces with a single space\n str must be a variable and not an explicit 'string'. Otherwise adjustl will fail. Arguments Type Intent Optional Attributes Name character(len=*) :: this public elemental subroutine removeComments (this) Removes the text after the ! mark in a string Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: this public subroutine replacedelim (this, dlim, dlimr) Replace a single character length delimiter in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Replace delimiter in this character(len=*) :: dlim Find this delimiter character(len=*) :: dlimr Replace with this delimiter","loc":"module/m_strings.html"},{"tags":"","title":"m_swap – Fortran Program","text":"Uses: variableKind Handles a simple swapping of two elements Interfaces swap Interfaces public interface swap Swap the values of two variables private subroutine swap_i1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this integer(kind=i32), intent(inout) :: that private subroutine swap_id1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this integer(kind=i64), intent(inout) :: that private subroutine swap_r1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this real(kind=r32), intent(inout) :: that private subroutine swap_d1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(inout) :: that private subroutine swap_c1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r32) :: this complex(kind=r32) :: that private subroutine swap_z1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r64) :: this complex(kind=r64) :: that private subroutine swap_l1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name logical :: this logical :: that","loc":"module/m_swap.html"},{"tags":"","title":"variableKind – Fortran Program","text":"Uses: iso_fortran_env iso_fortran_env Defines variable kinds Variables cLen Variables Type Visibility Attributes Name Initial integer(kind=i32), public, parameter :: cLen = 1024 Default character length for temporaries","loc":"module/variablekind.html"},{"tags":"","title":"m_writeline – Fortran Program","text":"Uses: iso_fortran_env variableKind m_errors m_strings Contains core routines to write different combinations of scalars and 1D arrays to a file Interfaces writeline Interfaces public interface writeline Write multiple items to a line private subroutine writeLine_a(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_ab(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abc(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcd(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcde(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_av(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdevfv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdvev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcvdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) real(kind=r64) :: g (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit","loc":"module/m_writeline.html"},{"tags":"","title":"m_maths – Fortran Program","text":"Uses: variableKind Math routines Interfaces crossproduct cumprod cumsum fastTwoDiff fastTwoSum geometricMean mean median norm1 normI project trimmedmean twoDiff twoSum std variance Interfaces public interface crossproduct Compute the cross product between two arrays of length 2 or 3 public function crossproduct_r1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (3) 1D Array real(kind=r32), intent(in) :: b (3) 1D Array Return Value real(kind=r32)\n  (3) cross product public function crossproduct_d1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (3) 1D Array real(kind=r64), intent(in) :: b (3) 1D Array Return Value real(kind=r64)\n  (3) cross product public interface cumprod Compute the variance of an array public function cumprod_r1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative product public function cumprod_d1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative product public function cumprod_i1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative product public function cumprod_id1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative product public interface cumsum Compute the variance of an array public function cumsum_r1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative sum public function cumsum_d1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative sum public function cumsum_i1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative sum public function cumsum_id1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative sum public interface fastTwoDiff Compute the difference two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoDiff routine public function fastTwoDiff_r(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoDiff_d(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error public interface fastTwoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoSum routine public function fastTwoSum_r(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoSum_d(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error public interface geometricMean Compute the geometric mean of a vector public function geometricMean_r1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_d1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_i1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_id1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) Return Value real(kind=r64) public interface mean Compute the mean public function mean_r1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_d1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_i1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_id1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public interface median Compute the median of a set of numbers public function median_r1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) median public function median_d1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_i1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_id1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public interface norm1 Compute the L1 norm of a set of numbers public function norm1_r1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) L1 norm public function norm1_d1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_i1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_id1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public interface normI Compute the Linfinity norm of a set of numbers public function normI_r1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) Linfinity norm public function normI_d1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) Linfinity norm public function normI_i1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32) Linfinity norm public function normI_id1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64) Linfinity norm public interface project Project a vector a onto vector b public function project_r1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (:) 1D array real(kind=r32), intent(in) :: b (size(a)) 1D array Return Value real(kind=r32)\n  (size(a)) 1D array public function project_d1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (:) 1D array real(kind=r64), intent(in) :: b (size(a)) 1D array Return Value real(kind=r64)\n  (size(a)) 1D array public interface trimmedmean Compute the Trimmed mean of an array,  alpha is a percent value to trim from either end public function trimmedmean_r1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_d1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_i1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_id1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public interface twoDiff Compute the difference between two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoDiff public function twoDiff_r(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function twoDiff_d(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error public interface twoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoSum public function twoSum_r(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number in sum real(kind=r32), intent(in) :: b Second number in sum Return Value real(kind=r32)\n  (2) The sum and its error public function twoSum_d(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number in sum real(kind=r64), intent(in) :: b Second number in sum Return Value real(kind=r64)\n  (2) The sum and its error public interface std Compute the standard deviation of an array public function std_r1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_d1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_i1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_id1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public interface variance Compute the variance of an array public function variance_r1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_d1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_i1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_id1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance","loc":"module/m_maths.html"},{"tags":"","title":"m_random – Fortran Program","text":"Uses: iso_fortran_env variableKind m_errors m_strings m_indexing Routines for random number generation.  The original code is provided via Netlib at http://www.netlib.org/random/random.f90\n Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM VARIATE IN [0,1]\n FROM A BETA DISTRIBUTION WITH DENSITY\n PROPORTIONAL TO BETA (AA-1) * (1-BETA) (BB-1).\n USING CHENG'S LOG LOGISTIC METHOD. AA = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL)\n BB = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL)\n\n\n\n\n\n Local variables Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM VARIATE FROM A\n T DISTRIBUTION USING KINDERMAN AND MONAHAN'S RATIO METHOD. M = DEGREES OF FREEDOM OF DISTRIBUTION\n       (1 <= 1NTEGER)\n\n\n\n\n Local variables Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 N.B. An extra argument, ier, has been added to Dagpunar's routine SUBROUTINE GENERATES AN N VARIATE RANDOM NORMAL\n VECTOR USING A CHOLESKY DECOMPOSITION. ARGUMENTS:\n        N = NUMBER OF VARIATES IN VECTOR\n           (INPUT,INTEGER >= 1)\n     H(J) = J'TH ELEMENT OF VECTOR OF MEANS\n           (INPUT,REAL)\n     X(J) = J'TH ELEMENT OF DELIVERED VECTOR\n           (OUTPUT,REAL) D(J*(J-1)/2+I) = (I,J)'TH ELEMENT OF VARIANCE MATRIX (J> = I)\n        (INPUT,REAL)\nF((J-1)*(2*N-J)/2+I) = (I,J)'TH ELEMENT OF LOWER TRIANGULAR\n       DECOMPOSITION OF VARIANCE MATRIX (J <= I)\n        (OUTPUT,REAL)\n\nFIRST = .TRUE. IF THIS IS THE FIRST CALL OF THE ROUTINE\nOR IF THE DISTRIBUTION HAS CHANGED SINCE THE LAST CALL OF THE ROUTINE.\nOTHERWISE SET TO .FALSE.\n        (INPUT,LOGICAL)\n\nier = 1 if the input covariance matrix is not +ve definite\n    = 0 otherwise\n\n\n\n\n\n\n\n\n Local variables Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY] FROM\n A REPARAMETERISED GENERALISED INVERSE GAUSSIAN (GIG) DISTRIBUTION\n WITH DENSITY PROPORTIONAL TO  GIG (H-1) * EXP(-0.5 B (GIG+1/GIG))\n USING A RATIO METHOD. H = PARAMETER OF DISTRIBUTION (0 <= REAL)\n B = PARAMETER OF DISTRIBUTION (0 < REAL)\n\n\n\n\n\n Local variables Translated to Fortran 90 by Alan Miller from:\n                       RANLIB\n\n Library of Fortran Routines for Random Number Generation\n\n                Compiled and Written by:\n\n                     Barry W. Brown\n                      James Lovato\n\n         Department of Biomathematics, Box 237\n         The University of Texas, M.D. Anderson Cancer Center\n         1515 Holcombe Boulevard\n         Houston, TX      77030 This work was supported by grant CA-16672 from the National Cancer Institute. GENerate POIsson random deviate\n\n                        Function Generates a single random deviate from a Poisson distribution with mean mu. Arguments\n\n mu --> The mean of the Poisson distribution from which\n        a random deviate is to be generated.\n                          REAL mu\n\n                          Method\n\n For details see:\n\n           Ahrens, J.H. and Dieter, U.\n           Computer Generation of Poisson Deviates\n           From Modified Normal Distributions.\n           ACM Trans. Math. Software, 8, 2\n           (June 1982),163-179\n\n TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT\n COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL\n\n SEPARATION OF CASES A AND B\n\n .. Scalar Arguments ..\n\n\n\n ..\n .. Local Scalars ..\n\n\n\n\n\n\n ..\n .. Local Arrays ..\n\n ..\n .. Data statements ..\n\n\n\n\n\n\n\n ..\n .. Executable Statements ..\n\n C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED)\n\n\n\n\n\n         THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL\n         PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484)\n         IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 .\n\n\n\n\n\n\n STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE\n\n\n\n\n\n STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH\n\n\n\n STEP S. SQUEEZE ACCEPTANCE - SAMPLE U\n\n\n\n\n\n\n\n STEP P. PREPARATIONS FOR STEPS Q AND H.\n         (RECALCULATIONS OF PARAMETERS IF NECESSARY)\n         .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7.\n         THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE\n         APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK.\n         C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN)\n\n\n\n\n STEP Q. QUOTIENT ACCEPTANCE (RARE CASE)\n\n\n\n STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL\n         DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT'\n         (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.)\n\n\n\n\n\n\n\n\n\n\n         'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN)\n\n\n\n\n STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION)\n\n\n\n\n STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY.\n         CASE ival < 10 USES FACTORIALS FROM TABLE FACT\n\n\n\n\n\n\n         CASE ival >= 10 USES POLYNOMIAL APPROXIMATION\n         A0-A7 FOR ACCURACY WHEN ADVISABLE\n         .8333333E-1=1./12.  .3989423=(2*PI)**(-.5) C A S E  B.    mu < 10\n START NEW TABLE AND CALCULATE P0 IF NECESSARY\n\n\n\n\n\n\n\n\n\n\n STEP U. UNIFORM SAMPLE FOR INVERSION METHOD\n\n\n\n\n\n\n STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE\n         PP-TABLE OF CUMULATIVE POISSON PROBABILITIES\n         (0.458=PP(9) FOR MU=10)\n\n\n\n\n\n\n\n\n\n STEP C. CREATION OF NEW POISSON PROBABILITIES P\n         AND THEIR CUMULATIVES Q=PP(K) FUNCTION GENERATES A RANDOM BINOMIAL VARIATE USING C.D.Kemp's method.\n This algorithm is suitable when many random variates are required\n with the SAME parameter values for n & p. P = BERNOULLI SUCCESS PROBABILITY\n       (0 <= REAL <= 1)\nN = NUMBER OF BERNOULLI TRIALS\n       (1 <= INTEGER)\nFIRST = .TRUE. for the first call using the current parameter values\n      = .FALSE. if the values of (n,p) are unchanged from last call Reference: Kemp, C.D. (1986). `A modal method for generating binomial\n            variables', Commun. Statist. - Theor. Meth. 15(3), 805-813. Local variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n This point should not be reached, but just in case:\n\n\n\n\n\n\n\n\n\n Calculate a binomial probability\n\n\n\n\n\n Local variable Logarithm to base e of the gamma function. Accurate to about 1.e-14.\n Programmer: Alan Miller Latest revision of Fortran 77 version - 28 February 1988 Local variables\n\n\n\n\n\n\n\n   lngamma is not defined if x = 0 or a negative integer.\n\n\n\n\n\n\n   If x < 0, use the reflection formula:\n           gamma(x) * gamma(1-x) = pi * cosec(pi.x)\n\n\n\n\n\n\n\n\n   Increase the argument, if necessary, to make it > 10. Use a polynomial approximation to Stirling's formula.\n  N.B. The real Stirling's formula is used here, not the simpler, but less\n       accurate formula given by De Moivre in a letter to Stirling, which\n       is the one usually quoted. Translated to Fortran 90 by Alan Miller from:\n                          RANLIB\n\n Library of Fortran Routines for Random Number Generation\n\n                  Compiled and Written by:\n\n                       Barry W. Brown\n                        James Lovato\n\n           Department of Biomathematics, Box 237\n           The University of Texas, M.D. Anderson Cancer Center\n           1515 Holcombe Boulevard\n           Houston, TX      77030 This work was supported by grant CA-16672 from the National Cancer Institute. GENerate BINomial random deviate\n\n                          Function\n\n Generates a single random deviate from a binomial\n distribution whose number of trials is N and whose\n probability of an event in each trial is P.\n\n                          Arguments\n\n N  --> The number of trials in the binomial distribution\n        from which a random deviate is to be generated.\n                          INTEGER N\n\n P  --> The probability of an event in each trial of the\n        binomial distribution from which a random deviate\n        is to be generated.\n                          REAL P\n\n FIRST --> Set FIRST = .TRUE. for the first call to perform initialization\n           the set FIRST = .FALSE. for further calls using the same pair\n           of parameter values (N, P).\n                          LOGICAL FIRST\n\n random_binomial2 <-- A random deviate yielding the number of events\n            from N independent trials, each of which has\n            a probability of event P.\n                          INTEGER random_binomial\n\n                          Method\n\n This is algorithm BTPE from:\n\n     Kachitvichyanukul, V. and Schmeiser, B. W.\n     Binomial Random Variate Generation.\n     Communications of the ACM, 31, 2 (February, 1988) 216. * DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY ..\n .. Scalar Arguments ..\n\n\n\n\n ..\n .. Local Scalars ..\n\n\n\n\n\n\n\n ..\n .. Executable Statements .. * SETUP, PERFORM ONLY WHEN PARAMETERS CHANGE * GENERATE VARIATE, Binomial mean at least 30. TRIANGULAR REGION\n\n\n\n\n\n\n PARALLELOGRAM REGION\n\n\n\n\n\n\n\n\n LEFT TAIL\n\n\n\n\n\n\n\n RIGHT TAIL * DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST EXPLICIT EVALUATION\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n SQUEEZING USING UPPER AND LOWER BOUNDS ON LOG(F(X))\n\n\n\n\n\n\n\n STIRLING'S (actually de Moivre's) FORMULA TO MACHINE ACCURACY FOR\n THE FINAL ACCEPTANCE/REJECTION TEST\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n INVERSE CDF LOGIC FOR MEAN LESS THAN 30 Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM NEGATIVE BINOMIAL VARIATE USING UNSTORED\n INVERSION AND/OR THE REPRODUCTIVE PROPERTY. SK = NUMBER OF FAILURES REQUIRED (Dagpunar's words!)\n   = the `power' parameter of the negative binomial\n       (0 < REAL)\nP = BERNOULLI SUCCESS PROBABILITY\n       (0 < REAL < 1) THE PARAMETER H IS SET SO THAT UNSTORED INVERSION ONLY IS USED WHEN P <= H,\n OTHERWISE A COMBINATION OF UNSTORED INVERSION AND\n THE REPRODUCTIVE PROPERTY IS USED. Local variables THE PARAMETER ULN = -LOG(MACHINE'S SMALLEST REAL NUMBER). Algorithm VMD from:\n Dagpunar, J.S. (1990) `Sampling from the von Mises distribution via a\n comparison of random numbers', J. of Appl. Statist., 17, 165-168.\n\n Fortran 90 code by Alan Miller\n CSIRO Division of Mathematical & Information Sciences\n\n Arguments:\n k (real)        parameter of the von Mises distribution.\n first (logical) set to .TRUE. the first time that the function\n                 is called, or the first time with a new value\n                 for k.   When first = .TRUE., the function sets\n                 up starting values and may be very much slower.\n\n\n\n\n\n Local variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Set up array p of probabilities.\n\n\n\n\n\n\n\n\n\n Numerical integration of e&#94;[k.cos(x)] from theta(j-1) to theta(j)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Gaussian integration of exp(k.cosx) from a to b.\n\n\n\n\n\n Local variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Generate a random deviate from the standard Cauchy distribution\n\n\n\n Local variables Variables isInitialized zero half one two vsmall vlarge Interfaces setRNG shuffle rngInteger rngWeibull rngExponential rngChisq rngGamma rngNormal rngUniform Variables Type Visibility Attributes Name Initial logical, protected :: isInitialized = .false. real(kind=r64), protected :: zero = 0.d0 real(kind=r64), protected :: half = 0.5d0 real(kind=r64), protected :: one = 1.d0 real(kind=r64), protected :: two = 2.d0 real(kind=r64), protected :: vsmall = TINY(1.d0) real(kind=r64), protected :: vlarge = HUGE(1.d0) Interfaces public interface setRNG Sets the random number with or without a seed private subroutine setRNG_Wseed(seed) Interfaced to setRNG()\n Sets the seed of the random number generator with a specified seed Arguments Type Intent Optional Attributes Name integer :: seed (:) private subroutine setRNG_WOseed(display) Interfaced to setRNG()\n 'Randomly' sets the seed of the random number generator Arguments Type Intent Optional Attributes Name logical :: display public interface shuffle Perform Knuth shuffling on an array public subroutine shuffle_r1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array public subroutine shuffle_d1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array public subroutine shuffle_i1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array public subroutine shuffle_id1D(this) Interfaced with shuffle() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array public interface rngInteger private subroutine rngInteger_i1(this, imin, imax) Generate a random integer from imin to imax Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this integer(kind=i32) :: imin integer(kind=i32) :: imax private subroutine rngInteger_i1D(this, imin) Generate size(this) random integers starting from imin Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: imin public interface rngWeibull private subroutine rngWeibull_d1(this, den) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64), intent(in) :: den private subroutine rngWeibull_d1D(this, den) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), intent(in) :: den public interface rngExponential private subroutine rngExponential_d1(this) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this private subroutine rngExponential_d1D(this) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) public interface rngChisq private subroutine rngChisq_d1(this, ndf, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer, intent(in) :: ndf logical, intent(in) :: first private subroutine rngChisq_d1D(this, ndf, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer, intent(in) :: ndf logical, intent(in) :: first public interface rngGamma private subroutine rngGamma_d1(this, s, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64), intent(in) :: s logical, intent(in) :: first private subroutine rngGamma_d1D(this, s, first) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), intent(in) :: s logical, intent(in) :: first public interface rngNormal private subroutine rngNormal_d1(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std private subroutine rngNormal_d1D(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), optional :: mean real(kind=r64), optional :: std private subroutine rngNormal_d2D(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:,:) real(kind=r64), optional :: mean real(kind=r64), optional :: std private subroutine rngNormal_d3D(this, mean, std) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:,:,:) real(kind=r64), optional :: mean real(kind=r64), optional :: std public interface rngUniform private subroutine rngUniform_d1(this, rmin, rmax) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax private subroutine rngUniform_d1D(this, rmin, rmax) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), optional :: rmin real(kind=r64), optional :: rmax private subroutine rngUniform_d2D(this, rmin, rmax) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:,:) real(kind=r64), optional :: rmin real(kind=r64), optional :: rmax","loc":"module/m_random.html"},{"tags":"","title":"m_BinarySearch – Fortran Program","text":"Uses: variableKind Contains routines to perform a simple binary search on a vector Interfaces binarySearch binarySearch_wNeighbours Interfaces public interface binarySearch Perform a binary search private recursive function binarySearch_r1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present private recursive function binarySearch_d1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present private recursive function binarySearch_i1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present private recursive function binarySearch_id1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public interface binarySearch_wNeighbours Perform a binary search but also return the neighbours.\n This is useful if you need to find a number that is not contained in the array and you want the interval private recursive function binarySearch_wNeighbours_r1D(this, v, imin, imax) result(iout) Perform a binary search on a double precision vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval private recursive function binarySearch_wNeighbours_d1D(this, v, imin, imax) result(iout) Perform a binary search on a double precision vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval private recursive function binarySearch_wNeighbours_i1D(this, v, imin, imax) result(iout) Perform a binary search on an integer vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval private recursive function binarySearch_wNeighbours_id1D(this, v, imin, imax) result(iout) Perform a binary search on an integer vector\n Returns a length 3 integer(i32) vector where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval","loc":"module/m_binarysearch.html"},{"tags":"","title":"m_simpleSearch – Fortran Program","text":"Contains simple search routines Interfaces simpleSearch Interfaces public interface simpleSearch private function simpleSearch_i1D(this, i) result(iout) Simple search over an integer vector Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Search this vector integer(kind=i32) :: i Number to find in the vector Return Value integer(kind=i32) Location of i in this","loc":"module/m_simplesearch.html"},{"tags":"","title":"m_medianOf3 – Fortran Program","text":"Uses: variableKind m_swap Given three numbers, find their median and sort at the same time Interfaces medianOf3 argMedianOf3 Interfaces public interface medianOf3 Sort three numbers in an array and return the location of the median private subroutine medianOf3_r1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_d1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_i1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_id1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right public interface argMedianOf3 Sort the indices of three numbers into an array and return the location of the median private subroutine argMedianOf3_r1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_d1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_i1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_id1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right","loc":"module/m_medianof3.html"},{"tags":"","title":"m_select – Fortran Program","text":"Uses: variableKind Perform a quickselect on an array. Quick select finds the kth smallest number in an array. It also puts values lower than the kth on the left, and those higher on the right\n This makes it perfect for finding the median. Interfaces select argSelect Interfaces public interface select Use an in-place quick select on an array of numbers public subroutine quickSelect_i1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res public subroutine quickSelect_id1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i64) :: res public subroutine quickSelect_r1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r32) :: res public subroutine quickSelect_d1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r64) :: res public interface argSelect Use an indirect introspection sort on an array of numbers public subroutine argQuickSelect_i1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_id1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_r1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_d1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right","loc":"module/m_select.html"},{"tags":"","title":"m_sort – Fortran Program","text":"Uses: variableKind Module containing in-place and indirect routines to sort an array of numbers. Uses an introspective sort on a set of number. See this http://www.geeksforgeeks.org/know-your-sorting-algorithm-set-2-introsort-cs-sorting-weapon/ for more information To begin, a quicksort with a median of three pivot is used until the size of the array is less than 16.  At this point, an insertion sort is used to reduce cache overhead and tail recursion.\n Unfortunately, a quicksort is not ideal for sorted/almost sorted arrays or arrays with duplicate values.  Therefore if the number of iterations exceededs a threshold, a heapsort is used instead.\n This provides a robust sorting algorithm that is still very fast for almost sorted arrays. In this implementation, the quicksort and heapsort are unstable sorts. A stable merge sort is therefore provided as an alternative but it has an order(N) memory overhead. Often, the numbers wish to be maintained in their given order, so with an O(N) memory overhead we can sort an integer array instead by calling argsort() See sort and argSort for more information. Interfaces sort argSort insertionsort argInsertionsort Interfaces public interface sort Use an in-place introspection sort on an array of numbers public subroutine sort_i1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) logical, optional :: stable public subroutine sort_id1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) logical, optional :: stable public subroutine sort_r1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) logical, optional :: stable public subroutine sort_d1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) logical, optional :: stable public interface argSort Use an indirect introspection sort on an array of numbers public subroutine argSort_i1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_id1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_r1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_d1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public interface insertionsort Perform an in-place insertion sort on an array public subroutine insertionsort_r1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_d1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_i1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_id1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public interface argInsertionsort Perform an indirect insertion sort on an array public subroutine argInsertionsort_r1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_d1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_i1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_id1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index","loc":"module/m_sort.html"},{"tags":"","title":"m_KdTree – Fortran Program","text":"Uses: variableKind m_errors m_allocate m_deallocate m_array1D m_random m_select m_maths Module contains classes to create K-dimensional trees in 2, 3, and N dimensions. This KdTree is balanced, in that splits are made along the dimension with the largest variance. A quickselect is used to find the median in that split dimension as the splitting value. After the tree is initialized, for a given set of points, a search class can be used to perform nearest neighbour, range search, k nearest neighbours etc.\nThe searches are thread safe and can be used in a parallel region if multiple are needed. Once a tree is generated, the point coordinates should not be changed, otherwise the tree will no longer be correct. Generating the tree does not modify the incoming point coordinates. Example program kdTree_test use variableKind , only : r64 use m_allocate , only : allocate use m_deallocate , only : deallocate use m_random , only : rngNormal use m_KdTree , only : KdTree , KdTreeSearch use m_string , only : str implicit none real ( r64 ), allocatable :: x (:), y (:) integer ( i32 ) :: N type ( KdTree ) :: tree type ( KdSearch ) :: search N = 1 d6 call allocate ( x , N ) call allocate ( y , N ) call rngNormal ( x ) call rngNormal ( y ) call tree % init ( x , y ) ia = search % kNearest ( tree , x , y , xQuery = 0. d0 , yQuery = 0. d0 ) write ( * , '(3a)' ) 'Nearest point to the query location: ' , str ( x ( ia )), str ( y ( ia )) call tree % deallocate () call deallocate ( x ) call deallocate ( y ) end program Derived Types KdTree KdTreeSearch Derived Types type, public :: KdTree KdTree in 2, 3, or N dimensions.  See m_KdTree for more information on how to use this class. Type-Bound Procedures generic, public :: init => ikdt2 KdTree%init() - Initialize the class procedure, public :: deallocate => deallocate_KdTree kdTree%deallocate() - deallocate the recursive pointers type, public :: KdTreeSearch Class to search a KdTree.  See m_KdTree for more information on how to use this class. Type-Bound Procedures procedure, public :: init => init_KdTreeSearch Initialize the class generic, public :: kNearest => kNearest2D Perform a k nearest neighbour search","loc":"module/m_kdtree.html"},{"tags":"","title":"m_time – Fortran Program","text":"Uses: variableKind Contains functions that handle time Functions timeinseconds daysinMonth daysinYear isLeapYear absTimetoHMS Functions public function timeinseconds (values) result(res) Convert hours minutes seconds etc. to seconds Arguments Type Intent Optional Attributes Name integer(kind=i32) :: values (8) values containing amounts of days hours etc. Return Value real(kind=r64) time in seconds public function daysinMonth (month, year) result(days) Get the number of days in a month. Accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: month How many days in this month integer(kind=i32), optional :: year Check if a leap year? Return Value integer(kind=i32) Number of days public function daysinYear (year) result(days) Get the number of days in a year, accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year How many days in this year Return Value integer(kind=i32) Number of days public function isLeapYear (year) result(yes) Determine whether the year is a leap year Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year Year to check Return Value logical is a leap year public function absTimetoHMS (t) result(res) Convert an absolute time to HH:MM:SS.MSEC Arguments Type Intent Optional Attributes Name real(kind=r64) :: t Time in seconds Return Value character(len=22) Resulting string contains the time","loc":"module/m_time.html"},{"tags":"","title":"ProgressBar_Class – Fortran Program","text":"Uses: iso_fortran_env variableKind Stopwatch_Class m_time An inline and updateable command prompt progress bar Example usage use variableKind use ProgressBar_Class type ( ProgressBar ) :: P integer ( i32 ) :: i , N N = 100000 call P % set ( N , time = . false .) call P % print ( 0 ) do i = 1 , N Compute some stuff call P % print ( i ) enddo call P % set ( N , time = . true .) call P % print ( 0 ) do i = 1 , N Compute some stuff call P % print ( i ) enddo Interfaces ProgressBar Derived Types ProgressBar Interfaces public interface ProgressBar private function ProgressBar_i1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) private function ProgressBar_id1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) Derived Types type, public :: ProgressBar A progress bar that displays a moving counter with percentage and optional estimated time remaining\n Print the progress Bar Constructor private  function ProgressBar_i1 (N, title, time) Interfaced with class instantiation ProgressBar() private  function ProgressBar_id1 (N, title, time) Interfaced with class instantiation ProgressBar() Type-Bound Procedures generic, public :: print => print_i1_ProgressBar_, print_id1_ProgressBar_ Print the progress Bar","loc":"module/progressbar_class.html"},{"tags":"","title":"Stopwatch_Class – Fortran Program","text":"Uses: iso_fortran_env variableKind m_strings m_time Contains code timing capabilities Example usage program stopwatch_test use variableKind , only : i32 use Stopwatch_Class , only : Stopwatch type ( Stopwatch ) :: clk integer ( i32 ) :: i , N call clk % start ( 'Some Title' ) N = 100000 do i = 1 , N Compute some stuff enddo call clk % stop () call clk % elapsed () write ( * , '(a)' ) 'Finished on ' // clk % datetime () end program Derived Types Stopwatch Derived Types type, public :: Stopwatch Class for timing sections of code, See the Stopwatch_Class module documentation for usage. Type-Bound Procedures procedure, public :: start => start_Stopwatch Start the Stopwatch procedure, public :: stop => stop_Stopwatch Stop the Stopwatch procedure, public :: reset => reset_Stopwatch Reset the Stopwatch procedure, public :: restart => restart_Stopwatch Restart the Stopwatch procedure, public :: time => time_Stopwatch Get the current or stopped time procedure, public :: lap => lap_Stopwatch Lap the Stopwatch procedure, public :: lapInSeconds => lapInSeconds_Stopwatch Get the lap time in seconds procedure, public :: elapsed => elapsed_Stopwatch Get the current elapsed time procedure, public :: elapsedInSeconds => elapsedInSeconds_Stopwatch Get the elapsed time in seconds procedure, public :: date => date_Stopwatch Print the date procedure, public :: dateAndTime => dateAndTime_Stopwatch Print the date and time","loc":"module/stopwatch_class.html"}]}