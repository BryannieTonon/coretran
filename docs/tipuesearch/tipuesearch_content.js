var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Developer Info Leon Foks I do cool things in Fortran. (I think)","loc":"index.html","tags":""},{"title":"m_array1D.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_array1d.f90~~EfferentGraph sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_array1d.f90~~AfferentGraph sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 var pansourcefilem_array1df90AfferentGraph = svgPanZoom('#sourcefilem_array1df90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_array1D Source Code m_array1D.f90 Source Code module m_array1D !! 1D array routines !! !! See !! [[arange]], [[diff]], [[isSorted]], [[repeat]] !! for more information. use variableKind , only : r32 , r64 , i32 , i64 use m_errors , only : msg use m_allocate , only : allocate use m_deallocate , only : deallocate use m_unitTester , only : tester implicit none private public :: array1D_test public :: arange interface arange !! Create a 1D array from start to stop in given increments of 1 or optionally step !! !! Example Usage !!```fortran !!program arangeTest !!use variableKind, only: i32,i64,r32,r64 !!use m_allocatable, only: allocatable !!use m_array1D, only: arange !!real(r32), allocatable :: a(:) !!integer(i32), allocatable :: b(:) !!real(r64), allocatable :: c(:) !!integer(i64), allocatable :: d(:) !!integer :: N !!N = 10000 !!call allocate(a, N) !!call allocate(b, N) !!call allocate(c, N) !!call allocate(d, N) !! !!call arange(a, 1, N) !!call arange(b, 1, N) !!call arange(c, 1, N) !!call arange(d, 1, N) !! !!call deallocate(a) !!call deallocate(b) !!call deallocate(c) !!call deallocate(d) !! !!end program !!``` module subroutine arange_r1D ( res , start , stp , step ) !! Interfaced with [[arange]] real ( r32 ), intent ( in ) :: start !! Start from here real ( r32 ), intent ( in ) :: stp !! Stop here real ( r32 ), optional , intent ( in ) :: step !! Step size real ( r32 ), allocatable , intent ( inout ) :: res (:) end subroutine module subroutine arange_d1D ( res , start , stp , step ) !! Interfaced with [[arange]] real ( r64 ), intent ( in ) :: start !! Start from here real ( r64 ), intent ( in ) :: stp !! Stop here real ( r64 ), optional , intent ( in ) :: step !! Step size real ( r64 ), allocatable , intent ( inout ) :: res (:) end subroutine module subroutine arange_i1D ( res , start , stp , step ) !! Interfaced with [[arange]] integer ( i32 ), intent ( in ) :: start !! Start from here integer ( i32 ), intent ( in ) :: stp !! Stop here integer ( i32 ), optional , intent ( in ) :: step !! Step size integer ( i32 ), allocatable , intent ( inout ) :: res (:) end subroutine module subroutine arange_id1D ( res , start , stp , step ) !! Interfaced with [[arange]] integer ( i64 ), intent ( in ) :: start !! Start from here integer ( i64 ), intent ( in ) :: stp !! Stop here integer ( i64 ), optional , intent ( in ) :: step !! Step size integer ( i64 ), allocatable , intent ( inout ) :: res (:) end subroutine end interface public :: diff interface diff !! Compute the difference along an array !! !! Example Usage !!```fortran !!program arangeTest !!use variableKind, only: i32,i64,r32,r64 !!use m_allocatable, only: allocatable !!use m_array1D, only: arange, diff !!real(r32), allocatable :: a(:) !!integer(i32), allocatable :: b(:) !!real(r64), allocatable :: c(:) !!integer(i64), allocatable :: d(:) !!integer :: N !!N = 10000 !!call allocate(a, N) !!call allocate(b, N) !!call allocate(c, N) !!call allocate(d, N) !! !!call arange(a, 1, N) !!call arange(b, 1, N) !!call arange(c, 1, N) !!call arange(d, 1, N) !! !!call diff(a, 1, N) !!call diff(b, 1, N) !!call diff(c, 1, N) !!call diff(d, 1, N) !! !!call deallocate(a) !!call deallocate(b) !!call deallocate(c) !!call deallocate(d) !! !!end program !!``` module subroutine diff_r1D ( this , res ) !! Interfaced with [[diff]] real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res (:) !! Difference along array end subroutine module subroutine diff_d1D ( this , res ) !! Interfaced with [[diff]] real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res (:) !! Difference along array end subroutine module subroutine diff_i1D ( this , res ) !! Interfaced with [[diff]] integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res (:) !! Difference along array end subroutine module subroutine diff_id1D ( this , res ) !! Interfaced with [[diff]] integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res (:) !! Difference along array end subroutine end interface public isSorted interface isSorted !! Check that a 1D array is sorted !! !! Example Usage !!```fortran !!program arangeTest !!use variableKind, only: i32,i64,r32,r64 !!use m_allocatable, only: allocatable !!use m_array1D, only: arange, isSorted !!real(r32), allocatable :: a(:) !!integer(i32), allocatable :: b(:) !!real(r64), allocatable :: c(:) !!integer(i64), allocatable :: d(:) !!integer :: N !!N = 10000 !!call allocate(a, N) !!call allocate(b, N) !!call allocate(c, N) !!call allocate(d, N) !! !!call arange(a, 1, N) !!call arange(b, 1, N) !!call arange(c, 1, N) !!call arange(d, 1, N) !! !!call diff(a, 1, N) !!call diff(b, 1, N) !!call diff(c, 1, N) !!call diff(d, 1, N) !! !!call deallocate(a) !!call deallocate(b) !!call deallocate(c) !!call deallocate(d) !! !!end program !!``` module function isSorted_r1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] real ( r32 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_d1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] real ( r64 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_i1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] integer ( i32 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_id1D ( this ) result ( yes ) !! Interfaced with [[isSorted]] integer ( i64 ), intent ( in ) :: this (:) !! 1D array logical :: yes !! isSorted end function module function isSorted_r1Di1D ( this , indx ) result ( yes ) !! Interfaced with [[isSorted]] real ( r32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: indx (:) !! Index into 1D array logical :: yes !! isSorted end function module function isSorted_d1Di1D ( this , indx ) result ( yes ) !! Interfaced with [[isSorted]] real ( r64 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: indx (:) !! Index into 1D array logical :: yes !! isSorted end function module function isSorted_i1Di1D ( this , indx ) result ( yes ) !! Interfaced with [[isSorted]] integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: indx (:) !! Index into 1D array logical :: yes !! isSorted end function module function isSorted_id1Di1D ( this , indx ) result ( yes ) !! Interfaced with [[isSorted]] integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: indx (:) !! Index into 1D array logical :: yes !! isSorted end function end interface public repeat interface repeat !! Repeat each element nRepeat times module subroutine repeat_r1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated real ( r32 ), allocatable :: res (:) end subroutine module subroutine repeat_d1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated real ( r64 ), allocatable :: res (:) end subroutine module subroutine repeat_i1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated integer ( i32 ), allocatable :: res (:) end subroutine module subroutine repeat_id1D ( this , nRepeats , res ) !! Interfaced with [[repeat]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: nRepeats !! Number of times each element should be repeated integer ( i64 ), allocatable :: res (:) end subroutine end interface !  interface isConstant !  module procedure :: isConstant_DV !  end interface !  private :: isConstant_DV ! !  interface isConstantIncrement !  module procedure :: isConstantIncrement_DV !  end interface !  private :: isConstantIncrement_DV ! !  interface isInside !  module procedure :: isInside1D_I1,isInside1D_D1 !  end interface ! !  interface getBin !  module procedure :: getBin1D_I1,getBin1D_D1 !  end interface ! !  interface scale !  module procedure :: scaleVector !  end interface ! !  interface deintegerize !  module procedure :: deintegerizeVector !  end interface !  private :: deintegerizeVector ! !  private :: isInside1D_I1,isInside1D_D1 !  private :: getBin1D_I1,getBin1D_D1 ! !  interface mapExponential !  module procedure :: mapExponential_1D !  end interface !  private :: mapExponential_1D ! !  interface unitize !  module procedure :: unitize_1D !  end interface !  private :: unitize_1D contains !====================================================================! subroutine array1D_test ( test ) !====================================================================! class ( tester ) :: test real ( r32 ) :: ar real ( r32 ), allocatable :: ar1D (:), br1D (:) real ( r64 ) :: a real ( r64 ), allocatable :: a1D (:), b1D (:) integer ( i32 ) :: ia , ib , ic integer ( i32 ), allocatable :: ia1D (:), ib1D (:) integer ( i64 ) :: iad integer ( i64 ), allocatable :: iad1D (:), ibd1D (:) call Msg ( '==========================' ) call Msg ( 'Testing : Array 1D' ) call Msg ( '==========================' ) call allocate ( ar1D , 3 ) call allocate ( a1D , 3 ) call allocate ( ia1D , 3 ) call allocate ( iad1D , 3 ) call allocate ( br1D , 2 ) call allocate ( b1D , 2 ) call allocate ( ib1D , 2 ) call allocate ( ibd1D , 2 ) call arange ( ar1D , 1.0 , 3.0 , 1.0 ) call test % test ( all ( ar1D == [ 1.0 , 2.0 , 3.0 ]), 'arange_r1D' ) call arange ( a1D , 1.d0 , 3.d0 , 1.d0 ) call test % test ( all ( a1D == [ 1.d0 , 2.d0 , 3.d0 ]), 'arange_d1D' ) call arange ( ia1D , 1 , 3 , 1 ) call test % test ( all ( ia1D == [ 1 , 2 , 3 ]), 'arange_i1D' ) call arange ( iad1D , 1_i64 , 3_i64 , 1_i64 ) call test % test ( all ( iad1D == [ 1 , 2 , 3 ]), 'arange_id1D' ) call diff ( ar1D , br1D ) call test % test ( all ( br1D == [ 1.0 , 1.0 ]), 'diff_r1D' ) call diff ( a1D , b1D ) call test % test ( all ( b1D == [ 1.d0 , 1.d0 ]), 'diff_d1D' ) call diff ( ia1d , ib1D ) call test % test ( all ( ib1D == [ 1 , 1 ]), 'diff_i1D' ) call diff ( iad1d , ibd1D ) call test % test ( all ( ibd1D == [ 1 , 1 ]), 'diff_id1D' ) call allocate ( br1D , size ( ar1D ) * 3 ) call allocate ( b1D , size ( a1D ) * 3 ) call allocate ( ib1D , size ( ia1D ) * 3 ) call allocate ( ibd1D , size ( iad1D ) * 3 ) call repeat ( ar1D , 3 , br1D ) call test % test ( all ( br1D == [ 1.0 , 1.0 , 1.0 , 2.0 , 2.0 , 2.0 , 3.0 , 3.0 , 3.0 ]), 'repeat_r1D' ) call repeat ( a1D , 3 , b1D ) call test % test ( all ( b1D == [ 1.d0 , 1.d0 , 1.d0 , 2.d0 , 2.d0 , 2.d0 , 3.d0 , 3.d0 , 3.d0 ]), 'repeat_d1D' ) call repeat ( ia1D , 3 , ib1D ) call test % test ( all ( ib1D == [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ]), 'repeat_ib1D' ) call repeat ( iad1D , 3 , ibd1D ) call test % test ( all ( ibd1D == [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ]), 'repeat_ibd1D' ) call deallocate ( ar1D ) call deallocate ( a1D ) call deallocate ( ia1D ) call deallocate ( iad1D ) call deallocate ( br1D ) call deallocate ( b1D ) call deallocate ( ib1D ) call deallocate ( ibd1D ) end subroutine !====================================================================! end module","loc":"sourcefile/m_array1d.f90.html","tags":""},{"title":"m_allocate.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_allocate.f90~~EfferentGraph sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_allocate.f90~~AfferentGraph sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_allocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_allocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_allocate.f90->sourcefile~m_maths.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_allocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_copy.f90 m_copy.f90 sourcefile~m_allocate.f90->sourcefile~m_copy.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 var pansourcefilem_allocatef90AfferentGraph = svgPanZoom('#sourcefilem_allocatef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_allocate Source Code m_allocate.f90 Source Code module m_allocate !! Contains fundamental interface to allocate allocatable arrays of different types and shapes !! !! See [[allocate]] for more information. use variableKind use m_unitTester , only : tester use m_errors , only : eMsg , mErr , msg implicit none private public :: allocate public :: allocate_test interface allocate !! Allocate an allocatable array. If the array is already allocated, memory is reallocated to the given size, unless no size change will occur. !! The allocated memory is NOT initialized to any value, so be sure to do so afterwards if you call allocate. !! !! Does not overload the intrinsic allocate function. !! !! This way, calling allocate makes the user aware that checks are being made, and memory will be re-allocated. !! !! Checks for an error during allocation, and will stop the code if there is one. !! !! Example usage !!```fortran !!use variableKind !!use m_allocate, only: allocate !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!call allocate(a1D, 20) !!call allocate(a2D, [20,20]) !!call allocate(a3D, [20,20,20]) !!write(*,'(a)') 'Shape of a3D is [20,20,20]? '//all(shape(a3D) == [20,20,20]) !!``` !====================================================================! module subroutine allocate_r1D ( this , n ) !====================================================================! !!Interfaced with [[allocate]] real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_r2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_r3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_d1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_d2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_d3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_i1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_i2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_i3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_id1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_id2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_id3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_c1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_c2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_c3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_z1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_z2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_z3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_l1D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_l2D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] logical , allocatable , intent ( inout ) :: this (:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! Allocation size end subroutine !====================================================================! !====================================================================! module subroutine allocate_l3D ( this , n ) !====================================================================! !!Interfaced with  [[allocate]] logical , allocatable , intent ( inout ) :: this (:,:,:) !! 1D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! Allocation size end subroutine !====================================================================! end interface contains !====================================================================! module subroutine allocate_r1D ( this , n ) !!Interfaced with  [[allocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_r1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_r2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_r2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_r3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_r3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_d1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_d1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_d2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_d2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_d3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_d3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_i1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_i1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_i2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_i2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_i3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_i3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_id1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_id1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_id2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_id2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_id3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_id3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_c1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_c1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_c2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_c2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_c3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_c3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_z1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_z1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_z2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_z2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_z3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_z3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_l1D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! Allocation size integer ( i32 ) :: istat if ( allocated ( this )) then if ( n == size ( this )) then return ! Don't need to allocate the same size else deallocate ( this ) ! No need to duplicate memory end if end if allocate ( this ( n ), stat = istat ); call mErr ( istat , 'allocate_l1D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_l2D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'allocate_l2D:this' , 1 ) end subroutine !====================================================================! !====================================================================! module subroutine allocate_l3D ( this , n ) !! Interfaced with [[allocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ) :: istat if ( allocated ( this )) then if ( all ( n == shape ( this ))) then return ! Don't need to allocate the same size else deallocate ( this ) end if end if allocate ( this ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'allocate_l3D:this' , 1 ) end subroutine !====================================================================! !====================================================================! subroutine allocate_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test real ( r32 ), allocatable :: ar1D (:), ar2D (:,:), ar3D (:,:,:) real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) integer ( i32 ), allocatable :: ia1D (:), ia2D (:,:), ia3D (:,:,:) integer ( i64 ), allocatable :: iad1D (:), iad2D (:,:), iad3D (:,:,:) complex ( r32 ), allocatable :: z1D (:), z2D (:,:), z3D (:,:,:) complex ( r64 ), allocatable :: zz1D (:), zz2D (:,:), zz3D (:,:,:) logical , allocatable :: la1D (:), la2D (:,:), la3D (:,:,:) call Msg ( '==========================' ) call Msg ( 'Testing : Allocate' ) call Msg ( '==========================' ) call allocate ( ar1D , 100 ) call test % test ( size ( ar1D ) == 100 , 'allocate_r1D' ) call allocate ( ar2D , [ 5 , 6 ]) call test % test ( all ( shape ( ar2D ) == [ 5 , 6 ]), 'allocate_r2D' ) call allocate ( ar3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( ar3D ) == [ 10 , 9 , 8 ]), 'allocate_r3D' ) call allocate ( a1D , 100 ) call test % test ( size ( a1D ) == 100 , 'allocate_d1D' ) call allocate ( a2D , [ 5 , 6 ]) call test % test ( all ( shape ( a2D ) == [ 5 , 6 ]), 'allocate_d2D' ) call allocate ( a3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( a3D ) == [ 10 , 9 , 8 ]), 'allocate_d3D' ) call allocate ( ia1D , 100 ) call test % test ( size ( ia1D ) == 100 , 'allocate_i1D' ) call allocate ( ia2D , [ 5 , 6 ]) call test % test ( all ( shape ( ia2D ) == [ 5 , 6 ]), 'allocate_i2D' ) call allocate ( ia3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( ia3D ) == [ 10 , 9 , 8 ]), 'allocate_i3D' ) call allocate ( iad1D , 100 ) call test % test ( size ( iad1D ) == 100 , 'allocate_id1D' ) call allocate ( iad2D , [ 5 , 6 ]) call test % test ( all ( shape ( iad2D ) == [ 5 , 6 ]), 'allocate_id2D' ) call allocate ( iad3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( iad3D ) == [ 10 , 9 , 8 ]), 'allocate_id3D' ) call allocate ( z1D , 100 ) call test % test ( size ( z1D ) == 100 , 'allocate_c1D' ) call allocate ( z2D , [ 5 , 6 ]) call test % test ( all ( shape ( z2D ) == [ 5 , 6 ]), 'allocate_c2D' ) call allocate ( z3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( z3D ) == [ 10 , 9 , 8 ]), 'allocate_c3D' ) call allocate ( zz1D , 100 ) call test % test ( size ( zz1D ) == 100 , 'allocate_z1D' ) call allocate ( zz2D , [ 5 , 6 ]) call test % test ( all ( shape ( zz2D ) == [ 5 , 6 ]), 'allocate_z2D' ) call allocate ( zz3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( zz3D ) == [ 10 , 9 , 8 ]), 'allocate_z3D' ) call allocate ( la1D , 100 ) call test % test ( size ( la1D ) == 100 , 'allocate_l1D' ) call allocate ( la2D , [ 5 , 6 ]) call test % test ( all ( shape ( la2D ) == [ 5 , 6 ]), 'allocate_l2D' ) call allocate ( la3D , [ 10 , 9 , 8 ]) call test % test ( all ( shape ( la3D ) == [ 10 , 9 , 8 ]), 'allocate_l3D' ) deallocate ( ar1D , ar2D , ar3D , a1D , a2D , a3D , ia1D , ia2D , ia3D ) deallocate ( iad1D , iad2D , iad3D , z1D , z2D , z3D , zz1D , zz2D , zz3D ) deallocate ( la1D , la2D , la3D ) end subroutine end module","loc":"sourcefile/m_allocate.f90.html","tags":""},{"title":"m_compare.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_compare.f90~~EfferentGraph sourcefile~m_compare.f90 m_compare.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_compare.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_compare.f90~~AfferentGraph sourcefile~m_compare.f90 m_compare.f90 sourcefile~m_partition3way.f90 m_partition3way.f90 sourcefile~m_compare.f90->sourcefile~m_partition3way.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_compare Source Code m_compare.f90 Source Code module m_compare use variableKind implicit none interface compare module procedure :: compare_d1 end interface contains function compare_d1 ( this , that ) result ( res ) real ( r64 ) :: this real ( r64 ) :: that integer ( i32 ) :: res if ( this < that ) then res = - 1 elseif ( this > that ) then res = 1 else res = 0 end if end function end module","loc":"sourcefile/m_compare.f90.html","tags":""},{"title":"m_copy.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_copy.f90~~EfferentGraph sourcefile~m_copy.f90 m_copy.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_copy.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_allocate.f90->sourcefile~m_copy.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_copy.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_unittester.f90->sourcefile~m_copy.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_copy Source Code m_copy.f90 Source Code module m_copy !! Contains fundamental routines to copy arrays to new memory locations while maintaining both copies !! !! See [[copy]] for more information. use variableKind use m_errors , only : mErr , eMsg , msg use m_allocate , only : allocate use m_unitTester , only : tester private public :: copy_test public :: copy interface copy !! Copies an array to new memory (no pointers), The output array size will be changed to match the copy. !! !! Example usage !!```fortran !!use variableKind, only: r64 !!use m_allocate, only: allocate !!use m_copy, only: copy !! !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!real(r64),allocatable :: b1D(:), b2D(:,:), b3D(:,:,:) !!call allocate(a1D, 20) !!call allocate(a2D, [20,20]) !!call allocate(a3D, [20,20,20]) !!a1D = 1.d0 !!a2D = 2.d0 !!a3D = 3.d0 !!call copy(a1D, b1D) !!call copy(a2D, b2D) !!call copy(a3D, b3D) !!write(*,'(a)') 'a1D equals b1D: '//str(all(a1D == b1D)) !!write(*,'(a)') 'a2D equals b2D: '//str(all(a2D == b2D)) !!write(*,'(a)') 'a3D equals b3D: '//str(all(a3D == b3D)) !!call deallocate(a1D) !!call deallocate(a2D) !!call deallocate(a3D) !!call deallocate(b1D) !!call deallocate(b2D) !!call deallocate(b3D) !!``` !====================================================================! module subroutine copy_r1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_r2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_r3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_d1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_d2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_d3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_i1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_i2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_i3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_id1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_id2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_id3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_c1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_c2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_c3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_z1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_z2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_z3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_l1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_l2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:) !! Copy of this end subroutine !====================================================================! !====================================================================! module subroutine copy_l3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this end subroutine !====================================================================! end interface contains !====================================================================! module subroutine copy_r1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_r1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_r2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_r2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_r3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_r3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_d1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_d1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_d2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_d2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_d3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] real ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array real ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_d3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_i1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_i1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_i2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_i2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_i3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_i3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_id1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_id1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_id2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_id2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_id3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] integer ( i64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array integer ( i64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_id3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_c1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_c1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_c2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_c2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_c3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r32 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r32 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_c3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_z1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_z1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_z2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_z2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_z3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] complex ( r64 ), allocatable , intent ( in ) :: this (:,:,:) !! Copy this array complex ( r64 ), allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_z3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_l1D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_l1D:Array to be copied is not allocated' ) call allocate ( that , size ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_l2D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_l2D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! module subroutine copy_l3D ( this , that ) !====================================================================! !! Interfaced with [[copy]] logical , allocatable , intent ( in ) :: this (:,:,:) !! Copy this array logical , allocatable , intent ( inout ) :: that (:,:,:) !! Copy of this if (. not . allocated ( this )) call eMsg ( 'copy_l3D:Array to be copied is not allocated' ) call allocate ( that , shape ( this )) that = this end subroutine !====================================================================! !====================================================================! subroutine copy_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test real ( r32 ), allocatable :: ar1D (:), ar2D (:,:), ar3D (:,:,:) real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) integer ( i32 ), allocatable :: ia1D (:), ia2D (:,:), ia3D (:,:,:) integer ( i64 ), allocatable :: iad1D (:), iad2D (:,:), iad3D (:,:,:) complex ( r32 ), allocatable :: za1D (:), za2D (:,:), za3D (:,:,:) complex ( r64 ), allocatable :: zza1D (:), zza2D (:,:), zza3D (:,:,:) logical , allocatable :: la1D (:), la2D (:,:), la3D (:,:,:) real ( r32 ), allocatable :: br1D (:), br2D (:,:), br3D (:,:,:) real ( r64 ), allocatable :: b1D (:), b2D (:,:), b3D (:,:,:) integer ( i32 ), allocatable :: ib1D (:), ib2D (:,:), ib3D (:,:,:) integer ( i64 ), allocatable :: ibd1D (:), ibd2D (:,:), ibd3D (:,:,:) complex ( r32 ), allocatable :: zb1D (:), zb2D (:,:), zb3D (:,:,:) complex ( r64 ), allocatable :: zzb1D (:), zzb2D (:,:), zzb3D (:,:,:) logical , allocatable :: lb1D (:), lb2D (:,:), lb3D (:,:,:) call Msg ( '==========================' ) call Msg ( 'Testing : Copy' ) call Msg ( '==========================' ) call allocate ( ar1D , 10 ); ar1D = 1.0 call allocate ( ar2D , [ 5 , 6 ]); ar2D = 2.0 call allocate ( ar3D , [ 10 , 9 , 8 ]); ar3D = 3.0 call allocate ( a1D , 10 ); a1D = 1.d0 call allocate ( a2D , [ 5 , 6 ]); a2D = 2.d0 call allocate ( a3D , [ 10 , 9 , 8 ]); a3D = 3.d0 call allocate ( ia1D , 10 ); ia1D = 1 call allocate ( ia2D , [ 5 , 6 ]); ia2D = 2 call allocate ( ia3D , [ 10 , 9 , 8 ]); ia3D = 3 call allocate ( iad1D , 10 ); iad1D = 1_i64 call allocate ( iad2D , [ 5 , 6 ]); iad2D = 2_i64 call allocate ( iad3D , [ 10 , 9 , 8 ]); iad3D = 3_i64 call allocate ( za1D , 10 ); za1D = ( 1.0 , 1.0 ) call allocate ( za2D , [ 5 , 6 ]); za2D = ( 2.0 , 1.0 ) call allocate ( za3D , [ 10 , 9 , 8 ]); za3D = ( 3.0 , 1.0 ) call allocate ( zza1D , 10 ); zza1D = ( 1.d0 , 1.d0 ) call allocate ( zza2D , [ 5 , 6 ]); zza2D = ( 2.d0 , 1.d0 ) call allocate ( zza3D , [ 10 , 9 , 8 ]); zza3D = ( 3.d0 , 1.d0 ) call allocate ( la1D , 10 ); la1D = . true . call allocate ( la2D , [ 5 , 6 ]); la2D = . true . call allocate ( la3D , [ 10 , 9 , 8 ]); la3D = . true . call copy ( ar1D , br1D ) call test % test ( all ( ar1D == br1D ), 'copy_r1D' ) call copy ( ar2D , br2D ) call test % test ( all ( ar2D == br2D ), 'copy_r2D' ) call copy ( ar3D , br3D ) call test % test ( all ( ar3D == br3D ), 'copy_r3D' ) call copy ( a1D , b1D ) call test % test ( all ( a1D == b1D ), 'copy_d1D' ) call copy ( a2D , b2D ) call test % test ( all ( a2D == b2D ), 'copy_d2D' ) call copy ( a3D , b3D ) call test % test ( all ( a3D == b3D ), 'copy_d3D' ) call copy ( ia1D , ib1D ) call test % test ( all ( ia1D == ib1D ), 'copy_i1D' ) call copy ( ia2D , ib2D ) call test % test ( all ( ia2D == ib2D ), 'copy_i2D' ) call copy ( ia3D , ib3D ) call test % test ( all ( ia3D == ib3D ), 'copy_i3D' ) call copy ( iad1D , ibd1D ) call test % test ( all ( iad1D == ibd1D ), 'copy_id1D' ) call copy ( iad2D , ibd2D ) call test % test ( all ( iad2D == ibd2D ), 'copy_id2D' ) call copy ( iad3D , ibd3D ) call test % test ( all ( iad3D == ibd3D ), 'copy_id3D' ) call copy ( za1D , zb1D ) call test % test ( all ( za1D == zb1D ), 'copy_c1D' ) call copy ( za2D , zb2D ) call test % test ( all ( za2D == zb2D ), 'copy_c2D' ) call copy ( za3D , zb3D ) call test % test ( all ( za3D == zb3D ), 'copy_c3D' ) call copy ( zza1D , zzb1D ) call test % test ( all ( zza1D == zzb1D ), 'copy_z1D' ) call copy ( zza2D , zzb2D ) call test % test ( all ( zza2D == zzb2D ), 'copy_z2D' ) call copy ( zza3D , zzb3D ) call test % test ( all ( zza3D == zzb3D ), 'copy_z3D' ) call copy ( la1D , lb1D ) call test % test ( all ( la1D . eqv . lb1D ), 'copy_l1D' ) call copy ( la2D , lb2D ) call test % test ( all ( la2D . eqv . lb2D ), 'copy_l2D' ) call copy ( la3D , lb3D ) call test % test ( all ( la3D . eqv . lb3D ), 'copy_l3D' ) deallocate ( ar1D , ar2D , ar3D , a1D , a2D , a3D , ia1D , ia2D , ia3D ) deallocate ( iad1D , iad2D , iad3D , za1D , za2D , za3D , zza1D , zza2D , zza3D ) deallocate ( la1D , la2D , la3D ) deallocate ( br1D , br2D , br3D , b1D , b2D , b3D , ib1D , ib2D , ib3D ) deallocate ( ibd1D , ibd2D , ibd3D , zb1D , zb2D , zb3D , zzb1D , zzb2D , zzb3D ) deallocate ( lb1D , lb2D , lb3D ) end subroutine end module","loc":"sourcefile/m_copy.f90.html","tags":""},{"title":"m_deallocate.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_deallocate.f90~~EfferentGraph sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_deallocate.f90~~AfferentGraph sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_deallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_deallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_deallocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_deallocate.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_deallocate.f90->sourcefile~m_maths.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_deallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 var pansourcefilem_deallocatef90AfferentGraph = svgPanZoom('#sourcefilem_deallocatef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_deallocate Source Code m_deallocate.f90 Source Code module m_deallocate !! Contains fundamental interface to deallocate allocatable arrays of different types and shapes. !! !! See [[deallocate]] for more information. use variableKind , only : r32 , r64 , i32 , i64 use m_errors , only : eMsg , mErr implicit none private public deallocate interface deallocate !! Deallocate an allocatable array. !! !! Contains fundamental routines to deallocate allocatable arrays of different types and shapes. !! Does not overload the intrinsic deallocate function. !! !! This way, calling deallocate makes the user aware that checks are being made and errors are handled with a message. !! !! Checks for an error during allocation, and will stop the code if there is one. !! !! Example usage !!```fortran !!use variableKind !!use m_allocate, only: allocate !!use m_deallocate, only: deallocate !! ! Could be other intrinsic types too, integer(i32), complex(r32), etc. !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!call allocate(a1D, 20) !!call allocate(a2D, [20,20]) !!call allocate(a3D, [20,20,20]) !!write(*,'(a)') 'Shape of a3D is [20,20,20]? '//all(shape(a3D) == [20,20,20]) !!call deallocate(a1D) !!call deallocate(a2D) !!call deallocate(a3D) !!``` !====================================================================! module subroutine deallocate_r1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array end subroutine !====================================================================! end interface contains !====================================================================! module subroutine deallocate_r1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_r1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_r2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_r3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_r3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_d1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_d2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_d3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_d3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_i1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_i2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_i3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_i3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_id1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_id2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_id3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_id3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_c1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_c2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_c3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_c3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_z1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_z2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_z3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_z3D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l1D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_l1D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l2D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_l2D:this' , 2 ) endif end subroutine !====================================================================! !====================================================================! module subroutine deallocate_l3D ( this ) !! Interfaced with [[deallocate]] !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ) :: istat if ( allocated ( this )) then deallocate ( this , stat = istat ) call mErr ( istat , 'deallocate_l3D:this' , 2 ) endif end subroutine !====================================================================! end module","loc":"sourcefile/m_deallocate.f90.html","tags":""},{"title":"m_debugging.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_debugging.f90~~EfferentGraph sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_debugging.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 var pansourcefilem_debuggingf90EfferentGraph = svgPanZoom('#sourcefilem_debuggingf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_debugging Source Code m_debugging.f90 Source Code module m_debugging !! Contains routines for debugging use variableKind use m_strings logical :: verbose = . false . !! Verbose option for debugging codes integer :: debugLevel !! Integer level for debug messages interface debug !! Interface for printing primitives with a name for debug purposes !! All may be called using 'call debug(args)' module procedure :: debug_d , debug_d1D , debug_i , debug_i1D end interface private :: debug_d , debug_d1D , debug_i , debug_i1D contains !====================================================================! subroutine debug_s ( name ) !====================================================================! character ( len =* ) :: name real ( r64 ) :: var if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_D ( name , var ) !====================================================================! character ( len =* ) :: name real ( r64 ) :: var if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_D1D ( name , var ) !====================================================================! character ( len =* ) :: name real ( r64 ) :: var (:) if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_I ( name , var ) !====================================================================! character ( len =* ) :: name integer ( i32 ) :: var if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! !====================================================================! subroutine debug_I1D ( name , var ) !====================================================================! character ( len =* ) :: name integer ( i32 ) :: var (:) if ( verbose ) write ( * , '(a)' ) trim ( name ) // ': ' // str ( var ) end subroutine !====================================================================! end module","loc":"sourcefile/m_debugging.f90.html","tags":""},{"title":"m_errors.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_errors.f90~~EfferentGraph sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_errors.f90~~AfferentGraph sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_errors.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_errors.f90->sourcefile~m_select.f90 sourcefile~m_time.f90 m_time.f90 sourcefile~m_errors.f90->sourcefile~m_time.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_copy.f90 m_copy.f90 sourcefile~m_errors.f90->sourcefile~m_copy.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_errors.f90->sourcefile~m_fileio.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_indexing.f90 m_indexing.f90 sourcefile~m_errors.f90->sourcefile~m_indexing.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_errors.f90->sourcefile~m_read.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_errors.f90->sourcefile~m_write.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_errors.f90->sourcefile~m_maths.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~m_time.f90->sourcefile~progressbar_class.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_time.f90->sourcefile~stopwatch_class.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_copy.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_maths.f90 sourcefile~m_allocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_deallocate.f90->sourcefile~m_select.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_maths.f90 sourcefile~m_deallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_select.f90 sourcefile~m_unittester.f90->sourcefile~m_time.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_copy.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_fileio.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_indexing.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_maths.f90 sourcefile~m_unittester.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 var pansourcefilem_errorsf90AfferentGraph = svgPanZoom('#sourcefilem_errorsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_errors Source Code m_errors.f90 Source Code module m_errors !!Module contains error handling procedures use iso_fortran_env , only : output_unit use variableKind implicit none contains !====================================================================! subroutine mErr ( istat , aMsg , alloc , iunit ) !! Checks for successful (de)allocation.  Stops the code. !! !! Use this after an allocate/deallocate statement !! allocate(x(nz,ny,nx), stat=istat); call mErr(istat,'x',1) !! deallocate(x, stat=istat); call mErr(istat,'x',2) !====================================================================! integer ( i32 ), intent ( in ) :: istat !! results of stat=istat in (de)allocate character ( len =* ), intent ( in ) :: aMsg !! Message associated with the (de)allocate integer ( i32 ), intent ( in ) :: alloc !! 1 = allocate, 2 = deallocate integer ( i32 ), intent ( in ), optional :: iunit !! Optional file id to write the message to character ( len = :), allocatable :: tmp ! If istat is not zero, there is an error. tmp = '' if ( istat /= 0 ) then select case ( alloc ) case ( 1 ) tmp = 'Allocating Memory: ' // trim ( aMsg ) case ( 2 ) tmp = 'Deallocating Memory: ' // trim ( aMsg ) end select call eMsg ( tmp , iunit ) endif end subroutine !====================================================================! !====================================================================! subroutine msg ( aMsg , iunit ) !! Write a message !====================================================================! character ( len =* ), intent ( in ) :: aMsg !! Message to write integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the message to if ( present ( iunit )) then write ( iunit , '(a)' ) trim ( aMsg ) write ( output_unit , '(a)' ) trim ( aMsg ) else write ( output_unit , '(a)' ) trim ( aMsg ) endif end subroutine !====================================================================! !====================================================================! subroutine wMsg ( aMsg , iunit ) !! Write a Warning message !====================================================================! character ( len =* ), intent ( in ) :: aMsg !! Message to write integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the message to call Msg ( 'Warning:' // trim ( aMsg ), iunit ) end subroutine !====================================================================! !====================================================================! subroutine eMsg ( aMsg , iunit ) !! Write an Error message. Stops the code !====================================================================! character ( len =* ), intent ( in ) :: aMsg !! Message to write integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the message to call Msg ( 'Error:' // trim ( aMsg ), iunit ) if ( present ( iunit )) close ( iunit ) stop end subroutine !====================================================================! !====================================================================! subroutine fErr ( istat , fname , flg , iunit ) !! Checks for a file error !====================================================================! integer ( i32 ), intent ( in ) :: istat !! Result of iostat=istat for open,read,write,close character ( len =* ), intent ( in ) :: fname !! Name of the file integer ( i32 ), intent ( in ) :: flg !! 1=Open, 2=Read, 3=Write, 4=Close integer ( i32 ), intent ( in ), optional :: iunit !! file id to write the error to character ( len = :), allocatable :: Amsg Amsg = '' if ( istat /= 0 ) then select case ( flg ) case ( 1 ) Amsg = 'Opening file: ' // trim ( fname ) case ( 2 ) Amsg = 'Reading from: ' // trim ( fname ) case ( 3 ) Amsg = 'Writing to file: ' // trim ( fname ) case ( 4 ) Amsg = 'Closing file: ' // trim ( fname ) case default Amsg = 'Error:Invalid error flag [1-4]' end select call eMsg ( aMsg , iunit ) endif end subroutine !====================================================================! end module","loc":"sourcefile/m_errors.f90.html","tags":""},{"title":"m_fileIO.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_fileio.f90~~EfferentGraph sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_fileio.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_errors.f90->sourcefile~m_read.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_errors.f90->sourcefile~m_write.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~m_unittester.f90->sourcefile~m_fileio.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_fileio.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_read.f90 sourcefile~m_variablekind.f90->sourcefile~m_write.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 var pansourcefilem_fileiof90EfferentGraph = svgPanZoom('#sourcefilem_fileiof90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_fileIO Source Code m_fileIO.f90 Source Code module m_fileIO !! Contains functions and subroutines that inquire and operate on files !! including reading and writing multiple entries to a file use variableKind , only : i32 , r64 use m_strings , only : compact , lowercase , isString , str use m_errors , only : Emsg , Ferr , msg use m_readline , only : readline use m_writeline , only : writeline use m_unitTester , only : tester implicit none contains !====================================================================! function fileExists ( fName ) result ( yes ) !! Checks whether the file with name fName exists on disk !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name to check logical :: yes !! Exists? character ( len = len_trim ( fName )) :: this this = '' ; this = trim ( fName ) ! Inquire as to whether the file exists on disk or not inquire ( FILE = trim ( this ), EXIST = yes ) end function !====================================================================! !====================================================================! function hasExtension ( fName , extension ) result ( yes ) !====================================================================! !! Checks if a file 'fname' is of type 'extension' character ( len =* ), intent ( in ) :: fName !! File name character ( len = 3 ), intent ( in ) :: extension !! Extension to find logical :: yes !! Has this extension? ! Function Declarations integer ( i32 ) :: i , ilen ilen = len_trim ( fName ) i = scan ( fName , '.' ,. true .) ! Get the location of the dot ! If the three entries after the dot match, return yes yes = isString ( fName ( i + 1 : i + 3 ), extension ) end function !====================================================================! !====================================================================! subroutine checkIsOpen ( fName ) !! Checks whether a file is open with an error message if not !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name if (. not . isOpen ( fName )) call Ferr ( 1 , fName , 3 ) end subroutine !====================================================================! !====================================================================! function isOpen ( fname ) result ( yes ) !! Is the file open or not !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name logical :: yes !! Is the file open? inquire ( file = trim ( fname ), opened = yes ) end function !====================================================================! !====================================================================! subroutine openFile ( fname , iunit , stat , istat ) !! Open a file and perform necessary checks for failure !! stat should be 'new','old','unknown','append' !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( out ) :: iunit !! Unit number returned character ( len =* ), intent ( in ) :: stat !! Status of the file you are opening integer ( i32 ), intent ( out ) :: istat !! Error flag character ( len = len_trim ( fname )) :: this this = '' ; this = trim ( fname ) call compact ( this ) select case ( lowercase ( trim ( stat ))) case ( 'new' , 'old' , 'unknown' ) open ( newunit = iunit , file = trim ( this ), status = stat , iostat = istat ) case ( 'append' ) open ( newunit = iunit , file = trim ( this ), access = stat , status = 'old' , iostat = istat ) case default call Emsg ( 'openFile : Invalid status [new,old,unknown,append]' ) end select call Ferr ( istat , this , 1 ) end subroutine !====================================================================! !====================================================================! subroutine openBinaryFile ( fname , iunit , stat , istat ) !! Open an unformatted binary file !! stat should be 'new','old','unknown','append' !====================================================================! character ( len =* ), intent ( in ) :: fname !! File Name integer ( i32 ), intent ( out ) :: iunit !! Unit number returned character ( len =* ), intent ( in ) :: stat !! Status of the file you are opening integer ( i32 ), intent ( out ) :: istat !! Error Flag select case ( lowercase ( trim ( stat ))) case ( 'new' , 'old' , 'unknown' ) open ( newunit = iunit , file = trim ( fname ), form = 'unformatted' , status = stat , iostat = istat ) case ( 'append' ) open ( newunit = iunit , file = trim ( fname ), form = 'unformatted' , access = stat , status = 'old' , iostat = istat ) case default call Emsg ( 'openBinaryFile : Invalid status [new,old,unknown,append]' ) end select call Ferr ( istat , fname , 1 ) end subroutine !====================================================================! !====================================================================! subroutine closeFile ( fname , iunit , stat , istat ) !! Close a file and perform any necessary checks !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! Unit number returned character ( len =* ), intent ( in ) :: stat !! Status of the file you are closing integer ( i32 ), intent ( out ) :: istat !! Error Flag character ( len = len_trim ( fname )) :: this this = '' ; this = trim ( fname ) call compact ( this ) select case ( lowercase ( trim ( stat ))) case ( 'delete' ) close ( iunit , status = 'delete' , iostat = istat ) case default close ( iunit , iostat = istat ) end select call Ferr ( istat , this , 4 ) end subroutine !====================================================================! !====================================================================! subroutine deleteFile ( fname ) !! Deletes a file on disk !====================================================================! character ( len =* ), intent ( in ) :: fname !! File name to delete integer ( i32 ) :: u , istat open ( newunit = u , file = fname , status = 'old' , iostat = istat ) if ( istat == 0 ) close ( u , status = 'delete' ) end subroutine !====================================================================! !====================================================================! function getFileSize ( fName ) result ( that ) !! Get the file size in Bytes !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name integer ( i32 ) :: that !! Size of the file that = 0 if (. not . fileExists ( fName )) return inquire ( file = trim ( fName ), size = that ) end function !====================================================================! !====================================================================! function getNFileLines ( fName , nHeader ) result ( N ) !! Counts the number of lines in a file after the number of specified header lines !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name integer ( i32 ), intent ( in ), optional :: nHeader ! Skip Lines !! Skip this number of lines at the top of the file integer ( i32 ) :: N !! Number of lines in the file integer ( i32 ) :: iunit , istat call openFile ( fName , iunit , 'old' , istat ) if ( present ( nHeader )) then if ( nHeader > 0 ) call skipFileLines ( iunit , nHeader ) endif N = 0 read ( iunit , '(a)' , iostat = istat ) do while ( istat == 0 ) N = N + 1 read ( iunit , '(a)' , iostat = istat ) enddo call closeFile ( fName , iunit , '' , istat ) end function !====================================================================! !====================================================================! subroutine skipFileLines ( iunit , N ) !! Skip N lines in a file !====================================================================! integer ( i32 ), intent ( in ) :: iunit !! Unit number to skip integer ( i32 ) , intent ( in ) :: N !! Number of lines to skip integer ( i32 ) :: i do i = 1 , N read ( iunit , * ) enddo end subroutine !====================================================================! !====================================================================! function getExtension ( fName ) result ( that ) !! Get the extension of a file !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name character ( len = :), allocatable :: that !! File extension integer ( i32 ) :: i , N N = len_trim ( fName ) i = scan ( fName , '.' ) if ( i == 0 ) call Emsg ( 'getExtension : Filename ' // trim ( fName ) // ' needs an extension (.txt?)' ) that = fName ( i + 1 : N ) end function !====================================================================! !====================================================================! function trimExtension ( fName ) result ( that ) !! Trims the extension of a filename !====================================================================! character ( len =* ), intent ( in ) :: fName !! File name character ( len = :), allocatable :: that !! File name without the extension integer ( i32 ) :: i i = scan ( fName , '.' ); if ( i == 0 ) call Emsg ( 'trimExtension : Filename ' // trim ( fName ) // ' needs an extension (.txt?)' ) that = fName ( 1 : i - 1 ) end function !====================================================================! !====================================================================! subroutine fileIO_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test character ( len = 100 ) :: fname integer ( i32 ) :: istat , iTest logical :: lTest real ( r64 ) :: a , b , c real ( r64 ) :: a1D ( 5 ), b1D ( 5 ), c1D ( 5 ) fName = 'testFile.txt' a = 1.d0 ; b = 2.d0 ; c = 3.d0 a1D = [ 0.d0 , 1.d0 , 2.d0 , 3.d0 , 4.d0 ] b1D = [ 5.d0 , 6.d0 , 7.d0 , 8.d0 , 9.d0 ] c1D = [ 1 0.d0 , 1 1.d0 , 1 2.d0 , 1 3.d0 , 1 4.d0 ] call Msg ( '==========================' ) call Msg ( 'Testing : file IO' ) call Msg ( '==========================' ) call deleteFile ( fName ) ! Make sure tests can work! call test % test ( fileExists ( fName ) . eqv . . false ., 'fileExists' ) call test % test ( hasExtension ( fName , 'txt' ), 'hasExtension' ) call test % test ( getExtension ( fName ) == 'txt' , 'getExtension' ) call test % test ( trimExtension ( fName ) == 'testFile' , 'trimExtension' ) call test % test (. not . isOpen ( fName ), 'isOpen' ) call openFile ( fName , iTest , 'unknown' , istat ) call test % test ( istat == 0 , 'openFile' ) call test % test ( isOpen ( fName ), 'isOpen' ) call writeLine ( a , fName , iTest ) call writeLine ( a , b , fName , iTest ) call writeLine ( a , b , c , fName , iTest ) call writeLine ( a , b1D , fName , iTest ) call writeLine ( a1D , b1D , c1D , fName , iTest ) call closeFile ( fName , iTest , '' , istat ) call test % test ( istat == 0 , 'closeFile' ) lTest = fileExists ( fName ) call test % test ( lTest . eqv . . true ., 'fileExists' ) if ( lTest . eqv . . false .) call eMsg ( 'Make sure you change to the directory containing the executable before running the test' ) call test % test (. not . isOpen ( fName ), 'isOpen' ) iTest = getFileSize ( fName ) call test % test ( itest > 0 , 'getFileSize ' // str ( iTest ) // 'bytes' ) call openFile ( fName , iTest , 'unknown' , istat ) call skipFileLines ( iTest , 1 ) a = 0.d0 ; b = 0.d0 ; c = 0.d0 a1D = 0.d0 ; b1D = 0.d0 ; c1D = 0.d0 call readLine ( a , b , fName , iTest ) call readLine ( a , b , c , fName , iTest ) call readLine ( a , b1D , fName , iTest ) call readLine ( a1D , b1D , c1D , fName , iTest ) call test % test ( a == 1.d0 , 'writeLine/readLine' ) call test % test ( b == 2.d0 , 'writeLine/readLine' ) call test % test ( c == 3.d0 , 'writeLine/readLine' ) call test % test ( all ( a1D == [ 0.d0 , 1.d0 , 2.d0 , 3.d0 , 4.d0 ]), 'writeLine/readLine' ) call test % test ( all ( b1D == [ 5.d0 , 6.d0 , 7.d0 , 8.d0 , 9.d0 ]), 'writeLine/readLine' ) call test % test ( all ( c1D == [ 1 0.d0 , 1 1.d0 , 1 2.d0 , 1 3.d0 , 1 4.d0 ]), 'writeLine/readLine' ) call closeFile ( fName , iTest , 'delete' , istat ) call test % test ( istat == 0 , 'closeFile + Delete' ) end subroutine !====================================================================! end module","loc":"sourcefile/m_fileio.f90.html","tags":""},{"title":"m_format.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_format.f90~~EfferentGraph sourcefile~m_format.f90 m_format.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_format.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules formatting Source Code m_format.f90 Source Code module formatting !! Contains routines that handle string formatting use variableKind , only : i32 implicit none contains !  !====================================================================! !  function getNFormats(N, formt) result(FMT) !    !! Create a format string with N times strings for writing on a single line !  !====================================================================! !  integer(i32), intent(in) :: N !! Number of times to repeat the format !  character(len=*), intent(in), optional :: formt !! Optional format to repeat !  character(len=20), intent(out) :: FMT !    !! Format statement with (N('a')) !  if (present(formt)) then !    write(FMT,'(\"(\",i0,a,\")\")') N,trim(formt) !  else !    write(FMT,'(\"(\",i0,\"(a))\")') N !  endif !  end function !  !====================================================================! end module","loc":"sourcefile/m_format.f90.html","tags":""},{"title":"m_indexing.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_indexing.f90~~EfferentGraph sourcefile~m_indexing.f90 m_indexing.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_indexing.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_indexing.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_unittester.f90->sourcefile~m_indexing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_indexing Source Code m_indexing.f90 Source Code module m_indexing !! Contains routines to obtain packed and unpacked indices into arrays use variableKind use m_errors , only : msg use m_unitTester , only : tester implicit none contains !====================================================================! function ind2sub ( iG , nSub ) result ( iSub ) !! Compute the indices in each dimension from the global index !====================================================================! integer ( i32 ), intent ( in ) :: iG !! Index into a global vector integer ( i32 ), intent ( in ) :: nSub (:) !! Size in each dimension integer ( i32 ) :: iSub ( size ( nSub )) !! Indices in each dimension to return integer ( i32 ) :: i , iGtmp , iTmp integer ( i32 ) :: nDims integer ( i32 ) :: prod nDims = size ( nSub ) if ( nDims == 1 ) then iSub ( 1 ) = iG return end if prod = product ( nSub ) iGtmp = iG do i = nDims , 1 , - 1 prod = prod / nSub ( i ) iTmp = mod ( iGtmp - 1 , prod ) + 1 iSub ( i ) = ( iGtmp - iTmp ) / prod + 1 iGtmp = iTmp end do end function !====================================================================! !====================================================================! function sub2ind ( iSub , nSub ) result ( iG ) !! Given component indices, get the global vector location. !====================================================================! integer ( i32 ), intent ( in ) :: iSub (:) !! Indices in each dimension. The first entry in iL is the left most index integer ( i32 ), intent ( in ) :: nSub (:) !! Size in each dimension integer ( i32 ) :: iG !! Index in the global vector integer ( i32 ) :: i integer ( i32 ) :: nDims integer ( i32 ) :: prod nDims = size ( iSub ) prod = 1 iG = 1 do i = 1 , nDims iG = iG + ( iSub ( i ) - 1 ) * prod prod = prod * nSub ( i ) end do end function !====================================================================! !====================================================================! function integerBin ( this , n , bound ) result ( i ) !====================================================================! ! Given a real number this, that is assumed to lie between 1 and N ! Round the real number and if it is outside 1 or N, limit the output to ! either of those values ! Automatically limits the output between 1 and N, unless bound is .false. ! TODO: This is not an integer bin, its the integer Nearest. real ( r64 ) :: this integer ( i32 ) :: n logical :: bound integer ( i32 ) :: i i = idnint ( this ) if ( bound ) then if ( i < 1 ) i = 1 if ( i > n ) i = n endif end function !====================================================================! !====================================================================! subroutine indexing_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test integer ( i32 ) :: ia1D ( 3 ), ic1D ( 3 ) integer ( i32 ) :: ia call Msg ( '==========================' ) call Msg ( 'Testing : Indexing' ) call Msg ( '==========================' ) ia1D = [ 3 , 4 , 7 ] ic1D = [ 3 , 5 , 9 ] ia = - 1 ia = sub2ind ( ia1D , ic1D ) write ( * , 1 ) 'sub2ind([3,4,7],[3,5,9]) = 102' call test % test ( ia == 102 , 'sub2ind' ) ia = 99 ia1D = 0 ia1D = ind2sub ( ia , ic1D ) write ( * , 1 ) 'ind2sub(99,[3,5,9]) = [3,3,7]' call test % test ( all ( ia1D == [ 3 , 3 , 7 ]), 'ind2sub' ) 1 format ( a ) end subroutine !====================================================================! end module","loc":"sourcefile/m_indexing.f90.html","tags":""},{"title":"m_parameters.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_parameters.f90~~EfferentGraph sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_parameters.f90~~AfferentGraph sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 var pansourcefilem_parametersf90AfferentGraph = svgPanZoom('#sourcefilem_parametersf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_parameters Source Code m_parameters.f90 Source Code module m_parameters !! Module contains user defined parameters for consistent use use variableKind implicit none real ( r64 ), parameter :: inf = huge ( 0.d0 ) real ( r64 ), parameter :: NaN = transfer (( / Z '00000000' , Z '7FF80000' / ), 1.0_r64 ) real ( r64 ), parameter :: pi = dacos ( - 1.d0 ) end module","loc":"sourcefile/m_parameters.f90.html","tags":""},{"title":"m_partition.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_partition.f90~~EfferentGraph sourcefile~m_partition.f90 m_partition.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_partition.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_partition Source Code m_partition.f90 Source Code module m_partition !! Contains Hoare's style partitioning algorithm used for quicksorting and quickselect routines. !! !! See [[partition]] and [[argPartition]] for more information. use variableKind , only : r32 , r64 , i32 , i64 implicit none private public :: partition interface partition !! Partitioning used for quickSort and quickSelect routines !====================================================================! module subroutine partition_r1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! real ( r32 ), intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: left !! Left index integer ( i32 ), intent ( in ) :: right !! Right index integer ( i32 ), intent ( inout ) :: iPivot !! Pivoting index end subroutine !====================================================================! !====================================================================! module subroutine partition_d1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: left !! Left index integer ( i32 ), intent ( in ) :: right !! Right index integer ( i32 ), intent ( inout ) :: iPivot !! Pivoting index end subroutine !====================================================================! !====================================================================! module subroutine partition_i1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! integer ( i32 ), intent ( inout ) :: this (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: iPivot end subroutine !====================================================================! !====================================================================! module subroutine partition_id1D ( this , left , right , iPivot ) !! Interfaced with [[partition]] !====================================================================! integer ( i64 ), intent ( inout ) :: this (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: iPivot end subroutine !====================================================================! end interface public :: argPartition interface argPartition !! Partitioning used for argQuicksort routines !====================================================================! module subroutine argPartition_r1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! real ( r32 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! !====================================================================! module subroutine argPartition_d1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! real ( r64 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! !====================================================================! module subroutine argPartition_i1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! integer ( i32 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! !====================================================================! module subroutine argPartition_id1D ( this , idx , left , right , i ) !! Interfaced with [[argPartition]] !====================================================================! integer ( i64 ), intent ( in ) :: this (:) integer ( i32 ), intent ( inout ) :: idx (:) integer ( i32 ), intent ( in ) :: left integer ( i32 ), intent ( in ) :: right integer ( i32 ), intent ( inout ) :: i end subroutine !====================================================================! end interface contains end module","loc":"sourcefile/m_partition.f90.html","tags":""},{"title":"m_partition3way.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_partition3way.f90~~EfferentGraph sourcefile~m_partition3way.f90 m_partition3way.f90 sourcefile~m_swap.f90 m_swap.f90 sourcefile~m_swap.f90->sourcefile~m_partition3way.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_partition3way.f90 sourcefile~m_variablekind.f90->sourcefile~m_swap.f90 sourcefile~m_compare.f90 m_compare.f90 sourcefile~m_variablekind.f90->sourcefile~m_compare.f90 sourcefile~m_compare.f90->sourcefile~m_partition3way.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_partition3way Source Code m_partition3way.f90 Source Code module m_partition3way !! Contains Hoare's style partitioning algorithms used for quicksorting routines use variableKind use m_swap , only : swap use m_compare , only : compare implicit none interface partition3way !! Partitioning used for quicksort routines !    module procedure :: partition_r1D, module procedure :: partition3way_d1D !, partition_i1D, partition_id1D end interface !  interface argPartition !    !! Partitioning used for argQuicksort routines !    module procedure :: argPartition_r1D, argPartition_d1D, argPartition_i1D, argPartition_id1D !  end interface contains !  !====================================================================! !  subroutine partition_r1D(this,left,right,iPivot) !    !! Interfaced with partition() !  !====================================================================! !  real(r32), intent(inout) :: this(:) !! 1D array !  integer(i32), intent(inout) :: left !! Left index !  integer(i32), intent(inout) :: right !! Right index !  integer(i32), intent(inout) :: iPivot !! Pivoting index !  integer(i32) :: n !  integer(i32) :: lo,hi !  real(r32) :: pivot !  n=(right+left)/2 !  call swap(this(left),this(n)) !  pivot=this(left) !  lo=left;hi=right !  do while (lo <= hi) !    do while (this(hi) > pivot) !      hi=hi-1 !    end do ! !    do while (lo <= hi .and. this(lo) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(this(lo),this(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(this(left),this(hi)) !  iPivot=hi !  end subroutine !  !====================================================================! !====================================================================! subroutine partition3way_d1D ( this , left , right , iPivot1 , iPivot2 ) !! Interfaced with partition() !====================================================================! real ( r64 ), intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: left !! Left index integer ( i32 ), intent ( inout ) :: right !! Right index integer ( i32 ), intent ( inout ) :: iPivot1 !! Pivoting index integer ( i32 ), intent ( inout ) :: iPivot2 !! Pivoting index integer ( i32 ) :: i , j integer ( i32 ) :: c real ( r64 ) :: pivot iPivot1 = left iPivot2 = right pivot = this ( left ) i = left do while ( i <= iPivot2 ) c = compare ( this ( i ), pivot ) select case ( c ) case ( - 1 ) call swap ( this ( iPivot1 ), this ( i )) iPivot1 = iPivot1 + 1 i = i + 1 case ( 1 ) call swap ( this ( i ), this ( iPivot2 )) iPivot2 = iPivot2 - 1 case ( 0 ) i = i + 1 end select end do end subroutine !====================================================================! !  !====================================================================! !  subroutine partition_i1D(this,left,right,iPivot) !    !! Interfaced with partition() !  !====================================================================! !  integer(i32), intent(inout) :: this(:) !  integer(i32), intent(inout) :: left !  integer(i32), intent(inout) :: right !  integer(i32), intent(inout) :: iPivot !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i32) :: pivot !  n=(right+left)/2 !  call swap(this(left),this(n)) !  pivot=this(left) !  lo=left;hi=right !  do while (lo <= hi) !    do while (this(hi) > pivot) !      hi=hi-1 !    end do ! !    do while (lo <= hi .and. this(lo) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(this(lo),this(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(this(left),this(hi)) !  iPivot=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine partition_id1D(this,left,right,iPivot) !    !! Interfaced with partition() !  !====================================================================! !  integer(i64), intent(inout) :: this(:) !  integer(i32), intent(inout) :: left !  integer(i32), intent(inout) :: right !  integer(i32), intent(inout) :: iPivot !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i64) :: pivot !  n=(right+left)/2 !  call swap(this(left),this(n)) !  pivot=this(left) !  lo=left;hi=right !  do while (lo <= hi) !    do while (this(hi) > pivot) !      hi=hi-1 !    end do ! !    do while (lo <= hi .and. this(lo) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(this(lo),this(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(this(left),this(hi)) !  iPivot=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_r1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  real(r32) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  real(r32) :: pivot !  n=(right+left)/2 !  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. this(idx(lo)) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_d1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  real(r64) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  real(r64) :: pivot !!  n=(right+left)/2 !!  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. (this(idx(lo)) - pivot) <= 1.d-12  ) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_i1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  integer(i32) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i32) :: pivot !  n=(right+left)/2 !  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. this(idx(lo)) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! !  !====================================================================! !  subroutine argPartition_id1D(this,idx,left,right,i) !    !! Interfaced with argPartition() !  !====================================================================! !  integer(i64) :: this(:) !  integer(i32) :: idx(:) !  integer(i32) :: left,right,i !  integer(i32) :: n !  integer(i32) :: lo,hi !  integer(i64) :: pivot !  n=(right+left)/2 !  call swap(idx(left),idx(n)) !  pivot=this(idx(left)) !  lo=left+1;hi=right !  do while (lo <= hi) !    do while (this(idx(hi)) > pivot) !      hi=hi-1 !    end do !    do while (lo <= hi .and. this(idx(lo)) <= pivot) !      lo=lo+1 !    end do !    if (lo <= hi) then !      call swap(idx(lo),idx(hi)) !      lo=lo+1;hi=hi-1 !    end if !  end do !  call swap(idx(left),idx(hi)) !  i=hi !  end subroutine !  !====================================================================! end module","loc":"sourcefile/m_partition3way.f90.html","tags":""},{"title":"m_read.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_read.f90~~EfferentGraph sourcefile~m_read.f90 m_read.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_read.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_read.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 var pansourcefilem_readf90EfferentGraph = svgPanZoom('#sourcefilem_readf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_read.f90~~AfferentGraph sourcefile~m_read.f90 m_read.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_readline Source Code m_read.f90 Source Code module m_readline !! Contains core routines to read different combinations of scalars and 1D arrays from a file use variableKind use m_errors , only : Ferr use m_strings , only : isString implicit none private public :: readline interface readline !! Read in multiple items from a line !! !! Example usage !!```fortran !!use variableKind !!use m_readline !!character(len=:),allocatable :: s !!real(r64) :: a,b,c !!real(r64) :: a1D(3) !!s = '1.0 2.0 3.0' !!call readline(a, b, c, 'No File Name', 0, s) ! Read 3 scalars from a string !!write(*,*) 'a should equal 1.0 ',a == 1.d0 !!write(*,*) 'b should equal 2.0 ',b == 2.d0 !!write(*,*) 'c should equal 3.0 ',c == 3.d0 !!call readline(a1D, 'No File Name', 0, s) ! Read a length 3 1D array from a string !!write(*,*) 'a1D should equal [1.0,2.0,3.0] ',all(a == [1.d0,2.d0,3.d0]) !!``` module procedure :: readLine_a , readLine_ab , readLine_abc , readLine_abcd , readLine_abcde module procedure :: readLine_av , readLine_avbv , readLine_avbvcv , readLine_abv , readLine_abvcv , readLine_abcdev module procedure :: readLine_abcdv , readLine_abcdvev , readLine_abcv , readLine_abcvdv , readLine_abcdefv , readLine_abcdefvgv end interface contains !====================================================================! subroutine readLine_a ( a , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! real ( r64 ), intent ( out ) :: a !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a else read ( iunit , * , iostat = istat ) a endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_ab ( a , b , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b else read ( iunit , * , iostat = istat ) a , b endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abc ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a b c on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c else read ( iunit , * , iostat = istat ) a , b , c endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcd ( a , b , c , d , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a b c d on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d else read ( iunit , * , iostat = istat ) a , b , c , d endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcde ( a , b , c , d , e , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a b c on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e !! Number character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: istat if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d , e else read ( iunit , * , iostat = istat ) a , b , c , d , e endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_av ( a , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a(1),...,a(Na) on a single line real ( r64 ), intent ( out ) :: a (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Na , istat Na = size ( a ) if ( present ( buf )) then read ( buf , * , iostat = istat ) ( a ( i ), i = 1 , Na ) else read ( iunit , * , iostat = istat ) ( a ( i ), i = 1 , Na ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_avbv ( a , b , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ), intent ( out ) :: a (:) !! Vector real ( r64 ), intent ( out ) :: b (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Na , Nb , istat Na = size ( a ); Nb = size ( b ) if ( present ( buf )) then read ( buf , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ) else read ( iunit , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_avbvcv ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ), intent ( out ) :: a (:) !! Vector real ( r64 ), intent ( out ) :: b (:) !! Vector real ( r64 ), intent ( out ) :: c (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Na , Nb , Nc , istat Na = size ( a ); Nb = size ( b ); Nc = size ( c ) if ( present ( buf )) then read ( buf , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) else read ( iunit , * , iostat = istat ) ( a ( i ), i = 1 , Na ),( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abv ( a , b , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b(1),...,b(Nb) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nb , istat Nb = size ( b ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ) else read ( iunit , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abvcv ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b(1),...,b(Nb),c(1),...,c(Nc) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b (:) !! Vector real ( r64 ), intent ( out ) :: c (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nb , Nc , istat Nb = size ( b ); Nc = size ( c ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) else read ( iunit , * , iostat = istat ) a ,( b ( i ), i = 1 , Nb ),( c ( i ), i = 1 , Nc ) endif if (. not . isString ( fname , '' )) call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcv ( a , b , c , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c(1),...,c(Nc) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nc , istat Nc = size ( c ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ) else read ( iunit , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ) endif if (. not . isString ( fname , '' )) call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcvdv ( a , b , c , d , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c(1),...,c(Nc),d(1),...,d(Nd) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c (:) !! Vector real ( r64 ), intent ( out ) :: d (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nc , Nd , istat Nc = size ( c ); Nd = size ( d ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ),( d ( i ), i = 1 , Nd ) else read ( iunit , * , iostat = istat ) a , b ,( c ( i ), i = 1 , Nc ),( d ( i ), i = 1 , Nd ) endif if (. not . isString ( fname , '' )) call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdv ( a , b , c , d , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d(1),...,d(Nd) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nd , istat Nd = size ( d ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ) else read ( iunit , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdvev ( a , b , c , d , e , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d(1),...,d(Nd),e(1),...,e(Ne) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d (:) !! Vector real ( r64 ), intent ( out ) :: e (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nd , Ne , istat Nd = size ( d ); Ne = size ( e ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ),( e ( i ), i = 1 , Ne ) else read ( iunit , * , iostat = istat ) a , b , c ,( d ( i ), i = 1 , Nd ),( e ( i ), i = 1 , Ne ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdev ( a , b , c , d , e , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d,e(1),...,e(Ne) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Ne , istat Ne = size ( e ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d ,( e ( i ), i = 1 , Ne ) else read ( iunit , * , iostat = istat ) a , b , c , d ,( e ( i ), i = 1 , Ne ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdefv ( a , b , c , d , e , f , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d,e,f(1),...,f(Nf) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e !! Number real ( r64 ), intent ( out ) :: f (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nf , istat Nf = size ( f ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ) else read ( iunit , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! !====================================================================! subroutine readLine_abcdefvgv ( a , b , c , d , e , f , g , fname , iunit , buf ) !! Interfaced with readLine() !====================================================================! ! reads a,b,c,d,e,f(1),...,f(Nf),g(1),...,g(Ng) on a single line real ( r64 ), intent ( out ) :: a !! Number real ( r64 ), intent ( out ) :: b !! Number real ( r64 ), intent ( out ) :: c !! Number real ( r64 ), intent ( out ) :: d !! Number real ( r64 ), intent ( out ) :: e !! Number real ( r64 ), intent ( out ) :: f (:) !! Vector real ( r64 ), intent ( out ) :: g (:) !! Vector character ( len =* ), intent ( in ) :: fname !! File name integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len =* ), intent ( in ), optional :: buf !! Character string to read from instead of the line in the file integer ( i32 ) :: i , Nf , Ng , istat Nf = size ( f ); Ng = size ( g ) if ( present ( buf )) then read ( buf , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ),( g ( i ), i = 1 , Ng ) else read ( iunit , * , iostat = istat ) a , b , c , d , e ,( f ( i ), i = 1 , Nf ),( g ( i ), i = 1 , Ng ) endif call Ferr ( istat , fname , 2 ) end subroutine !====================================================================! end module","loc":"sourcefile/m_read.f90.html","tags":""},{"title":"m_reallocate.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_reallocate.f90~~EfferentGraph sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_reallocate.f90~~AfferentGraph sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_reallocate Source Code m_reallocate.f90 Source Code module m_reallocate !! Contains routines to re-allocate allocatable arrays !! !! Copies the original values after reallocation. If you don't need to copy the values, use 'call allocate()' instead use variableKind use m_allocate , only : allocate use m_errors , only : eMsg , mErr , msg use m_unitTester , only : tester implicit none private public :: reallocate_test public :: reallocate interface reallocate !! Reallocate an allocatable array !! !! Example usage !!```fortran !!use variableKind !!use !!use m_reallocate !!real(r64),allocatable :: a1D(:), a2D(:,:), a3D(:,:,:) !!allocate(a1D(5)) !!allocate(a2D(5,5)) !!allocate(a3D(5,5,5)) !!write(*,'(a)') 'Shape of a3D is [5,5,5]? '//all(shape(a3D) == [5,5,5]) !!call reallocate(a1D, 20) !!call reallocate(a2D, [20,20]) !!call reallocate(a3D, [20,20,20]) !!write(*,'(a)') 'Shape of a3D is [20,20,20]? '//all(shape(a3D) == [20,20,20]) !!``` module procedure :: reallocate_r1D , reallocate_r2D , reallocate_r3D module procedure :: reallocate_d1D , reallocate_d2D , reallocate_d3D module procedure :: reallocate_i1D , reallocate_i2D , reallocate_i3D module procedure :: reallocate_id1D , reallocate_id2D , reallocate_id3D module procedure :: reallocate_c1D , reallocate_c2D , reallocate_c3D module procedure :: reallocate_z1D , reallocate_z2D , reallocate_z3D module procedure :: reallocate_l1D , reallocate_l2D , reallocate_l3D end interface contains !====================================================================! subroutine reallocate_r1D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size real ( r32 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_r1D:tmp' , 1 ) tmp = 0.d0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_r2D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape real ( r32 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_r2D:tmp' , 1 ) tmp = 0.d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_r3D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape real ( r32 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_r3D:tmp' , 1 ) tmp = 0.d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_d1D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size real ( r64 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_d1D:tmp' , 1 ) tmp = 0.d0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_d2D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape real ( r64 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_d2D:tmp' , 1 ) tmp = 0.d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_d3D ( this , n ) !! Interfaced with reallocate() !====================================================================! real ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape real ( r64 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_d3D:tmp' , 1 ) tmp = 0.d0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_i1D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size integer ( i32 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_i1D:tmp' , 1 ) tmp = 0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_i2D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i32 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_i2D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_i3D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i32 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_i3D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_id1D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size integer ( i64 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_id1D:tmp' , 1 ) tmp = 0 nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_id2D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape integer ( i64 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_id2D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_id3D ( this , n ) !! Interfaced with reallocate() !====================================================================! integer ( i64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape integer ( i64 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_id3D:tmp' , 1 ) tmp = 0 nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_c1D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size complex ( r32 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_c1D:tmp' , 1 ) tmp = ( 0.d0 , 0.d0 ) nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_c2D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape complex ( r32 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_c2D:tmp' , 1 ) tmp = ( 0.d0 , 0.d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_c3D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r32 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape complex ( r32 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_c3D:tmp' , 1 ) tmp = ( 0.d0 , 0.d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_z1D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size complex ( r64 ), allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_z1D:tmp' , 1 ) tmp = ( 0.d0 , 0.d0 ) nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_z2D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape complex ( r64 ), allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_z2D:tmp' , 1 ) tmp = ( 0.d0 , 0.d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_z3D ( this , n ) !! Interfaced with reallocate() !====================================================================! complex ( r64 ), allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape complex ( r64 ), allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_z3D:tmp' , 1 ) tmp = ( 0.d0 , 0.d0 ) nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_l1D ( this , n ) !! Interfaced with reallocate() !====================================================================! logical , allocatable , intent ( inout ) :: this (:) !! 1D array integer ( i32 ), intent ( in ) :: n !! New allocation size logical , allocatable :: tmp (:) integer ( i32 ) :: istat integer ( i32 ) :: n0 , nTmp if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = size ( this ) if ( n == n0 ) return ! Don't reallocate the same size allocate ( tmp ( n ), stat = istat ); call mErr ( istat , 'reallocate_l1D:tmp' , 1 ) tmp = . false . nTmp = min ( n , n0 ) tmp ( 1 : nTmp ) = this ( 1 : nTmp ) deallocate ( this ) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_l2D ( this , n ) !! Interfaced with reallocate() !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:) !! 2D array integer ( i32 ), intent ( in ) :: n ( 2 ) !! New allocation shape logical , allocatable :: tmp (:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 2 ), nTmp ( 2 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 )), stat = istat ); call mErr ( istat , 'reallocate_l2D:tmp' , 1 ) tmp = . false . nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_l3D ( this , n ) !! Interfaced with reallocate() !====================================================================! logical , allocatable , intent ( inout ) :: this (:,:,:) !! 3D array integer ( i32 ), intent ( in ) :: n ( 3 ) !! New allocation shape logical , allocatable :: tmp (:,:,:) integer ( i32 ) :: istat integer ( i32 ) :: n0 ( 3 ), nTmp ( 3 ) if (. not . allocated ( this )) call eMsg ( 'Cannot reallocate an unallocated array' ) n0 = shape ( this ) if ( all ( n == n0 )) return ! Don't reallocate the same size allocate ( tmp ( n ( 1 ), n ( 2 ), n ( 3 )), stat = istat ); call mErr ( istat , 'reallocate_l3D:tmp' , 1 ) tmp = . false . nTmp = [ min ( n ( 1 ), n0 ( 1 )), min ( n ( 2 ), n0 ( 2 )), min ( n ( 3 ), n0 ( 3 ))] tmp ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) = this ( 1 : nTmp ( 1 ), 1 : nTmp ( 2 ), 1 : nTmp ( 3 )) call move_alloc ( from = tmp , to = this ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test real ( r32 ), allocatable :: ar1D (:), ar2D (:,:), ar3D (:,:,:) real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) integer ( i32 ), allocatable :: ia1D (:), ia2D (:,:), ia3D (:,:,:) integer ( i64 ), allocatable :: iad1D (:), iad2D (:,:), iad3D (:,:,:) complex ( r32 ), allocatable :: z1D (:), z2D (:,:), z3D (:,:,:) complex ( r64 ), allocatable :: zz1D (:), zz2D (:,:), zz3D (:,:,:) logical , allocatable :: la1D (:), la2D (:,:), la3D (:,:,:) call Msg ( '==========================' ) call Msg ( 'Testing : Reallocate' ) call Msg ( '==========================' ) call allocate ( ar1D , 10 ) ar1D = 1.0 call reallocate ( ar1D , 50 ) call test % test ( size ( ar1D ) == 50 . and . all ( ar1D ( 1 : 10 ) == 1.0 ) . and . all ( ar1D ( 11 : 50 ) == 0.0 ), 'reallocate_r1D' ) call allocate ( ar2D ,[ 10 , 10 ]) ar2D = 2.0 call reallocate ( ar2D ,[ 5 , 7 ]) call test % test ( all ( shape ( ar2D ) == [ 5 , 7 ]) . and . all ( ar2D == 2.0 ), 'reallocate_r2D' ) call allocate ( ar3D ,[ 10 , 10 , 10 ]) ar3D = 3.0 call reallocate ( ar3D ,[ 2 , 20 , 3 ]) call test % test ( all ( shape ( ar3D ) == [ 2 , 20 , 3 ]) . and . all ( ar3D (:, 1 : 10 ,:) == 3.0 ) . and . all ( ar3D (:, 11 : 20 ,:) == 0.0 ), 'reallocate_r3D' ) call allocate ( a1D , 100 ) a1D = 1.d0 call reallocate ( a1D , 50 ) call test % test ( size ( a1D ) == 50 . and . all ( a1D == 1.d0 ), 'reallocate_d1D' ) call allocate ( a2D ,[ 10 , 10 ]) a2D = 2.d0 call reallocate ( a2D ,[ 20 , 20 ]) call test % test ( all ( shape ( a2D ) == [ 20 , 20 ]) . and . all ( a2D ( 1 : 10 , 1 : 10 ) == 2.d0 ) . and . all ( a2D ( 11 : 20 , 11 : 20 ) == 0.d0 ), 'reallocate_d2D' ) call allocate ( a3D ,[ 10 , 10 , 10 ]) a3D = 3.d0 call reallocate ( a3D ,[ 20 , 20 , 20 ]) call test % test ( all ( shape ( a3D ) == [ 20 , 20 , 20 ]) . and . all ( a3D ( 1 : 10 , 1 : 10 , 1 : 10 ) == 3.d0 ) . and . all ( a3D ( 11 : 20 , 11 : 20 , 11 : 20 ) == 0.d0 ), 'reallocate_d3D' ) call allocate ( ia1D , 100 ) ia1D = 1 call reallocate ( ia1D , 50 ) call test % test ( size ( ia1D ) == 50 . and . all ( ia1d == 1 ), 'reallocate_i1D' ) call allocate ( ia2D ,[ 10 , 10 ]) ia2D = 2 call reallocate ( ia2D ,[ 20 , 20 ]) call test % test ( all ( shape ( ia2D ) == [ 20 , 20 ]) . and . all ( ia2d ( 1 : 10 , 1 : 10 ) == 2 ) . and . all ( ia2D ( 11 : 20 , 11 : 20 ) == 0 ), 'reallocate_i2D' ) call allocate ( ia3D ,[ 10 , 10 , 10 ]) ia3D = 3 call reallocate ( ia3D ,[ 20 , 20 , 20 ]) call test % test ( all ( shape ( ia3D ) == [ 20 , 20 , 20 ]) . and . all ( ia3d ( 1 : 10 , 1 : 10 , 1 : 10 ) == 3 ) . and . all ( ia3D ( 11 : 20 , 11 : 20 , 11 : 20 ) == 0 ), 'reallocate_i3D' ) call allocate ( iad1D , 100 ) iad1D = 1 call reallocate ( iad1D , 50 ) call test % test ( size ( iad1D ) == 50 . and . all ( iad1d == 1 ), 'reallocate_id1D' ) call allocate ( iad2D ,[ 10 , 10 ]) iad2d = 2 call reallocate ( iad2D ,[ 20 , 20 ]) call test % test ( all ( shape ( iad2D ) == [ 20 , 20 ]) . and . all ( iad2d ( 1 : 10 , 1 : 10 ) == 2 ) . and . all ( iad2D ( 11 : 20 , 11 : 20 ) == 0 ), 'reallocate_id2D' ) call allocate ( iad3D ,[ 10 , 10 , 10 ]) iad3d = 3 call reallocate ( iad3D ,[ 20 , 20 , 20 ]) call test % test ( all ( shape ( iad3D ) == [ 20 , 20 , 20 ]) . and . all ( iad3d ( 1 : 10 , 1 : 10 , 1 : 10 ) == 3 ) . and . all ( iad3D ( 11 : 20 , 11 : 20 , 11 : 20 ) == 0 ), 'reallocate_id3D' ) call allocate ( z1D , 100 ) z1D = ( 1.d0 , 0.d0 ) call reallocate ( z1D , 50 ) call test % test ( size ( z1D ) == 50 . and . all ( z1D == ( 1.d0 , 0.d0 )), 'reallocate_c1D' ) call allocate ( z2D ,[ 10 , 10 ]) z2D = ( 2.d0 , 0.d0 ) call reallocate ( z2D ,[ 20 , 20 ]) call test % test ( all ( shape ( z2D ) == [ 20 , 20 ]) . and . all ( z2D ( 1 : 10 , 1 : 10 ) == ( 2.d0 , 0.d0 )) . and . all ( z2D ( 11 : 20 , 11 : 20 ) == ( 0.d0 , 0.d0 )), 'reallocate_c2D' ) call allocate ( z3D ,[ 10 , 10 , 10 ]) z3D = ( 3.d0 , 0.d0 ) call reallocate ( z3D ,[ 20 , 20 , 20 ]) call test % test ( all ( shape ( z3D ) == [ 20 , 20 , 20 ]) . and . all ( z3D ( 1 : 10 , 1 : 10 , 1 : 10 ) == ( 3.d0 , 0.d0 )) . and . all ( z3D ( 11 : 20 , 11 : 20 , 11 : 20 ) == ( 0.d0 , 0.d0 )), 'reallocate_c3D' ) call allocate ( zz1D , 100 ) zz1D = ( 1.d0 , 0.d0 ) call reallocate ( zz1D , 50 ) call test % test ( size ( zz1D ) == 50 . and . all ( zz1D == ( 1.d0 , 0.d0 )), 'reallocate_z1D' ) call allocate ( zz2D ,[ 10 , 10 ]) zz2D = ( 2.d0 , 0.d0 ) call reallocate ( zz2D ,[ 20 , 20 ]) call test % test ( all ( shape ( zz2D ) == [ 20 , 20 ]) . and . all ( zz2D ( 1 : 10 , 1 : 10 ) == ( 2.d0 , 0.d0 )) . and . all ( zz2D ( 11 : 20 , 11 : 20 ) == ( 0.d0 , 0.d0 )), 'reallocate_z2D' ) call allocate ( zz3D ,[ 10 , 10 , 10 ]) zz3D = ( 3.d0 , 0.d0 ) call reallocate ( zz3D ,[ 20 , 20 , 20 ]) call test % test ( all ( shape ( zz3D ) == [ 20 , 20 , 20 ]) . and . all ( zz3D ( 1 : 10 , 1 : 10 , 1 : 10 ) == ( 3.d0 , 0.d0 )) . and . all ( zz3D ( 11 : 20 , 11 : 20 , 11 : 20 ) == ( 0.d0 , 0.d0 )), 'reallocate_z3D' ) call allocate ( la1D , 100 ) la1D = . true . call reallocate ( la1D , 50 ) call test % test ( size ( la1D ) == 50 . and . all ( la1D . eqv . . true .), 'reallocate_l1D' ) call allocate ( la2D ,[ 10 , 10 ]) la2D = . true . call reallocate ( la2D ,[ 20 , 20 ]) call test % test ( all ( shape ( la2D ) == [ 20 , 20 ]) . and . all ( la2D ( 1 : 10 , 1 : 10 ) . eqv . . true .) . and . all ( la2D ( 11 : 20 , 11 : 20 ) . eqv . . false .), 'reallocate_l2D' ) call allocate ( la3D ,[ 10 , 10 , 10 ]) la3D = . true . call reallocate ( la3D ,[ 20 , 20 , 20 ]) call test % test ( all ( shape ( la3D ) == [ 20 , 20 , 20 ]) . and . all ( la3D ( 1 : 10 , 1 : 10 , 1 : 10 ) . eqv . . true .) . and . all ( la3D ( 11 : 20 , 11 : 20 , 11 : 20 ) . eqv . . false .), 'reallocate_l3D' ) deallocate ( ar1D , ar2D , ar3D , a1D , a2D , a3D , ia1D , ia2D , ia3D ) deallocate ( iad1D , iad2D , iad3D , z1D , z2D , z3D , zz1D , zz2D , zz3D ) deallocate ( la1D , la2D , la3D ) end subroutine !====================================================================! end module","loc":"sourcefile/m_reallocate.f90.html","tags":""},{"title":"m_strings.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_strings.f90~~EfferentGraph sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_strings.f90~~AfferentGraph sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 var pansourcefilem_stringsf90AfferentGraph = svgPanZoom('#sourcefilem_stringsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_strings Source Code m_strings.f90 Source Code module m_strings !! Module provides string handling capabilities use iso_fortran_env , only : output_unit use variableKind use m_allocate , only : allocate use m_deallocate , only : deallocate use m_errors , only : wMsg , eMsg , Ferr , mErr , msg use m_parameters , only : NaN , inf use m_unitTester , only : tester implicit none private public :: strings_test public :: appendString public :: compact public :: countEntries public :: hasNentries public :: iachar1D public :: isString public :: lowercase public :: prependString public :: read1Dble public :: read1Integer public :: removeComments public :: readline public :: replacedelim public :: str public :: uppercase public :: printOptions interface str !! Interface to print a string representation of a number !! The output format options can be set using the printOptions class !! !! Example usage !!```fortran !!use variableKind !!use m_strings !!real(r64) :: arr(20) !!integer(i32) :: i !!integer(i32) :: j(5) !!arr = [(dble(i), i = 1,20)] !!i = 12 !!j = [0, 1, 2, 3, 4] !!write(*,'(a)') str(i)//str(j) !!write(*,'(a)') str(j)//str(arr) !!write(*,'(a)') str(arr) !!printOptions%threshold = 0 !!write(*,'(a)') str(arr) !!``` module procedure :: str_r1 , str_r1D module procedure :: str_d1 , str_d1D , str_d2D module procedure :: str_i1 , str_i1D , str_id1 module procedure :: str_id1D module procedure :: str_s1 , str_s1D module procedure :: str_1L end interface interface compactReal !! Returns a compact representation of a real number !! By default, truncates to 3 decimal places unless printOptions%precision is changed module procedure :: compactReal_d1 !,compactReal_d1D end interface type , public :: c_printOptions !! Print options similar to numpy's print_options integer ( i32 ) :: precision = 3 !! Force this precision on the written number integer ( i32 ) :: threshold = 10 !! Omit the middle entries if the size is greater than threshold integer ( i32 ) :: edgeitems = 3 !! Only write the first and last threshold elements from rows and/or columns character ( len = 32 ) :: nanstr = 'nan' !! Print NAN as this character ( len = 32 ) :: infstr = 'inf' !! Print infinity as this end type type ( c_printOptions ) :: printOptions contains !====================================================================! subroutine ensure1Integer ( N , fname , vName , iUnit ) !! Forces the next line, read in from file contains a single integer !! Useful for ascii data files with a size specified in a header !====================================================================! integer ( i32 ), intent ( out ) :: N !! Number character ( len =* ), intent ( in ) :: fname !! File name character ( len =* ), intent ( in ) :: vName !! Integer variable name for warning message integer ( i32 ), intent ( in ) :: iunit !! File id number to read from character ( len = cLen ) :: buf integer ( i32 ) :: istat ! Removes multiple spaces and tabs from the line ! Adjusts the string to the left call readline ( iunit , buf , istat ) call Ferr ( istat , fname , 2 ) call read1Integer ( buf , N , istat ) if ( istat /= 0 ) then call eMsg ( 'Reading a single integer to variable ' // trim ( vName ) // ' Value obtained = ' // str ( N )) endif end subroutine !====================================================================! !====================================================================! subroutine read1Integer ( buf , N , istat ) !! Get a single integer from a line, returns an error code if there is more than one entry !====================================================================! character ( len =* ) :: buf !! String integer ( i32 ) :: N !! Single integer integer ( i32 ) :: istat !! istat > 0 if more than one entry is found integer ( i32 ) :: i call compact ( buf ) ! Check if any spaces exist between 2 numbers(there should only be 1 number) i = scan ( trim ( buf ), ' ' ,. true .) read ( buf , * , iostat = istat ) N if ( i > 2 ) istat = 1 end subroutine !====================================================================! !====================================================================! subroutine read1Dble ( iunit , this , fname , vName , istat ) !!TODO: CHECK THIS !====================================================================! ! Requires the line being read to contain ONLY one real number integer ( i32 ), intent ( in ) :: iunit character ( len =* ) :: fname character ( len =* ) :: vName ! varvariable name for warning msg, if str='', no msg will write character ( len = 500 ) :: buf integer ( i32 ) :: i , istat real ( r64 ) :: this call readline ( iunit , buf , istat ) call Ferr ( istat , fname , 2 ) call compact ( buf ) !Need to do this to ensure that spaces after the number !Are not considered as multiple spaces, and to remove control !characters and tabs. ! Check if any spaces exist between 2 numbers(there should only be 1) i = scan ( trim ( buf ), ' ' ,. true .) read ( buf , * , iostat = istat ) this if ( istat /= 0 ) then if ( len_trim ( vName ) /= 0 ) then call Wmsg ( str ( fname ) // vName ) write ( output_unit , '(a)' ) trim ( vName ) // ': ' , this endif endif end subroutine !====================================================================! !  !====================================================================! !  subroutine parse(str,delims,args,nargs) !  !====================================================================! !  ! Parses the string 'str' into arguments args(1), ..., args(nargs) based on !  ! the delimiters contained in the string 'delims'. Preceding a delimiter in !  ! 'str' by a backslash ( makes this particular instance not a delimiter. !  ! The integer output variable nargs contains the number of arguments found. ! !  character(len=*) :: str,delims !  character(len=len_trim(str)) :: strsav !  character(len=*),dimension(:) :: args !  integer(i32) :: i !  integer(i32) :: k !  integer(i32) :: lenstr !  integer(i32) :: na,nargs !  strsav=str !  call compact(str) !  na=size(args) !  do i=1,na !    args(i)=' ' !  end do !  nargs=0 !  lenstr=len_trim(str) !  if(lenstr==0) return !  k=0 ! !  do !    if(len_trim(str) == 0) exit !    nargs=nargs+1 !    call split(str,delims,args(nargs)) !    call removebksl(args(nargs)) !  end do !  str=strsav ! !  end subroutine parse ! !  !********************************************************************** !====================================================================! function hasNentries ( this , N ) result ( yes ) !! Check that a string has N entries !====================================================================! character ( len =* ) :: this integer ( i32 ) :: N logical :: yes yes = ( countEntries ( this ) == N ) end function !====================================================================! !====================================================================! function countEntries ( this ) result ( N ) !! Count the number of entries in a string !====================================================================! character ( len =* ) :: this integer ( i32 ) :: N integer ( i32 ) :: i , ich , lenstr character ( len = 1 ) :: c call compact ( this ) ! Ensure only single spaces between items lenstr = len_trim ( this ) c = this ( 1 : 1 ) ich = iachar ( c ) if ( ich >= 33 ) N = 1 do i = 2 , lenstr c = this ( i : i ) ich = iachar ( c ) if ( ich == 32 ) N = N + 1 enddo end function !====================================================================! !====================================================================! subroutine compact ( this ) !! Replace tabs and spaces with a single space !! str must be a variable and not an explicit 'string'. Otherwise adjustl will fail. !====================================================================! character ( len =* ) :: this character ( len = 1 ) :: s character ( len = len_trim ( this )) :: tmp integer ( i32 ) :: i , iL , iRes integer ( i32 ) :: N logical :: oneSpace N = len_trim ( this ) oneSpace = . true . iRes = 1 tmp = '' do i = 1 , N s = this ( i : i ) iL = iachar ( s ) select case ( iL ) case ( 9 , 32 ) ! If tab or space, skip entries while they are tabs or spaces if ( oneSpace ) then tmp ( iRes : iRes ) = ' ' oneSpace = . false . iRes = iRes + 1 endif case ( 33 :) tmp ( iRes : iRes ) = s oneSpace = . true . iRes = iRes + 1 end select enddo this = tmp end subroutine !====================================================================! !====================================================================! function isNumeric ( this ) result ( yes ) !! Determine if the item in a string is numeric !====================================================================! character ( len =* ), intent ( in ) :: this logical :: yes real ( r64 ) :: tmp integer ( i32 ) :: istat read ( this , * , iostat = istat ) tmp yes = ( istat == 0 ) end function !====================================================================! !====================================================================! function compactReal_d1 ( this ) result ( res ) !! Returns a compact representation of a real number !! By default, truncates to 3 decimal places unless dp is provided !====================================================================! real ( r64 ), intent ( in ) :: this !! Double precision number character ( len = :), allocatable :: res !! String character ( len = 1024 ) :: s character ( len = 9 ) :: ctmp real ( r64 ) :: tmp integer ( i32 ) :: p integer ( i32 ) :: myP character ( len = 12 ) :: FMT ! Check for an NaN if ( this /= this ) then res = printOptions % nanstr return end if if ( this > inf ) then res = printOptions % infstr return end if myP = printOptions % precision tmp = dabs ( this ) select case ( tmp < 1.d0 ) case (. true .) write ( FMT , '(\"(es\",i0,\".\",i0,\")\")' ) 7 + myP , myP write ( s , FMT ) this case (. false .) p = floor ( dlog10 ( tmp )) if ( p > printOptions % precision ) then write ( FMT , '(\"(es\",i0,\".\",i0,\")\")' ) p + 7 + myP , myP write ( s , FMT ) this else if ( this == 0.d0 ) then s = '0.' else write ( FMT , '(\"(f0.\",i0,\")\")' ) myP write ( s , FMT ) this p = len_trim ( s ) if ( all ( iachar1D ( s ( p - myP + 1 : p )) == 48 )) then ctmp = s ( 1 : p - myP ) s = '' s = ctmp endif endif endif end select write ( cTmp , 1 ) 46 , 48 , 48 , 48 , 69 , 43 , 48 , 48 1 format ( 8 ( a1 )) if ( verify ( s , cTmp ) == 0 ) then ! Checks that zero isnt being written as 0.000e+00, and replaces with just 0 s = '0.' endif s = adjustl ( s ) res = trim ( s ) end function !====================================================================! !  !====================================================================! !  subroutine compactReal_d1D(this,res) !    !! Use CompactReal on an r64 vector !  !====================================================================! !  real(r64) :: this(:) !    !! 1D vector of numbers !  character(len=*) :: res(:) !    !! 1D vector of strings !  integer(i32) :: i,N !  N=size(this) !  do i=1,N !    call compactReal(this(i),res(i)) !  enddo !  end subroutine !  !====================================================================! !====================================================================! function str_r1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r32 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ res = compactReal ( dble ( this )) // deli end function !====================================================================! !====================================================================! function str_r1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r32 ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_d2D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r64 ), intent ( in ) :: this (:,:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this , 1 ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str_d1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo else do i = 1 , printOptions % edgeitems res = res // str_d1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) end do res = res // '...' // new_line ( 'a' ) do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str_d1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo endif res = res // str_d1D ( this ( N ,:), delim_ ) end function !====================================================================! !====================================================================! function str_d1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r64 ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_d1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! real ( r64 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ res = compactReal ( this ) // deli end function !====================================================================! !====================================================================! function str_i1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i32 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = cLen ) :: tmp character ( len = :), allocatable :: res character ( len = :), allocatable :: deli write ( tmp , '(i0)' ) this deli = ' ' if ( present ( delim_ )) deli = delim_ res = trim ( tmp ) // deli end function !====================================================================! !====================================================================! function str_id1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i64 ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = cLen ) :: tmp character ( len = :), allocatable :: res character ( len = :), allocatable :: deli write ( tmp , '(i0)' ) this deli = ' ' if ( present ( delim_ )) deli = delim_ res = trim ( tmp ) // deli end function !====================================================================! !====================================================================! function str_i2D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i32 ), intent ( in ) :: this (:,:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this , 1 ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str_i1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo else do i = 1 , printOptions % edgeitems res = res // str_i1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) end do res = res // '...' // new_line ( 'a' ) do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str_i1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo endif res = res // str_i1D ( this ( N ,:), delim_ ) end function !====================================================================! !====================================================================! function str_i1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i32 ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_id2D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i64 ), intent ( in ) :: this (:,:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this , 1 ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str_id1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo else do i = 1 , printOptions % edgeitems res = res // str_id1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) end do res = res // '...' // new_line ( 'a' ) do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str_id1D ( this ( i ,:), delim_ ) // new_line ( 'a' ) enddo endif res = res // str_id1D ( this ( N ,:), delim_ ) end function !====================================================================! !====================================================================! function str_id1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! integer ( i64 ), intent ( in ) :: this (:) !! 1D array character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli !! String integer ( i32 ) :: i , N N = size ( this ) res = '' if ( N < printOptions % threshold . or . printOptions % threshold == 0 ) then do i = 1 , N - 1 res = res // str ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) else do i = 1 , printOptions % edgeitems res = res // str ( this ( i ), delim_ ) end do deli = ' ' if ( present ( delim_ )) deli = delim_ res = res // '...' // deli do i = N - printOptions % edgeitems + 1 , N - 1 res = res // str ( this ( i ), delim_ ) end do res = res // str ( this ( N )) end if end function !====================================================================! !====================================================================! function str_s1 ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! character ( len =* ), intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ res = trim ( this ) // deli end function !====================================================================! !====================================================================! function str_s1D ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! character ( len =* ), intent ( in ) :: this (:) character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res integer ( i32 ) :: i , N N = size ( this ) res = '' do i = 1 , N - 1 res = res // str_s1 ( this ( i ), delim_ ) enddo res = res // str ( this ( N )) end function !====================================================================! !====================================================================! function str_1L ( this , delim_ ) result ( res ) !! Interfaced with str() !====================================================================! logical , intent ( in ) :: this character ( len =* ), optional , intent ( in ) :: delim_ character ( len = :), allocatable :: res character ( len = :), allocatable :: deli deli = ' ' if ( present ( delim_ )) deli = delim_ if ( this ) then res = 'True' // deli else res = 'False' // deli endif end function !====================================================================! !====================================================================! function lowerCase ( str ) result ( res ) !! Convert a string to lowercase !====================================================================! character ( len =* ) :: str character ( len = len_trim ( str )) :: res character ( len = 1 ) :: s integer ( i32 ) :: i , iSft integer ( i32 ) :: N iSft = iachar ( 'A' ) - iachar ( 'a' ) N = len_trim ( str ) res = str do i = 1 , N s = str ( i : i ) select case ( s ) case ( 'A' : 'Z' ) res ( i : i ) = achar ( iachar ( s ) - iSft ) end select enddo end function lowercase !====================================================================! !====================================================================! function upperCase ( str ) result ( res ) !! Convert a string to uppercase !====================================================================! character ( len =* ) :: str character ( len = len_trim ( str )) :: res character ( len = 1 ) :: s integer ( i32 ) :: i , iSft integer ( i32 ) :: N iSft = iachar ( 'A' ) - iachar ( 'a' ) N = len_trim ( str ) res = str do i = 1 , N s = res ( i : i ) select case ( s ) case ( 'a' : 'z' ) res ( i : i ) = achar ( iachar ( s ) + iSft ) end select enddo end function upperCase !====================================================================! !====================================================================! function isString ( tmp1 , tmp2 , exact_ ) result ( yes ) !! Match two string together !====================================================================! character ( len =* ) :: tmp1 !! Compare this string character ( len =* ) :: tmp2 !! Compare this string logical , optional :: exact_ !! Optional logical, if true, the strings are not converted to lowercase before comparison logical :: yes , exact character ( len = len_trim ( tmp1 )) :: this character ( len = len_trim ( tmp2 )) :: that this = '' ; that = '' this ( 1 : len_trim ( tmp1 )) = trim ( tmp1 ) that ( 1 : len_trim ( tmp2 )) = trim ( tmp2 ) yes = . false . exact = . false . if ( present ( exact_ )) exact = exact_ if ( exact ) then if ( trim ( this ) == trim ( that )) yes = . true . else if ( lowercase ( trim ( this )) == lowercase ( trim ( that ))) yes = . true . endif end function !====================================================================! !====================================================================! subroutine readline ( iUnit , line , istat ) !! Reads a line from a file, ignoring any comments !====================================================================! integer ( i32 ) :: iUnit !! File ID number character ( len =* ) :: line !! Character string to read the line into integer ( i32 ) :: istat !! Error Status integer ( i32 ) :: ipos !  go = .true. !  do while(go) !    read(iUnit,'(a)',iostat=istat, end = 1) line !    call removeBOM(line) ! Remove the byte order mark if present !    i = index(line,'!') ! Get the location of the comment ! !  enddo do read ( iUnit , '(a)' , iostat = istat , end = 1 ) line ! read input line call compact ( line ) if ( istat /= 0 ) return call removeBOM ( line ) line = adjustl ( line ) ipos = index ( line , '!' ) if ( ipos == 1 ) cycle if ( ipos /= 0 ) line = line (: ipos - 1 ) if ( len_trim ( line ) /= 0 ) exit end do return 1 istat = 1 end subroutine readline !====================================================================! !====================================================================! elemental subroutine removeBOM ( this ) !! Removes the byte order mark from the beginning of a string !====================================================================! character ( len =* ), intent ( inout ) :: this if ( iachar ( this ( 1 : 1 )) == 239 . and . iachar ( this ( 2 : 2 )) == 187 . and . iachar ( this ( 3 : 3 )) == 191 ) this ( 1 : 3 ) = '   ' end subroutine !====================================================================! !====================================================================! elemental subroutine removeComments ( this ) !! Removes the text after the ! mark in a string !====================================================================! character ( len =* ), intent ( inout ) :: this character ( len = :), allocatable :: tmp integer ( i32 ) :: i , length length = len_trim ( this ) tmp = this ; this = '' i = index ( tmp , '!' ) this ( 1 : i - 1 ) = tmp ( 1 : i - 1 ) end subroutine !====================================================================! !====================================================================! !! Replace a substring with another in a string !====================================================================! subroutine replace ( this , sub1 , sub2 ) character ( len =* ) :: this character ( len =* ) :: sub1 character ( len =* ) :: sub2 end subroutine !====================================================================! !====================================================================! !> Replace a single character length delimiter in a string subroutine replacedelim ( this , dlim , dlimr ) !====================================================================! character ( len =* ) :: this !! Replace delimiter in this character ( len =* ) :: dlim !! Find this delimiter character ( len =* ) :: dlimr !! Replace with this delimiter integer ( i32 ) :: i , it it = len ( dlim ) if ( it /= len ( dlimr )) call Emsg ( 'replaceDelim : un-equal length replacement' ) do i = 1 , len_trim ( this ) if ( this ( i :( i - 1 ) + it ) == dlim ) this ( i :( i - 1 ) + it ) = dlimr enddo end subroutine !====================================================================! !  !====================================================================! !  subroutine removebksl(str) !  !====================================================================! !  ! Removes backslash ( characters. Double backslashes (\\ are replaced !  ! by a single backslash. !  character(len=*):: str !  character(len=1):: ch !  character(len=len_trim(str))::outstr !  integer(i32) :: i,ibsl !  integer(i32) :: k !  integer(i32) :: lenstr ! !  str=adjustl(str) !  lenstr=len_trim(str) !  outstr=' ' !  k=0 !  ibsl=0                        ! backslash initially inactive ! !  do i=1,lenstr !    ch=str(i:i) !    if(ibsl == 1) then          ! backslash active !      k=k+1 !      outstr(k:k)=ch !      ibsl=0 !      cycle !    end if !    if(ch == '\\') then          ! backslash with backslash inactive !      ibsl=1 !      cycle !    end if !    k=k+1 !    outstr(k:k)=ch              ! non-backslash with backslash inactive !  end do ! !  str=adjustl(outstr) ! !  end subroutine removebksl !  !====================================================================! !====================================================================! function appendString ( this , that , delim ) result ( res ) !! Append a string !====================================================================! character ( len =* ) :: this !! String to append to character ( len =* ) :: that !! String to append character ( len =* ), optional :: delim !! Optional delimiter to separate the append character ( len = :), allocatable :: res !! Appended String if ( present ( delim )) then res = trim ( this ) // trim ( delim ) // trim ( that ) else res = trim ( this ) // trim ( that ) endif end function !====================================================================! !====================================================================! function prependString ( this , that , delim ) result ( res ) !! Prepend a string !====================================================================! character ( len =* ) :: this !! String to prepend to character ( len =* ) :: that !! String to prepend character ( len =* ), optional :: delim !! Optional delimiter to separate the append character ( len = :), allocatable :: res !! Prepended String if ( present ( delim )) then res = trim ( that ) // trim ( delim ) // trim ( this ) else res = trim ( that ) // trim ( this ) endif end function !====================================================================! !====================================================================! function iachar1D ( this ) result ( res ) !! Use iachar on a full string !! !! Cannot overload to intrinsic iachar because of ambiguity !====================================================================! character ( len =* ), intent ( in ) :: this integer ( i32 ), allocatable :: res (:) integer ( i32 ) :: i , istat integer ( i32 ) :: N N = len_trim ( this ) allocate ( res ( N ), stat = istat ); call mErr ( istat , 'iachar:result' , 2 ) do i = 1 , N res ( i ) = iachar ( this ( i : i )) end do end function !====================================================================! !====================================================================! subroutine strings_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test character ( len = :), allocatable :: cTest real ( r64 ) :: a real ( r64 ), allocatable :: a1D (:), a2D (:,:) integer ( i32 ) :: ia , istat call Msg ( '==========================' ) call Msg ( 'Testing : Strings' ) call Msg ( '==========================' ) cTest = 'aBcDeFgH   7483027401' call test % test ( lowerCase ( cTest ) == 'abcdefgh   7483027401' , 'lowerCase' ) call test % test ( upperCase ( cTest ) == 'ABCDEFGH   7483027401' , 'upperCase' ) call test % test ( isString ( cTest , 'aBcDeFgH   7483027401' ) . eqv . . true ., 'isString' ) call test % test ( isString ( cTest , 'abcdefgh   7483027401' ,. true .) . eqv . . false ., 'isString' ) a = 1.d0 write ( * , 1 ) str ( a ) call test % test ( str ( a ) == '1. ' , 'str(r64)' ) a = 5.6d-5 write ( * , 1 ) str ( a ) call test % test ( str ( a ) == '5.600E-05 ' , 'str(r64)' ) a = 3.217986d24 printOptions % precision = 6 write ( * , 1 ) str ( a ) call test % test ( str ( a ) == '3.217986E+24 ' , 'str(r64)' ) a = 3.217986d-24 printOptions % precision = 8 write ( * , 1 ) str ( a ) call test % test ( str ( a ) == '3.21798600E-24 ' , 'str(r64)' ) a = 0.d0 printOptions % precision = 6 write ( * , 1 ) str ( a ) call test % test ( str ( a ) == '0. ' , 'str(r64)' ) a = 4.d3 printOptions % precision = 3 write ( * , 1 ) str ( a ) call test % test ( str ( a ) == '4000. ' , 'str(r64)' ) ia = 9999 write ( * , 1 ) str ( ia ) call test % test ( str ( ia ) == '9999 ' , 'str(i32)' ) call allocate ( a1D , 5 ) a1D = 0.d0 cTest = str ( a1D ) write ( * , 1 ) 'str(1D dble array)' // new_line ( 'a' ) // trim ( cTest ) call test % test ( trim ( cTest ) == '0. 0. 0. 0. 0.' , 'str(1D dble array)' ) call allocate ( a2D , [ 3 , 3 ]) a2D = 0.d0 cTest = str ( a2D ( 1 : 3 , 1 : 3 )) write ( * , 1 ) 'str(2D dble array(3x3))' // new_line ( 'a' ) // trim ( cTest ) call test % test ( trim ( cTest ) == '0. 0. 0. ' // new_line ( 'a' ) // '0. 0. 0. ' // new_line ( 'a' ) // '0. 0. 0.' , 'str(2D dble array(3x3))' ) call allocate ( a2D , [ 10 , 10 ]) a2D = 0.d0 cTest = str ( a2D ) write ( * , 1 ) 'str(2D dble array(10x10)) with reduced output' // new_line ( 'a' ) // trim ( cTest ) call test % test ( trim ( cTest ) == & '0. 0. 0. ... 0. 0. 0. ' // new_line ( 'a' ) & // '0. 0. 0. ... 0. 0. 0. ' // new_line ( 'a' ) & // '0. 0. 0. ... 0. 0. 0. ' // new_line ( 'a' ) & // '...' // new_line ( 'a' )& // '0. 0. 0. ... 0. 0. 0. ' // new_line ( 'a' ) & // '0. 0. 0. ... 0. 0. 0. ' // new_line ( 'a' ) & // '0. 0. 0. ... 0. 0. 0. ' , 'str(2D dble array(10x10))' ) call test % test ( str (. true .) == 'True ' , 'str(L)' ) call test % test ( str (. false .) == 'False ' , 'str(L)' ) cTest = 'a      b, c; ' // achar ( 9 ) // 'd. e f g ' call compact ( cTest ) call test % test ( trim ( cTest ) == 'a b, c; d. e f g' , 'compact' ) call test % test ( countEntries ( cTest ) == 7 , 'countEntries' ) call test % test ( hasNentries ( cTest , 7 ), 'hasNentries' ) cTest = prependString ( cTest , 'Stuff' , ';' ) call test % test ( trim ( cTest ) == 'Stuff;a b, c; d. e f g' , 'prependString' ) cTest = appendString ( cTest , 'Stuff' , '#' ) call test % test ( trim ( cTest ) == 'Stuff;a b, c; d. e f g#Stuff' , 'prependString' ) call replaceDelim ( cTest , ';' , ' ' ) call test % test ( trim ( cTest ) == 'Stuff a b, c  d. e f g#Stuff' , 'replaceDelim' ) cTest = 'stuff ! Here is a comment' call removeComments ( cTest ) call test % test ( trim ( cTest ) == 'stuff' , 'removeComments' ) cTest = '1 2 3 4' call read1Integer ( cTest , ia , istat ) call test % test ( ia == 1 , 'read1integer' ) call deallocate ( a1D ) call deallocate ( a2D ) 1 format ( a ) end subroutine !====================================================================! end module","loc":"sourcefile/m_strings.f90.html","tags":""},{"title":"m_swap.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_swap.f90~~EfferentGraph sourcefile~m_swap.f90 m_swap.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_swap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_swap.f90~~AfferentGraph sourcefile~m_swap.f90 m_swap.f90 sourcefile~m_partition3way.f90 m_partition3way.f90 sourcefile~m_swap.f90->sourcefile~m_partition3way.f90 sourcefile~m_medianof3.f90 m_medianOf3.f90 sourcefile~m_swap.f90->sourcefile~m_medianof3.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_swap Source Code m_swap.f90 Source Code module m_swap !! Handles a simple swapping of two elements use variableKind implicit none private public :: swap interface swap !! Swap the values of two variables !! !!Example usage !!```fortran !!use variableKind !!use m_strings, only: str !!use m_swap, only: swap !!real(r64) :: a,b !!a = 10.d0 !!b = 100.d0 !!call swap(a,b) !!write(*,'(a)') 'Values were swapped? '//str(a == 100.d0 .and. b == 10.d0) !!``` module procedure :: swap_i1 , swap_id1 , swap_r1 , swap_d1 , swap_c1 , swap_z1 , swap_l1 end interface contains !====================================================================! subroutine swap_i1 ( this , that ) !! Interfaced with swap() !====================================================================! integer ( i32 ), intent ( inout ) :: this integer ( i32 ), intent ( inout ) :: that integer ( i32 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_id1 ( this , that ) !! Interfaced with swap() !====================================================================! integer ( i64 ), intent ( inout ) :: this integer ( i64 ), intent ( inout ) :: that integer ( i64 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_r1 ( this , that ) !! Interfaced with swap() !====================================================================! real ( r32 ), intent ( inout ) :: this real ( r32 ), intent ( inout ) :: that real ( r32 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_d1 ( this , that ) !! Interfaced with swap() !====================================================================! real ( r64 ), intent ( inout ) :: this real ( r64 ), intent ( inout ) :: that real ( r64 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_c1 ( this , that ) !! Interfaced with swap() !====================================================================! complex ( r32 ) :: this complex ( r32 ) :: that complex ( r32 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_z1 ( this , that ) !! Interfaced with swap() !====================================================================! complex ( r64 ) :: this complex ( r64 ) :: that complex ( r64 ) :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! !====================================================================! subroutine swap_l1 ( this , that ) !! Interfaced with swap() !====================================================================! logical :: this logical :: that logical :: tmp tmp = this ; this = that ; that = tmp end subroutine !====================================================================! end module","loc":"sourcefile/m_swap.f90.html","tags":""},{"title":"m_unitTester.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_unittester.f90~~EfferentGraph sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_unittester.f90~~AfferentGraph sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_unittester.f90->sourcefile~m_select.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_time.f90 m_time.f90 sourcefile~m_unittester.f90->sourcefile~m_time.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_unittester.f90->sourcefile~m_fileio.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_unittester.f90->sourcefile~m_maths.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_copy.f90 m_copy.f90 sourcefile~m_unittester.f90->sourcefile~m_copy.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_indexing.f90 m_indexing.f90 sourcefile~m_unittester.f90->sourcefile~m_indexing.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_unittester.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_allocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_maths.f90 sourcefile~m_allocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_copy.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_time.f90->sourcefile~stopwatch_class.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~m_time.f90->sourcefile~progressbar_class.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 var pansourcefilem_unittesterf90AfferentGraph = svgPanZoom('#sourcefilem_unittesterf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_unitTester Source Code m_unitTester.f90 Source Code module m_unitTester use iso_fortran_env , only : output_unit use variableKind , only : i32 use m_errors , only : msg implicit none private public :: tester type tester private integer ( i32 ) :: total integer ( i32 ) :: success contains procedure , public :: test => test_tester procedure , public :: summary => summary_tester end type interface tester module procedure :: init_tester end interface contains function init_tester () result ( this ) type ( tester ) :: this this % total = 0 this % success = 0 end function subroutine test_tester ( this , l , msg ) class ( tester ) :: this logical :: l character ( len =* ) :: msg this % total = this % total + 1 if ( l ) then write ( output_unit , 1 ) msg // ' Passed!' this % success = this % success + 1 else write ( output_unit , 1 ) msg // ' Failed!' endif 1 format ( a ) end subroutine subroutine summary_tester ( this ) class ( tester ) :: this call Msg ( '==========================' ) write ( output_unit , 1 ) this % success , '/' , this % total , ' tests passed' call Msg ( '==========================' ) 1 format ( i0 , a , i0 , a ) end subroutine end module","loc":"sourcefile/m_unittester.f90.html","tags":""},{"title":"m_variableKind.f90 – Fortran Program","text":"Files Dependent On This One sourcefile~~m_variablekind.f90~~AfferentGraph sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_variablekind.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_variablekind.f90->sourcefile~m_select.f90 sourcefile~m_time.f90 m_time.f90 sourcefile~m_variablekind.f90->sourcefile~m_time.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~m_variablekind.f90->sourcefile~progressbar_class.f90 sourcefile~m_compare.f90 m_compare.f90 sourcefile~m_variablekind.f90->sourcefile~m_compare.f90 sourcefile~m_copy.f90 m_copy.f90 sourcefile~m_variablekind.f90->sourcefile~m_copy.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_variablekind.f90->sourcefile~stopwatch_class.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_debugging.f90 m_debugging.f90 sourcefile~m_variablekind.f90->sourcefile~m_debugging.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_variablekind.f90->sourcefile~m_fileio.f90 sourcefile~m_format.f90 m_format.f90 sourcefile~m_variablekind.f90->sourcefile~m_format.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_indexing.f90 m_indexing.f90 sourcefile~m_variablekind.f90->sourcefile~m_indexing.f90 sourcefile~m_read.f90 m_read.f90 sourcefile~m_variablekind.f90->sourcefile~m_read.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_write.f90 m_write.f90 sourcefile~m_variablekind.f90->sourcefile~m_write.f90 sourcefile~m_partition.f90 m_partition.f90 sourcefile~m_variablekind.f90->sourcefile~m_partition.f90 sourcefile~m_partition3way.f90 m_partition3way.f90 sourcefile~m_variablekind.f90->sourcefile~m_partition3way.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_swap.f90 m_swap.f90 sourcefile~m_variablekind.f90->sourcefile~m_swap.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_variablekind.f90->sourcefile~m_maths.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_variablekind.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_medianof3.f90 m_medianOf3.f90 sourcefile~m_variablekind.f90->sourcefile~m_medianof3.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_time.f90->sourcefile~progressbar_class.f90 sourcefile~m_time.f90->sourcefile~stopwatch_class.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_compare.f90->sourcefile~m_partition3way.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 sourcefile~m_errors.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_kdtree.f90 sourcefile~m_errors.f90->sourcefile~m_select.f90 sourcefile~m_errors.f90->sourcefile~m_time.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_errors.f90->sourcefile~m_copy.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_errors.f90->sourcefile~m_fileio.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_indexing.f90 sourcefile~m_errors.f90->sourcefile~m_read.f90 sourcefile~m_errors.f90->sourcefile~m_write.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_maths.f90 sourcefile~m_errors.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_copy.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_maths.f90 sourcefile~m_allocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_deallocate.f90->sourcefile~m_select.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_maths.f90 sourcefile~m_deallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_select.f90 sourcefile~m_unittester.f90->sourcefile~m_time.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_copy.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_fileio.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_indexing.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_maths.f90 sourcefile~m_unittester.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_strings.f90->sourcefile~m_debugging.f90 sourcefile~m_strings.f90->sourcefile~m_fileio.f90 sourcefile~m_strings.f90->sourcefile~m_read.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_read.f90->sourcefile~m_fileio.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_swap.f90->sourcefile~m_partition3way.f90 sourcefile~m_swap.f90->sourcefile~m_medianof3.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 var pansourcefilem_variablekindf90AfferentGraph = svgPanZoom('#sourcefilem_variablekindf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules variableKind Source Code m_variableKind.f90 Source Code module variableKind !! Defines variable kinds use , intrinsic :: iso_fortran_env , only : i8 => int8 , i16 => int16 , i32 => int32 , i64 => int64 use , intrinsic :: iso_fortran_env , only : r32 => real32 , r64 => real64 integer ( i32 ), parameter :: cLen = 1024 !! Default character length for temporaries end module","loc":"sourcefile/m_variablekind.f90.html","tags":""},{"title":"m_write.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_write.f90~~EfferentGraph sourcefile~m_write.f90 m_write.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_write.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_strings.f90->sourcefile~m_write.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_write.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 var pansourcefilem_writef90EfferentGraph = svgPanZoom('#sourcefilem_writef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_write.f90~~AfferentGraph sourcefile~m_write.f90 m_write.f90 sourcefile~m_fileio.f90 m_fileIO.f90 sourcefile~m_write.f90->sourcefile~m_fileio.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_writeline Source Code m_write.f90 Source Code module m_writeline !! Contains core routines to write different combinations of scalars and 1D arrays to a file use iso_fortran_env , only : output_unit use variableKind use m_errors , only : Ferr use m_strings , only : str implicit none private public :: writeline interface writeline !! Write multiple items to a line !! !! Example usage !!```fortran !!use variableKind !!use m_writeline !!use m_fileIO, only: openFile, closeFile !!character(len=:),allocatable :: fName !!real(r64) :: a,b,c !!real(r64) :: a1D(3) !!integer(i32) :: iunit, istat !!a = 1.d0 !!b = 2.d0 !!c = 3.d0 !!a1D = [1.d0, 2.d0, 3.d0] !!fName = 'writeline.txt' !!call openFile(fName, iunit, 'unknown', istat) !!call writeline(a, b, c, fName, iunit) !!call writeline(a1D, fName, iunit) !!call closeFile(fName, iunit, '', istat) !!``` module procedure :: writeLine_a , writeLine_ab , writeLine_abc , writeLine_abcd , writeLine_abcde module procedure :: writeLine_av , writeLine_avbv , writeLine_avbvcv , writeLine_abv , writeLine_abvcv , writeLine_abcdev module procedure :: writeLine_abcdevfv , writeLine_abcdv , writeLine_abcdvev , writeLine_abcv , writeLine_abcvdv module procedure :: writeLine_abcdefv , writeLine_abcdefvgv end interface contains !====================================================================! subroutine writeLine_a ( a , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a on a single line real ( r64 ) :: a character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_ab ( a , b , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b on a single line real ( r64 ) :: a , b character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abc ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b c on a single line real ( r64 ) :: a , b , c character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcd ( a , b , c , d , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b c d on a single line real ( r64 ) :: a , b , c , d character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcde ( a , b , c , d , e , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a b c on a single line real ( r64 ) :: a , b , c , d , e character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_av ( a , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a(1),...,a(Na) on a single line real ( r64 ) :: a (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_avbv ( a , b , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ) :: a (:), b (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_avbvcv ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a(1),...,a(Na),b(1),...,b(Nb) on a single line real ( r64 ) :: a (:), b (:), c (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abv ( a , b , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b(1),...,b(Nb) on a single line real ( r64 ) :: a , b (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abvcv ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b(1),...,b(Nb),c(1),...,c(Nc) on a single line real ( r64 ) :: a , b (:), c (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcv ( a , b , c , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c(1),...,c(Nc) on a single line real ( r64 ) :: a , b , c (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcvdv ( a , b , c , d , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c(1),...,c(Nc),d(1),...,d(Nd) on a single line real ( r64 ) :: a , b , c (:), d (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdv ( a , b , c , d , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d(1),...,d(Nd) on a single line real ( r64 ) :: a , b , c , d (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdvev ( a , b , c , d , e , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d(1),...,d(Nd),e(1),...,e(Ne) on a single line real ( r64 ) :: a , b , c , d (:), e (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdev ( a , b , c , d , e , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e(1),...,e(Ne) on a single line real ( r64 ) :: a , b , c , d , e (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdevfv ( a , b , c , d , e , f , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e(1),...,e(Ne) on a single line real ( r64 ) :: a , b , c , d , e (:), f (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdefv ( a , b , c , d , e , f , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e,f(1),...,f(Nf) on a single line real ( r64 ) :: a , b , c , d , e , f (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) endif end subroutine !====================================================================! !====================================================================! subroutine writeLine_abcdefvgv ( a , b , c , d , e , f , g , fname , iunit ) !! Interfaced with writeLine() !====================================================================! ! Writes a,b,c,d,e,f(1),...,f(Nf),g(1),...,g(Ng) on a single line real ( r64 ) :: a , b , c , d , e , f (:), g (:) character ( len =* ), optional :: fname integer ( i32 ), optional :: iunit integer ( i32 ) :: istat if ( present ( iunit )) then write ( iunit , '(a)' , iostat = istat ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) // str ( g ) call Ferr ( istat , fname , 3 ) else write ( output_unit , '(a)' ) str ( a ) // str ( b ) // str ( c ) // str ( d ) // str ( e ) // str ( f ) // str ( g ) endif end subroutine !====================================================================! end module","loc":"sourcefile/m_write.f90.html","tags":""},{"title":"m_dArgDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_dargdynamicarray.f90~~EfferentGraph sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_dargdynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_dargdynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_dargdynamicarray.f90~~AfferentGraph sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_dArgDynamicArray Source Code m_dArgDynamicArray.f90 Source Code module m_dArgDynamicArray !! Class that act as stacks, queues, and priority queues like [[m_dDynamicArray]] but with an added !! integer index so that 'lists' of both a key and value can be maintained. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given !! like k nearest neighbours, or k smallest. !! !! Example usage !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_dArgDynamicArray, only: dArgDynamicArray !! !!implicit none !! !!type(dArgDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = dArgDynamicArray(10) !!call da%insertAt(1, 10, 10.d0) !!call da%insertAt(1, 20, 20.d0) !!call da%prepend(30, 30.d0) !!call da%append(40, 40.d0) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%v%values(2) = 50.d0 !!call da%deallocate() !!call da2%deallocate() !! !!da = dArgDynamicArray(3, sorted=.true.) !!call da%insertSorted(1, 20.d0) !!call da%insertSorted(2, 30.d0) !!call da%insertSorted(3, 10.d0) !!ia = da%locationOf(20.d0) !!ia = da%argOf(20.d0) !!call da%insertSortedUnique(4, 10.d0) !!call da%insertSortedUnique(4, 15.d0) !!call da%deallocate() !! !!da = dArgDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(1, 20.d0) !!call da%insertSorted(2, 30.d0) !!call da%insertSorted(3, 10.d0) !!ia = da%locationOf(20.d0) !!ia = da%argOf(20.d0) !!call da%insertSortedUnique(4, 10.d0) !!call da%insertSortedUnique(4, 15.d0) !!call da%deallocate() !!end program !!``` use variableKind , only : i32 , r64 use iso_fortran_env , only : output_unit use m_errors , only : msg , eMsg use m_iDynamicArray , only : iDynamicArray use m_dDynamicArray , only : dDynamicArray use m_searching , only : intervalSearch use m_strings , only : str , printOptions use m_unitTester , only : tester implicit none private public :: dArgDynamicArray_test public :: dArgDynamicArray type :: dArgDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_dArgDynamicArray]] for more information on how to use this class. type ( iDynamicArray ) :: i !! Argument of the values. type ( dDynamicArray ) :: v !! Values. contains procedure , public :: append => append_dArgDynamicArray !! dArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: argOf => argOf_dArgDynamicArray !! dArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure , public :: deallocate => deallocate_dArgDynamicArray !! dArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_dArgDynamicArray !! dArgDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_dArgDynamicArray !! dArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_dArgDynamicArray !! dArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_dArgDynamicArray !! dArgDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_dArgDynamicArray !! dArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure , public :: locationOf => locationOf_dArgDynamicArray !! dArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_dArgDynamicArray !! dArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: print => print_dArgDynamicArray !! dArgDynamicArray%print() - Print to the screen procedure , public :: remove => remove_dArgDynamicArray !! dArgDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_dArgDynamicArray !! dArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface dArgDynamicArray procedure :: init_dArgDynamicArray_i1 , init_dArgDynamicArray_d1D end interface interface assignment ( = ) procedure :: copy_dArgDynamicArray end interface contains !====================================================================! subroutine append_dArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure dArgDynamicArray%append(). !====================================================================! class ( dArgDynamicArray ) :: this integer ( i32 ) :: i !! Index of value real ( r64 ) :: val !! Value to append call this % i % append ( i ) call this % v % append ( val ) end subroutine !====================================================================! !====================================================================! function argOf_dArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure dArgDynamicArray%locationOf(). !====================================================================! class ( dArgDynamicArray ) :: this real ( r64 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Argument of the value. integer ( i32 ) :: iSearch iSearch = this % v % locationOf ( val ) i = - 1 if ( iSearch /= - 1 ) i = this % i % values ( iSearch ) end function !====================================================================! !====================================================================! subroutine copy_dArgDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( dArgDynamicArray ), intent ( in ) :: this !! Class to copy. type ( dArgDynamicArray ), intent ( out ) :: new !! Copy of this. new % i = this % i new % v = this % v end subroutine !====================================================================! !====================================================================! subroutine deallocate_dArgDynamicArray ( this ) !! Overloaded type bound procedure dArgDynamicArray%deallocate(). !====================================================================! class ( dArgDynamicArray ) :: this call this % i % deallocate () call this % v % deallocate () end subroutine !====================================================================! !====================================================================! function init_dArgDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface [[dArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( dArgDynamicArray ) :: this this % i = iDynamicArray ( M , . false ., fixed ) this % v = dDynamicArray ( M , sorted , fixed ) end function !====================================================================! !====================================================================! function init_dArgDynamicArray_d1D ( i , values , M , sorted , fixed ) result ( this ) !! Overloaded by interface [[dArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ) :: i (:) !! Set of value indices to initialize with. real ( r64 ), intent ( in ) :: values (:) !! Set of values to initialize with. integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( dArgDynamicArray ) :: this integer ( i32 ) :: ii , iv ii = size ( i ) iv = size ( values ) if ( ii /= iv ) call eMsg ( \"dArgDynamicArray: Size of i \" // str ( ii ) // \"must equal size of values \" // str ( iv )) this % i = iDynamicArray ( i , M , . false ., fixed ) this % v = dDynamicArray ( values , M , sorted , fixed ) end function !====================================================================! !====================================================================! subroutine insertAt_dArgDynamicArray ( this , loc , i , val ) !! Overloaded type bound procedure dArgDynamicArray%insertAt(). !====================================================================! class ( dArgDynamicArray ) :: this integer ( i32 ) :: loc !! Insert index and value at this location. integer ( i32 ) :: i !! index/ real ( r64 ) :: val !! Value/ call this % i % insertAt ( loc , i ) call this % v % insertAt ( loc , val ) end subroutine !====================================================================! !====================================================================! subroutine insertSorted_dArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure dArgDynamicArray%insertSorted(). !====================================================================! class ( dArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. real ( r64 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) call this % i % insertAt ( iSearch ( 3 ), i ) call this % v % insertAt ( iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_dArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure dArgDynamicArray%insertSortedUnique(). !====================================================================! class ( dArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. real ( r64 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) if ( iSearch ( 1 ) == - 1 ) then call this % i % insertAt ( iSearch ( 3 ), i ) call this % v % insertAt ( iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_dArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure dArgDynamicArray%isEmpty() !====================================================================! class ( dArgDynamicArray ) :: this logical :: yes !! Array is empty yes = this % v % isEmpty () end function !====================================================================! !====================================================================! function isFilled_dArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure dArgDynamicArray%isFilled() !====================================================================! class ( dArgDynamicArray ) :: this logical :: yes !! Array is filled yes = this % v % isFilled () end function !====================================================================! !====================================================================! function locationOf_dArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure dArgDynamicArray%locationOf(). !====================================================================! class ( dArgDynamicArray ) :: this real ( r64 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Index of the value. i = this % v % locationOf ( val ) end function !====================================================================! !====================================================================! subroutine prepend_dArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure dArgDynamicArray%prepend(). !====================================================================! class ( dArgDynamicArray ) :: this integer ( i32 ) :: i !! Prepend indices with this index. real ( r64 ) :: val !! Prepend values with this value. call this % i % prepend ( i ) call this % v % prepend ( val ) end subroutine !====================================================================! !====================================================================! subroutine print_dArgDynamicArray ( this ) !! Overloaded type bound procedure dArgDynamicArray%print() !====================================================================! class ( dArgDynamicArray ) :: this printOptions % threshold = 0 write ( output_unit , '(a)' ) 'size:   ' // str ( this % v % N ) if ( this % v % N <= 0 ) return write ( output_unit , '(a)' ) 'indx:   ' // str ( this % i % values ( 1 : this % i % N )) write ( output_unit , '(a)' ) 'values: ' // str ( this % v % values ( 1 : this % v % N )) end subroutine !====================================================================! !====================================================================! subroutine remove_dArgDynamicArray ( this , i ) !! Overloaded type bound procedure dArgDynamicArray%remove(). !====================================================================! class ( dArgDynamicArray ) :: this integer ( i32 ) :: i !! Remove the elements at this location. call this % i % remove ( i ) call this % v % remove ( i ) end subroutine !====================================================================! !====================================================================! subroutine tighten_dArgDynamicArray ( this ) !! Overloaded type bound procedure dArgDynamicArray%tighten(). !====================================================================! class ( dArgDynamicArray ) :: this call this % i % tighten () call this % v % tighten () end subroutine !====================================================================! !====================================================================! subroutine dArgDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( dArgDynamicArray ) :: da , da2 integer ( i32 ) :: ia call Msg ( '==========================' ) call Msg ( 'Testing : dArgDynamic Arrays' ) call Msg ( '==========================' ) da = dArgDynamicArray ( 10 ) call test % test ( size ( da % v % values ) == 10 . and . size ( da % i % values ) == 10 , 'dArgDynamicArray' ) call test % test ( da % v % N == 0 . and . da % i % N == 0 , 'dArgDynamicArray' ) call da % insertAt ( 1 , 10 , 1 0.d0 ) call test % test ( da % i % values ( 1 ) == 10 . and . da % v % values ( 1 ) == 1 0.d0 , 'dArgDynamicArray%insert' ) call da % insertAt ( 1 , 20 , 2 0.d0 ) call test % test ( all ( da % i % values ( 1 : 2 ) == [ 20 , 10 ]) . and . all ( da % v % values ( 1 : 2 ) == [ 2 0.d0 , 1 0.d0 ]), 'dArgDynamicArray%insert' ) call da % prepend ( 30 , 3 0.d0 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 30 , 20 , 10 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 3 0.d0 , 2 0.d0 , 1 0.d0 ]), 'dArgDynamicArray%prepend' ) call da % append ( 40 , 4 0.d0 ) call test % test ( all ( da % i % values ( 1 : 4 ) == [ 30 , 20 , 10 , 40 ]) . and . all ( da % v % values ( 1 : 4 ) == [ 3 0.d0 , 2 0.d0 , 1 0.d0 , 4 0.d0 ]), 'dArgDynamicArray%append' ) call da % remove ( 2 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 30 , 10 , 40 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 3 0.d0 , 1 0.d0 , 4 0.d0 ]), 'dArgDynamicArray%remove' ) call da % tighten () call test % test ( size ( da % i % values ) == 3 . and . size ( da % v % values ) == 3 , 'dArgDynamicArray%tighten' ) da2 = da call test % test ( all ( da2 % i % values == da % i % values ) . and . all ( da2 % v % values == da % v % values ), 'dArgDynamicArray%copy' ) da2 % v % values ( 2 ) = 5 0.d0 call test % test ( da2 % v % values ( 2 ) /= da % v % values ( 2 ), 'dArgDynamicArray%copy' ) call da % deallocate () call test % test (. not . allocated ( da % i % values ) . and . . not . allocated ( da % v % values ), 'dArgDynamicArray%deallocate' ) call da2 % deallocate () da = dArgDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 1 , 2 0.d0 ) call da % insertSorted ( 2 , 3 0.d0 ) call da % insertSorted ( 3 , 1 0.d0 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dArgDynamicArray%insertSorted' ) ia = da % locationOf ( 2 0.d0 ) call test % test ( ia == 2 , 'dArgDynamicArray%locationOf' ) ia = da % argOf ( 2 0.d0 ) call test % test ( ia == 1 , 'dArgDynamicArray%argOf' ) call da % insertSortedUnique ( 4 , 1 0.d0 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dArgDynamicArray%insertSortedUnique' ) call da % insertSortedUnique ( 4 , 1 5.d0 ) call test % test ( all ( da % i % values ( 1 : 4 ) == [ 3 , 4 , 1 , 2 ]) . and . all ( da % v % values ( 1 : 4 ) == [ 1 0.d0 , 1 5.d0 , 2 0.d0 , 3 0.d0 ]), 'dArgDynamicArray%insertSortedUnique' ) call test % test ( size ( da % i % values ) == 6 . and . size ( da % v % values ) == 6 , 'dArgDynamicArray%insert' ) call da % deallocate () da = dArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 1 , 2 0.d0 ) call da % insertSorted ( 2 , 3 0.d0 ) call da % insertSorted ( 3 , 1 0.d0 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dArgDynamicArray%insertSorted' ) ia = da % locationOf ( 2 0.d0 ) call test % test ( ia == 2 , 'dArgDynamicArray%locationOf' ) ia = da % argOf ( 2 0.d0 ) call test % test ( ia == 1 , 'dArgDynamicArray%argOf' ) call da % insertSortedUnique ( 4 , 1 0.d0 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dArgDynamicArray%insertSortedUnique' ) call da % insertSortedUnique ( 4 , 1 5.d0 ) call test % test ( all ( da % i % values ( 1 : 3 ) == [ 3 , 4 , 1 ]) . and . all ( da % v % values ( 1 : 3 ) == [ 1 0.d0 , 1 5.d0 , 2 0.d0 ]), 'dArgDynamicArray%insertSortedUnique' ) call test % test ( size ( da % i % values ) == 3 . and . size ( da % v % values ) == 3 , 'dArgDynamicArray%insert' ) call da % deallocate () end subroutine end module","loc":"sourcefile/m_dargdynamicarray.f90.html","tags":""},{"title":"m_dDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_ddynamicarray.f90~~EfferentGraph sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_ddynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_ddynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_ddynamicarray.f90~~AfferentGraph sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_dDynamicArray Source Code m_dDynamicArray.f90 Source Code module m_dDynamicArray !! Class that act as stacks, queues, and priority queues. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given !! like k nearest neighbours, or k smallest. !! !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_dDynamicArray, only: dDynamicArray !! !!implicit none !! !!type(dDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = dDynamicArray(10) !!call da%insertAt(1, 10.d0) !!call da%insertAt(1, 20.d0) !!call da%prepend(30.d0) !!call da%append(40.d0) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%values(2) = 50.d0 !!call da%deallocate() !!call da2%deallocate() !! !!da = dDynamicArray(3, sorted=.true.) !!call da%insertSorted(20.d0) !!call da%insertSorted(30.d0) !!call da%insertSorted(10.d0) !!ia = da%locationOf(20.d0) !!call da%insertSortedUnique(10.d0) !!call da%insertSortedUnique(15.d0) !!call da%deallocate() !! !!da = dDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(20.d0) !!call da%insertSorted(30.d0) !!call da%insertSorted(10.d0) !!ia = da%locationOf(20.d0) !!call da%insertSortedUnique(10.d0) !!call da%insertSortedUnique(15.d0) !!call da%deallocate() !!end program !!``` use variableKind , only : r64 , i32 use m_allocate , only : allocate use m_searching , only : binarySearch , intervalSearch use m_deallocate , only : deallocate use m_errors , only : eMsg , msg use m_reallocate , only : reallocate use m_sort , only : sort use m_strings , only : str use m_unitTester , only : tester implicit none private public :: dDynamicArray_test public :: dDynamicArray type :: dDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_dDynamicArray]] for more information on how to use this class. integer ( i32 ) :: N !! Current size of the array real ( r64 ), allocatable :: values (:) !! Memory for values, can be larger than N logical :: sorted = . false . !! Keep track of whether the array is sorted for potential speed increases logical :: fixed = . false . !! Don't allow the memory to change after initial instantiation. contains procedure , public :: append => append_dDynamicArray !! dDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: deallocate => deallocate_dDynamicArray !! dDynamicArray%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_dDynamicArray !! dDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_dDynamicArray !! dDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_dDynamicArray !! dDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_dDynamicArray !! dDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_dDynamicArray !! dDynamicArray%isFilled() - True if the array is filled. procedure , public :: locationOf => locationOf_dDynamicArray !! dDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_dDynamicArray !! dDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: reallocate => reallocate_dDynamicArray !! dDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure , public :: remove => remove_dDynamicArray !! dDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_dDynamicArray !! dDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface dDynamicArray procedure :: init_dDynamicArray_i1 , init_dDynamicArray_d1D end interface interface assignment ( = ) procedure :: copy_dDynamicArray end interface contains !====================================================================! subroutine append_dDynamicArray ( this , val ) !! Overloaded type bound procedure dDynamicArray%append() !====================================================================! class ( dDynamicArray ) :: this real ( r64 ) :: val !! Value to append. if ( this % fixed ) call eMsg ( 'dDynamicArray%append: Cannot use append with fixed array.' ) call this % insertAt ( this % N + 1 , val ) ! Append at last location end subroutine !====================================================================! !====================================================================! subroutine copy_dDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( dDynamicArray ), intent ( in ) :: this !! Class to copy. type ( dDynamicArray ), intent ( out ) :: new !! Copy of this. call allocate ( new % values , size ( this % values )) new % N = this % N new % values = this % values new % sorted = this % sorted new % fixed = this % fixed end subroutine !====================================================================! !====================================================================! subroutine deallocate_dDynamicArray ( this ) !! Overloaded type bound procedure dDynamicArray%deallocate() !====================================================================! class ( dDynamicArray ) :: this call deallocate ( this % values ) this % N = 0 this % sorted = . false . end subroutine !====================================================================! !====================================================================! function init_dDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface dDynamicArray() !====================================================================! integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( dDynamicArray ) :: this !! Return type. integer ( i32 ) :: M_ M_ = 1 if ( present ( M )) then if ( M < 1 ) call eMsg ( 'M must be > 0' ) M_ = M endif call allocate ( this % values , M_ ) this % N = 0 this % sorted = . false . if ( present ( sorted )) this % sorted = sorted this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! function init_dDynamicArray_d1D ( values , M , sorted , fixed ) result ( this ) !! Overloaded by interface dDynamicArray() !====================================================================! real ( r64 ), intent ( in ) :: values (:) !! Set of values to initialize with. integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( dDynamicArray ) :: this !! Return type if ( present ( M )) then if ( M < size ( values )) call eMsg ( 'M must be >= size(values)' ) call allocate ( this % values , M ) else call allocate ( this % values , size ( values )) endif this % N = size ( values ) this % sorted = . false . if ( present ( sorted )) this % sorted = sorted if ( this % sorted ) then this % values ( 1 : this % N ) = values call sort ( this % values ( 1 : this % N )) else this % values ( 1 : this % N ) = values endif this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! subroutine insertAt_dDynamicArray ( this , i , val ) !! Overloaded type bound procedure dDynamicArray%insertAt() !====================================================================! class ( dDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. real ( r64 ) :: val !! Insert this value. integer :: j , N if ( i < 1 . or . i > this % N + 1 ) call Emsg ( 'dDynamicArray%insert: 1 <= i <= ' // str ( this % N + 1 )) N = size ( this % values ) if ( this % fixed ) then if ( i > N ) call Emsg ( 'dDynamicArray%insert: For fixed array, 1 <= i <= ' // str ( N )) if ( this % N < N ) this % N = this % N + 1 do j = this % N , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo else ! Expand the vector if needed if ( N < this % N + 1 ) call this % reallocate ( 2 * N ) do j = this % N + 1 , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo this % N = this % N + 1 endif this % values ( i ) = val end subroutine !====================================================================! !====================================================================! subroutine insertSorted_dDynamicArray ( this , val ) !! Overloaded type bound procedure dDynamicArray%insertSorted() !====================================================================! class ( dDynamicArray ) :: this real ( r64 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'dDynamicArray%insertSorted: Cannot use insertSorted with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) call this % insertAt ( iSearch ( 3 ), val ) this % sorted = . true . end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_dDynamicArray ( this , val ) !! Overloaded type bound procedure dDynamicArray%insertSortedUnique() !====================================================================! class ( dDynamicArray ) :: this real ( r64 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'dDynamicArray%insertSortedUnique: Cannot use insertSortedUnique with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) if ( iSearch ( 1 ) == - 1 ) then call this % insertAt ( iSearch ( 3 ), val ) this % sorted = . true . endif end subroutine !====================================================================! !====================================================================! function isEmpty_dDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure dDynamicArray%isEmpty() !====================================================================! class ( dDynamicArray ) :: this logical :: yes !! Array is empty yes = ( this % N == 0 ) end function !====================================================================! !====================================================================! function isFilled_dDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure dDynamicArray%isFilled() !====================================================================! class ( dDynamicArray ) :: this logical :: yes !! Array is filled yes = ( this % N == size ( this % values )) end function !====================================================================! !====================================================================! function locationOf_dDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure dDynamicArray%locationOf(). !====================================================================! class ( dDynamicArray ) :: this real ( r64 ) :: val !! Get the location of this value integer ( i32 ) :: i !! Location of value if (. not . this % sorted ) call eMsg ( 'dDynamicArray%locationOf: Cannot use locationOf with unsorted dynamic array' ) i = binarySearch ( this % values , val , 1 , this % N ) end function !====================================================================! !====================================================================! subroutine prepend_dDynamicArray ( this , val ) !! Overloaded type bound procedure dDynamicArray%prepend() !====================================================================! class ( dDynamicArray ) :: this real ( r64 ) :: val !! Value to prepend. if ( this % fixed ) call eMsg ( 'dDynamicArray%prepend: Cannot use prepend with fixed array.' ) call this % insertAt ( 1 , val ) ! Prepend at first location end subroutine !====================================================================! !====================================================================! subroutine reallocate_dDynamicArray ( this , M ) !! Overloaded type bound procedure dDynamicArray%reallocate(). !====================================================================! class ( dDynamicArray ) :: this integer ( i32 ) :: M !! Reallocate memory to this size. call reallocate ( this % values , M ) end subroutine !====================================================================! !====================================================================! subroutine remove_dDynamicArray ( this , i ) !! Overloaded type bound procedure dDynamicArray%remove(). !====================================================================! class ( dDynamicArray ) :: this integer ( i32 ) :: i !! Remove the value at this location. integer ( i32 ) :: j if ( i < 1 . or . i > this % N ) call Emsg ( 'dDynamic%remove: 1 <= i <= ' // str ( this % N )) do j = i , this % N - 1 this % values ( j ) = this % values ( j + 1 ) enddo this % N = this % N - 1 if (. not . this % fixed ) then if ( this % N < size ( this % values ) / 4 ) call this % reallocate ( this % N ) endif end subroutine !====================================================================! !====================================================================! subroutine tighten_dDynamicArray ( this ) !! Overloaded type bound procedure dDynamicArray%tighten(). !====================================================================! class ( dDynamicArray ) :: this if ( this % fixed ) call eMsg ( 'dDynamicArray%tighten: Cannot use tighten with fixed array.' ) call this % reallocate ( this % N ) end subroutine !====================================================================! !====================================================================! subroutine dDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( dDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = dDynamicArray ( 10 ) call test % test ( size ( da % values ) == 10 , 'dDynamicArray' ) call test % test ( da % N == 0 , 'dDynamicArray' ) call da % insertAt ( 1 , 1 0.d0 ) call test % test ( da % values ( 1 ) == 10 , 'dDynamicArray%insert' ) call da % insertAt ( 1 , 2 0.d0 ) call test % test ( all ( da % values ( 1 : 2 ) == [ 2 0.d0 , 1 0.d0 ]), 'dDynamicArray%insert' ) call da % prepend ( 3 0.d0 ) call test % test ( all ( da % values ( 1 : 3 ) == [ 3 0.d0 , 2 0.d0 , 1 0.d0 ]), 'dDynamicArray%prepend' ) call da % append ( 4 0.d0 ) call test % test ( all ( da % values ( 1 : 4 ) == [ 3 0.d0 , 2 0.d0 , 1 0.d0 , 4 0.d0 ]), 'dDynamicArray%append' ) call da % remove ( 2 ) call test % test ( all ( da % values ( 1 : 3 ) == [ 3 0.d0 , 1 0.d0 , 4 0.d0 ]), 'dDynamicArray%remove' ) call da % tighten () call test % test ( size ( da % values ) == 3 , 'dDynamicArray%tighten' ) da2 = da call test % test ( all ( da2 % values == da % values ), 'dDynamicArray%copy' ) da2 % values ( 2 ) = 5 0.d0 call test % test ( da2 % values ( 2 ) /= da % values ( 2 ), 'dDynamicArray%copy' ) call da % deallocate () call test % test (. not . allocated ( da % values ), 'dDynamicArray%deallocate' ) call da2 % deallocate () da = dDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 2 0.d0 ) call da % insertSorted ( 3 0.d0 ) call da % insertSorted ( 1 0.d0 ) call test % test ( all ( da % values == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dDynamicArray%insertSorted' ) ia = da % locationOf ( 2 0.d0 ) call test % test ( ia == 2 , 'dDynamicArray%locationOf' ) call da % insertSortedUnique ( 1 0.d0 ) call test % test ( all ( da % values == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dDynamicArray%insertSortedUnique' ) call da % insertSortedUnique ( 1 5.d0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.d0 , 1 5.d0 , 2 0.d0 , 3 0.d0 ]), 'dDynamicArray%insertSortedUnique' ) call test % test ( size ( da % values ) == 6 , 'dDynamicArray%insert' ) call da % deallocate () da = dDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 2 0.d0 ) call da % insertSorted ( 3 0.d0 ) call da % insertSorted ( 1 0.d0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dDynamicArray%insertSorted' ) ia = da % locationOf ( 2 0.d0 ) call test % test ( ia == 2 , 'dDynamicArray%locationOf' ) call da % insertSortedUnique ( 1 0.d0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.d0 , 2 0.d0 , 3 0.d0 ]), 'dDynamicArray%insertSortedUnique' ) call da % insertSortedUnique ( 1 5.d0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.d0 , 1 5.d0 , 2 0.d0 ]), 'dDynamicArray%insertSortedUnique' ) call test % test ( size ( da % values ) == 3 , 'dDynamicArray%insert' ) call da % deallocate () end subroutine end module","loc":"sourcefile/m_ddynamicarray.f90.html","tags":""},{"title":"m_iArgDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_iargdynamicarray.f90~~EfferentGraph sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_iargdynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_iargdynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_iArgDynamicArray Source Code m_iArgDynamicArray.f90 Source Code module m_iArgDynamicArray !! Class that act as stacks, queues, and priority queues like [[m_iDynamicArray]] but with an added !! integer index so that 'lists' of both a key and value can be maintained. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given !! like k nearest neighbours, or k smallest. !! !! Example usage !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_iArgDynamicArray, only: iArgDynamicArray !! !!implicit none !! !!type(iArgDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = iArgDynamicArray(10) !!call da%insertAt(1, 10, 10) !!call da%insertAt(1, 20, 20) !!call da%prepend(30, 30) !!call da%append(40, 40) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%v%values(2) = 50 !!call da%deallocate() !!call da2%deallocate() !! !!da = iArgDynamicArray(3, sorted=.true.) !!call da%insertSorted(1, 20) !!call da%insertSorted(2, 30) !!call da%insertSorted(3, 10) !!ia = da%locationOf(20) !!ia = da%argOf(20) !!call da%insertSortedUnique(4, 10) !!call da%insertSortedUnique(4, 15) !!call da%deallocate() !! !!da = iArgDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(1, 20) !!call da%insertSorted(2, 30) !!call da%insertSorted(3, 10) !!ia = da%locationOf(20) !!ia = da%argOf(20) !!call da%insertSortedUnique(4, 10) !!call da%insertSortedUnique(4, 15) !!call da%deallocate() !!end program !!``` use variableKind , only : i32 use m_errors , only : msg , eMsg use m_iDynamicArray , only : iDynamicArray , insertAt__iDynamicArray use m_searching , only : intervalSearch use m_strings , only : str use m_unitTester , only : tester implicit none private public :: iArgDynamicArray_test public :: iArgDynamicArray type :: iArgDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_iArgDynamicArray]] for more information on how to use this class. type ( iDynamicArray ) :: i !! Argument of the values. type ( iDynamicArray ) :: v !! Values. contains procedure , public :: append => append_iArgDynamicArray !! iArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: argOf => argOf_iArgDynamicArray !! iArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure , public :: deallocate => deallocate_iArgDynamicArray !! iArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_iArgDynamicArray !! iArgDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_iArgDynamicArray !! iArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_iArgDynamicArray !! iArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_iArgDynamicArray !! iArgDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_iArgDynamicArray !! iArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure , public :: locationOf => locationOf_iArgDynamicArray !! iArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_iArgDynamicArray !! iArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: remove => remove_iArgDynamicArray !! iArgDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_iArgDynamicArray !! iArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface iArgDynamicArray procedure :: init_iArgDynamicArray_i1 , init_iArgDynamicArray_i1D end interface interface assignment ( = ) procedure :: copy_iArgDynamicArray end interface contains !====================================================================! subroutine append_iArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure iArgDynamicArray%append(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: i !! Index of value integer ( i32 ) :: val !! Value to append call this % i % append ( i ) call this % v % append ( val ) end subroutine !====================================================================! !====================================================================! function argOf_iArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure iArgDynamicArray%locationOf(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Argument of the value. integer ( i32 ) :: iSearch iSearch = this % v % locationOf ( val ) i = - 1 if ( iSearch /= - 1 ) i = this % i % values ( iSearch ) end function !====================================================================! !====================================================================! subroutine copy_iArgDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( iArgDynamicArray ), intent ( in ) :: this !! Class to copy. type ( iArgDynamicArray ), intent ( out ) :: new !! Copy of this. new % i = this % i new % v = this % v end subroutine !====================================================================! !====================================================================! subroutine deallocate_iArgDynamicArray ( this ) !! Overloaded type bound procedure iArgDynamicArray%deallocate(). !====================================================================! class ( iArgDynamicArray ) :: this call this % i % deallocate () call this % v % deallocate () end subroutine !====================================================================! !====================================================================! function init_iArgDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface [[iArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ), optional :: M logical , intent ( in ), optional :: sorted logical , intent ( in ), optional :: fixed type ( iArgDynamicArray ) :: this this % i = iDynamicArray ( M , . false ., fixed ) this % v = iDynamicArray ( M , sorted , fixed ) end function !====================================================================! !====================================================================! function init_iArgDynamicArray_i1D ( i , values , M , sorted , fixed ) result ( this ) !! Overloaded by interface [[iArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ) :: i (:) integer ( i32 ), intent ( in ) :: values (:) integer ( i32 ), intent ( in ), optional :: M logical , intent ( in ), optional :: sorted logical , intent ( in ), optional :: fixed type ( iArgDynamicArray ) :: this integer ( i32 ) :: ii , iv ii = size ( i ) iv = size ( values ) if ( ii /= iv ) call eMsg ( \"iArgDynamicArray: Size of i \" // str ( ii ) // \"must equal size of values \" // str ( iv )) this % i = iDynamicArray ( i , M , . false ., fixed ) this % v = iDynamicArray ( values , M , sorted , fixed ) end function !====================================================================! !====================================================================! subroutine insertAt_iArgDynamicArray ( this , loc , i , val ) !! Overloaded type bound procedure iArgDynamicArray%insertAt(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: loc !! Insert index and value at this location. integer ( i32 ) :: i !! index. integer ( i32 ) :: val !! Value. call this % i % insertAt ( loc , i ) call this % v % insertAt ( loc , val ) end subroutine !====================================================================! !====================================================================! subroutine insertSorted_iArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure iArgDynamicArray%insertSorted(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. integer ( i32 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) call this % i % insertAt ( iSearch ( 3 ), i ) call insertAt__iDynamicArray ( this % v , iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_iArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure iArgDynamicArray%insertSortedUnique(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. integer ( i32 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) if ( iSearch ( 1 ) == - 1 ) then call this % i % insertAt ( iSearch ( 3 ), i ) call insertAt__iDynamicArray ( this % v , iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_iArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure iArgDynamicArray%isEmpty() !====================================================================! class ( iArgDynamicArray ) :: this logical :: yes !! Array is empty yes = this % v % isEmpty () end function !====================================================================! !====================================================================! function isFilled_iArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure iArgDynamicArray%isFilled() !====================================================================! class ( iArgDynamicArray ) :: this logical :: yes !! Array is filled yes = this % v % isFilled () end function !====================================================================! !====================================================================! function locationOf_iArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure iArgDynamicArray%locationOf(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Index of the value. i = this % v % locationOf ( val ) end function !====================================================================! !====================================================================! subroutine prepend_iArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure iArgDynamicArray%prepend(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: i !! Prepend indices with this index. integer ( i32 ) :: val !! Prepend values with this value. call this % i % prepend ( i ) call this % v % prepend ( val ) end subroutine !====================================================================! !====================================================================! subroutine remove_iArgDynamicArray ( this , i ) !! Overloaded type bound procedure iArgDynamicArray%remove(). !====================================================================! class ( iArgDynamicArray ) :: this integer ( i32 ) :: i !! Remove the elements at this location. call this % i % remove ( i ) call this % v % remove ( i ) end subroutine !====================================================================! !====================================================================! subroutine tighten_iArgDynamicArray ( this ) !! Overloaded type bound procedure iArgDynamicArray%tighten(). !====================================================================! class ( iArgDynamicArray ) :: this call this % i % tighten () call this % v % tighten () end subroutine !====================================================================! !====================================================================! subroutine iArgDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( iArgDynamicArray ) :: ida , ida2 integer ( i32 ) :: ia call Msg ( '==========================' ) call Msg ( 'Testing : iArgDynamic Arrays' ) call Msg ( '==========================' ) ida = iArgDynamicArray ( 10 ) call test % test ( size ( ida % v % values ) == 10 . and . size ( ida % i % values ) == 10 , 'iArgDynamicArray' ) call test % test ( ida % v % N == 0 . and . ida % i % N == 0 , 'iArgDynamicArray' ) call ida % insertAt ( 1 , 10 , 10 ) call test % test ( ida % i % values ( 1 ) == 10 . and . ida % v % values ( 1 ) == 10 , 'iArgDynamicArray%insert' ) call ida % insertAt ( 1 , 20 , 20 ) call test % test ( all ( ida % i % values ( 1 : 2 ) == [ 20 , 10 ]) . and . all ( ida % v % values ( 1 : 2 ) == [ 20 , 10 ]), 'iArgDynamicArray%insert' ) call ida % prepend ( 30 , 30 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 30 , 20 , 10 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 30 , 20 , 10 ]), 'iArgDynamicArray%prepend' ) call ida % append ( 40 , 40 ) call test % test ( all ( ida % i % values ( 1 : 4 ) == [ 30 , 20 , 10 , 40 ]) . and . all ( ida % v % values ( 1 : 4 ) == [ 30 , 20 , 10 , 40 ]), 'iArgDynamicArray%append' ) call ida % remove ( 2 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 30 , 10 , 40 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 30 , 10 , 40 ]), 'iArgDynamicArray%remove' ) call ida % tighten () call test % test ( size ( ida % i % values ) == 3 . and . size ( ida % v % values ) == 3 , 'iArgDynamicArray%tighten' ) ida2 = ida call test % test ( all ( ida2 % i % values == ida % i % values ) . and . all ( ida2 % v % values == ida % v % values ), 'iArgDynamicArray%copy' ) ida2 % v % values ( 2 ) = 50 call test % test ( ida2 % v % values ( 2 ) /= ida % v % values ( 2 ), 'iArgDynamicArray%copy' ) call ida % deallocate () call test % test (. not . allocated ( ida % i % values ) . and . . not . allocated ( ida % v % values ), 'iArgDynamicArray%deallocate' ) call ida2 % deallocate () ida = iArgDynamicArray ( 3 , sorted = . true .) call ida % insertSorted ( 1 , 20 ) call ida % insertSorted ( 2 , 30 ) call ida % insertSorted ( 3 , 10 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 10 , 20 , 30 ]), 'iArgDynamicArray%insertSorted' ) ia = ida % locationOf ( 20 ) call test % test ( ia == 2 , 'iArgDynamicArray%locationOf' ) ia = ida % argOf ( 20 ) call test % test ( ia == 1 , 'iArgDynamicArray%argOf' ) call ida % insertSortedUnique ( 4 , 10 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 10 , 20 , 30 ]), 'iArgDynamicArray%insertSortedUnique' ) call ida % insertSortedUnique ( 4 , 15 ) call test % test ( all ( ida % i % values ( 1 : 4 ) == [ 3 , 4 , 1 , 2 ]) . and . all ( ida % v % values ( 1 : 4 ) == [ 10 , 15 , 20 , 30 ]), 'iArgDynamicArray%insertSortedUnique' ) call test % test ( size ( ida % i % values ) == 6 . and . size ( ida % v % values ) == 6 , 'iArgDynamicArray%insert' ) call ida % deallocate () ida = iArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call ida % insertSorted ( 1 , 20 ) call ida % insertSorted ( 2 , 30 ) call ida % insertSorted ( 3 , 10 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 10 , 20 , 30 ]), 'iArgDynamicArray%insertSorted' ) ia = ida % locationOf ( 20 ) call test % test ( ia == 2 , 'iArgDynamicArray%locationOf' ) ia = ida % argOf ( 20 ) call test % test ( ia == 1 , 'iArgDynamicArray%argOf' ) call ida % insertSortedUnique ( 4 , 10 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 10 , 20 , 30 ]), 'iArgDynamicArray%insertSortedUnique' ) call ida % insertSortedUnique ( 4 , 15 ) call test % test ( all ( ida % i % values ( 1 : 3 ) == [ 3 , 4 , 1 ]) . and . all ( ida % v % values ( 1 : 3 ) == [ 10 , 15 , 20 ]), 'iArgDynamicArray%insertSortedUnique' ) call test % test ( size ( ida % i % values ) == 3 . and . size ( ida % v % values ) == 3 , 'iArgDynamicArray%insert' ) call ida % deallocate () end subroutine end module","loc":"sourcefile/m_iargdynamicarray.f90.html","tags":""},{"title":"m_idArgDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_idargdynamicarray.f90~~EfferentGraph sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_idargdynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_idargdynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_idArgDynamicArray Source Code m_idArgDynamicArray.f90 Source Code module m_idArgDynamicArray !! Class that act as stacks, queues, and priority queues like [[m_idDynamicArray]] but with an added !! integer index so that 'lists' of both a key and value can be maintained. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given !! like k nearest neighbours, or k smallest. !! !! Example usage !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_iArgDynamicArray, only: iArgDynamicArray !! !!implicit none !! !!type(idArgDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = idArgDynamicArray(10) !!call da%insertAt(1, 10, 10_i64) !!call da%insertAt(1, 20, 20_i64) !!call da%prepend(30, 30_i64) !!call da%append(40, 40_i64) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%v%values(2) = 50_i64 !!call da%deallocate() !!call da2%deallocate() !! !!da = idArgDynamicArray(3, sorted=.true.) !!call da%insertSorted(1, 20_i64) !!call da%insertSorted(2, 30_i64) !!call da%insertSorted(3, 10_i64) !!ia = da%locationOf(20_i64) !!ia = da%argOf(20_i64) !!call da%insertSortedUnique(4, 10_i64) !!call da%insertSortedUnique(4, 15_i64) !!call da%deallocate() !! !!da = idArgDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(1, 20_i64) !!call da%insertSorted(2, 30_i64) !!call da%insertSorted(3, 10_i64) !!ia = da%locationOf(20_i64) !!ia = da%argOf(20_i64) !!call da%insertSortedUnique(4, 10_i64) !!call da%insertSortedUnique(4, 15_i64) !!call da%deallocate() !!end program !!``` use variableKind , only : i32 , i64 use m_errors , only : msg , eMsg use m_iDynamicArray , only : iDynamicArray use m_idDynamicArray , only : idDynamicArray , insertAt__idDynamicArray use m_searching , only : intervalSearch use m_strings , only : str use m_unitTester , only : tester implicit none private public :: idArgDynamicArray_test public :: idArgDynamicArray type :: idArgDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_idArgDynamicArray]] for more information on how to use this class. type ( iDynamicArray ) :: i !! Argument of the values. type ( idDynamicArray ) :: v !! Values. contains procedure , public :: append => append_idArgDynamicArray !! idArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: argOf => argOf_idArgDynamicArray !! idArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure , public :: deallocate => deallocate_idArgDynamicArray !! idArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_idArgDynamicArray !! idArgDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_idArgDynamicArray !! idArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_idArgDynamicArray !! idArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_idArgDynamicArray !! idArgDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_idArgDynamicArray !! idArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure , public :: locationOf => locationOf_idArgDynamicArray !! idArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_idArgDynamicArray !! idArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: remove => remove_idArgDynamicArray !! idArgDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_idArgDynamicArray !! idArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface idArgDynamicArray procedure :: init_idArgDynamicArray_i1 , init_idArgDynamicArray_id1D end interface interface assignment ( = ) procedure :: copy_idArgDynamicArray end interface contains !====================================================================! subroutine append_idArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure idArgDynamicArray%append(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i32 ) :: i !! Index of value integer ( i64 ) :: val !! Value to append call this % i % append ( i ) call this % v % append ( val ) end subroutine !====================================================================! !====================================================================! function argOf_idArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure idArgDynamicArray%locationOf(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i64 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Argument of the value. integer ( i32 ) :: iSearch iSearch = this % v % locationOf ( val ) i = - 1 if ( iSearch /= - 1 ) i = this % i % values ( iSearch ) end function !====================================================================! !====================================================================! subroutine copy_idArgDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( idArgDynamicArray ), intent ( in ) :: this !! Class to copy. type ( idArgDynamicArray ), intent ( out ) :: new !! Copy of this. new % i = this % i new % v = this % v end subroutine !====================================================================! !====================================================================! subroutine deallocate_idArgDynamicArray ( this ) !! Overloaded type bound procedure idArgDynamicArray%deallocate(). !====================================================================! class ( idArgDynamicArray ) :: this call this % i % deallocate () call this % v % deallocate () end subroutine !====================================================================! !====================================================================! function init_idArgDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface [[idArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ), optional :: M logical , intent ( in ), optional :: sorted logical , intent ( in ), optional :: fixed type ( idArgDynamicArray ) :: this this % i = iDynamicArray ( M , . false ., fixed ) this % v = idDynamicArray ( M , sorted , fixed ) end function !====================================================================! !====================================================================! function init_idArgDynamicArray_id1D ( i , values , M , sorted , fixed ) result ( this ) !! Overloaded by interface [[idArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ) :: i (:) integer ( i64 ), intent ( in ) :: values (:) integer ( i32 ), intent ( in ), optional :: M logical , intent ( in ), optional :: sorted logical , intent ( in ), optional :: fixed type ( idArgDynamicArray ) :: this integer ( i32 ) :: ii , iv ii = size ( i ) iv = size ( values ) if ( ii /= iv ) call eMsg ( \"idArgDynamicArray: Size of i \" // str ( ii ) // \"must equal size of values \" // str ( iv )) this % i = iDynamicArray ( i , M , . false ., fixed ) this % v = idDynamicArray ( values , M , sorted , fixed ) end function !====================================================================! !====================================================================! subroutine insertAt_idArgDynamicArray ( this , loc , i , val ) !! Overloaded type bound procedure idArgDynamicArray%insertAt(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i32 ) :: loc !! Insert index and value at this location. integer ( i32 ) :: i !! index/ integer ( i64 ) :: val !! Value/ call this % i % insertAt ( loc , i ) call this % v % insertAt ( loc , val ) end subroutine !====================================================================! !====================================================================! subroutine insertSorted_idArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure idArgDynamicArray%insertSorted(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. integer ( i64 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) call this % i % insertAt ( iSearch ( 3 ), i ) call insertAt__idDynamicArray ( this % v , iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_idArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure idArgDynamicArray%insertSortedUnique(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. integer ( i64 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) if ( iSearch ( 1 ) == - 1 ) then call this % i % insertAt ( iSearch ( 3 ), i ) call insertAt__idDynamicArray ( this % v , iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_idArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure idArgDynamicArray%isEmpty() !====================================================================! class ( idArgDynamicArray ) :: this logical :: yes !! Array is empty yes = this % v % isEmpty () end function !====================================================================! !====================================================================! function isFilled_idArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure idArgDynamicArray%isFilled() !====================================================================! class ( idArgDynamicArray ) :: this logical :: yes !! Array is filled yes = this % v % isFilled () end function !====================================================================! !====================================================================! function locationOf_idArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure idArgDynamicArray%locationOf(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i64 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Index of the value. i = this % v % locationOf ( val ) end function !====================================================================! !====================================================================! subroutine prepend_idArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure idArgDynamicArray%prepend(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i32 ) :: i !! Prepend indices with this index. integer ( i64 ) :: val !! Prepend values with this value. call this % i % prepend ( i ) call this % v % prepend ( val ) end subroutine !====================================================================! !====================================================================! subroutine remove_idArgDynamicArray ( this , i ) !! Overloaded type bound procedure idArgDynamicArray%remove(). !====================================================================! class ( idArgDynamicArray ) :: this integer ( i32 ) :: i !! Remove the elements at this location. call this % i % remove ( i ) call this % v % remove ( i ) end subroutine !====================================================================! !====================================================================! subroutine tighten_idArgDynamicArray ( this ) !! Overloaded type bound procedure idArgDynamicArray%tighten(). !====================================================================! class ( idArgDynamicArray ) :: this call this % i % tighten () call this % v % tighten () end subroutine !====================================================================! !====================================================================! subroutine idArgDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( idArgDynamicArray ) :: idda , idda2 integer ( i32 ) :: ia call Msg ( '==========================' ) call Msg ( 'Testing : idArgDynamic Arrays' ) call Msg ( '==========================' ) idda = idArgDynamicArray ( 10 ) call test % test ( size ( idda % v % values ) == 10 . and . size ( idda % i % values ) == 10 , 'idArgDynamicArray' ) call test % test ( idda % v % N == 0 . and . idda % i % N == 0 , 'idArgDynamicArray' ) call idda % insertAt ( 1 , 10 , 10_i64 ) call test % test ( idda % i % values ( 1 ) == 10_i64 . and . idda % v % values ( 1 ) == 10_i64 , 'idArgDynamicArray%insert' ) call idda % insertAt ( 1 , 20 , 20_i64 ) call test % test ( all ( idda % i % values ( 1 : 2 ) == [ 20_i64 , 10_i64 ]) . and . all ( idda % v % values ( 1 : 2 ) == [ 20_i64 , 10_i64 ]), 'idArgDynamicArray%insert' ) call idda % prepend ( 30 , 30_i64 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 30_i64 , 20_i64 , 10_i64 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 30_i64 , 20_i64 , 10_i64 ]), 'idArgDynamicArray%prepend' ) call idda % append ( 40 , 40_i64 ) call test % test ( all ( idda % i % values ( 1 : 4 ) == [ 30_i64 , 20_i64 , 10_i64 , 40_i64 ]) . and . all ( idda % v % values ( 1 : 4 ) == [ 30_i64 , 20_i64 , 10_i64 , 40_i64 ]), 'idArgDynamicArray%append' ) call idda % remove ( 2 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 30_i64 , 10_i64 , 40_i64 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 30_i64 , 10_i64 , 40_i64 ]), 'idArgDynamicArray%remove' ) call idda % tighten () call test % test ( size ( idda % i % values ) == 3 . and . size ( idda % v % values ) == 3 , 'idArgDynamicArray%tighten' ) idda2 = idda call test % test ( all ( idda2 % i % values == idda % i % values ) . and . all ( idda2 % v % values == idda % v % values ), 'idArgDynamicArray%copy' ) idda2 % v % values ( 2 ) = 50_i64 call test % test ( idda2 % v % values ( 2 ) /= idda % v % values ( 2 ), 'idArgDynamicArray%copy' ) call idda % deallocate () call test % test (. not . allocated ( idda % i % values ) . and . . not . allocated ( idda % v % values ), 'idArgDynamicArray%deallocate' ) call idda2 % deallocate () idda = idArgDynamicArray ( 3 , sorted = . true .) call idda % insertSorted ( 1 , 20_i64 ) call idda % insertSorted ( 2 , 30_i64 ) call idda % insertSorted ( 3 , 10_i64 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 10_i64 , 20_i64 , 30_i64 ]), 'idArgDynamicArray%insertSorted' ) ia = idda % locationOf ( 20_i64 ) call test % test ( ia == 2 , 'idArgDynamicArray%locationOf' ) ia = idda % argOf ( 20_i64 ) call test % test ( ia == 1 , 'idArgDynamicArray%argOf' ) call idda % insertSortedUnique ( 4 , 10_i64 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 10_i64 , 20_i64 , 30_i64 ]), 'idArgDynamicArray%insertSortedUnique' ) call idda % insertSortedUnique ( 4 , 15_i64 ) call test % test ( all ( idda % i % values ( 1 : 4 ) == [ 3 , 4 , 1 , 2 ]) . and . all ( idda % v % values ( 1 : 4 ) == [ 10_i64 , 15_i64 , 20_i64 , 30_i64 ]), 'idArgDynamicArray%insertSortedUnique' ) call test % test ( size ( idda % i % values ) == 6 . and . size ( idda % v % values ) == 6 , 'idArgDynamicArray%insert' ) call idda % deallocate () idda = idArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call idda % insertSorted ( 1 , 20_i64 ) call idda % insertSorted ( 2 , 30_i64 ) call idda % insertSorted ( 3 , 10_i64 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 10_i64 , 20_i64 , 30_i64 ]), 'idArgDynamicArray%insertSorted' ) ia = idda % locationOf ( 20_i64 ) call test % test ( ia == 2 , 'idArgDynamicArray%locationOf' ) ia = idda % argOf ( 20_i64 ) call test % test ( ia == 1 , 'idArgDynamicArray%argOf' ) call idda % insertSortedUnique ( 4 , 10_i64 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 10_i64 , 20_i64 , 30_i64 ]), 'idArgDynamicArray%insertSortedUnique' ) call idda % insertSortedUnique ( 4 , 15_i64 ) call test % test ( all ( idda % i % values ( 1 : 3 ) == [ 3 , 4 , 1 ]) . and . all ( idda % v % values ( 1 : 3 ) == [ 10_i64 , 15_i64 , 20_i64 ]), 'idArgDynamicArray%insertSortedUnique' ) call test % test ( size ( idda % i % values ) == 3 . and . size ( idda % v % values ) == 3 , 'idArgDynamicArray%insert' ) call idda % deallocate () end subroutine end module","loc":"sourcefile/m_idargdynamicarray.f90.html","tags":""},{"title":"m_idDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_iddynamicarray.f90~~EfferentGraph sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_iddynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_iddynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_iddynamicarray.f90~~AfferentGraph sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_idDynamicArray Source Code m_idDynamicArray.f90 Source Code module m_idDynamicArray !! Class that act as stacks, queues, and priority queues. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_dynamicArray, only: idDynamicArray !! !!implicit none !! !!type(idDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = idDynamicArray(10) !!call da%insertAt(1, 10_i64) !!call da%insertAt(1, 20_i64) !!call da%prepend(30_i64) !!call da%append(40_i64) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%values(2) = 50_i64 !!call da%deallocate() !!call da2%deallocate() !! !!da = idDynamicArray(3, sorted=.true.) !!call da%insertSorted(20_i64) !!call da%insertSorted(30_i64) !!call da%insertSorted(10_i64) !!ia = da%locationOf(20_i64) !!call da%insertSortedUnique(10_i64) !!call da%insertSortedUnique(15_i64) !!call da%deallocate() !! !!da = idDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(20_i64) !!call da%insertSorted(30_i64) !!call da%insertSorted(10_i64) !!ia = da%locationOf(20_i64) !!call da%insertSortedUnique(10_i64) !!call da%insertSortedUnique(15_i64) !!call da%deallocate() !!end program !!``` use variableKind , only : i32 , i64 use m_allocate , only : allocate use m_searching , only : binarySearch , intervalSearch use m_deallocate , only : deallocate use m_errors , only : eMsg , msg use m_reallocate , only : reallocate use m_sort , only : sort use m_strings , only : str use m_unitTester , only : tester implicit none private public :: idDynamicArray_test public :: insertAt__idDynamicArray public :: idDynamicArray type :: idDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_idDynamicArray]] for more information on how to use this class. integer ( i32 ) :: N !! Current size of the array integer ( i64 ), allocatable :: values (:) !! Memory for values, can be larger than N logical :: sorted = . false . !! Keep track of whether the array is sorted for potential speed increases logical :: fixed = . false . !! Don't allow the memory to change after initial instantiation. contains procedure , public :: append => append_idDynamicArray !! idDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: deallocate => deallocate_idDynamicArray !! idDynamicArray%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_idDynamicArray !! idDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_idDynamicArray !! idDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_idDynamicArray !! idDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_idDynamicArray !! idDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_idDynamicArray !! idDynamicArray%isFilled() - True if the array is filled. procedure , public :: locationOf => locationOf_idDynamicArray !! idDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_idDynamicArray !! idDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: reallocate => reallocate_idDynamicArray !! idDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure , public :: remove => remove_idDynamicArray !! idDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_idDynamicArray !! idDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface idDynamicArray procedure :: init_idDynamicArray_i1 , init_idDynamicArray_d1D end interface interface assignment ( = ) procedure :: copy_idDynamicArray end interface contains !====================================================================! subroutine append_idDynamicArray ( this , val ) !! Overloaded type bound procedure idDynamicArray%append() !====================================================================! class ( idDynamicArray ) :: this integer ( i64 ) :: val !! Value to append. if ( this % fixed ) call eMsg ( 'idDynamicArray%append: Cannot use append with fixed array.' ) call insertAt__idDynamicArray ( this , this % N + 1 , val ) ! Append at last location end subroutine !====================================================================! !====================================================================! subroutine copy_idDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( idDynamicArray ), intent ( in ) :: this !! Class to copy. type ( idDynamicArray ), intent ( out ) :: new !! Copy of this. call allocate ( new % values , size ( this % values )) new % N = this % N new % values = this % values new % sorted = this % sorted new % fixed = this % fixed end subroutine !====================================================================! !====================================================================! subroutine deallocate_idDynamicArray ( this ) !! Overloaded type bound procedure idDynamicArray%deallocate() !====================================================================! class ( idDynamicArray ) :: this call deallocate ( this % values ) this % N = 0 this % sorted = . false . end subroutine !====================================================================! !====================================================================! function init_idDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface idDynamicArray() !====================================================================! integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( idDynamicArray ) :: this !! Return type. integer ( i32 ) :: M_ M_ = 1 if ( present ( M )) then if ( M < 1 ) call eMsg ( 'M must be > 0' ) M_ = M endif call allocate ( this % values , M_ ) this % N = 0 this % sorted = . false . if ( present ( sorted )) this % sorted = sorted this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! function init_idDynamicArray_d1D ( values , M , sorted , fixed ) result ( this ) !! Overloaded by interface idDynamicArray() !====================================================================! integer ( i64 ), intent ( in ) :: values (:) !! Set of values to initialize with. integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( idDynamicArray ) :: this !! Return type if ( present ( M )) then if ( M < size ( values )) call eMsg ( 'M must be >= size(values)' ) call allocate ( this % values , M ) else call allocate ( this % values , size ( values )) endif this % N = size ( values ) this % sorted = . false . if ( present ( sorted )) this % sorted = sorted if ( this % sorted ) then this % values ( 1 : this % N ) = values call sort ( this % values ( 1 : this % N )) else this % values ( 1 : this % N ) = values endif this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! subroutine insertAt_idDynamicArray ( this , i , val ) !! Overloaded type bound procedure rDynamicArray%insertAt() !====================================================================! class ( idDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. integer ( i64 ) :: val !! Insert this value. if ( this % sorted ) call eMsg ( 'idDynamicArray%insertAt: Cannot use insertAt with sorted array' ) call insertAt__idDynamicArray ( this , i , val ) end subroutine !====================================================================! !====================================================================! subroutine insertAt__idDynamicArray ( this , i , val ) !! Private insert into array without checking for sorted flag. !====================================================================! class ( idDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. integer ( i64 ) :: val !! Insert this value. integer :: j , N if ( i < 1 . or . i > this % N + 1 ) call Emsg ( 'idDynamicArray%insertAt: 1 <= i <= ' // str ( this % N + 1 )) N = size ( this % values ) if ( this % fixed ) then if ( i > N ) call Emsg ( 'idDynamicArray%insertAt: For fixed array, 1 <= i <= ' // str ( N )) if ( this % N < N ) this % N = this % N + 1 do j = this % N , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo else ! Expand the vector if needed if ( N < this % N + 1 ) call this % reallocate ( 2 * N ) do j = this % N + 1 , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo this % N = this % N + 1 endif this % values ( i ) = val end subroutine !====================================================================! !====================================================================! subroutine insertSorted_idDynamicArray ( this , val ) !! Overloaded type bound procedure idDynamicArray%insertSorted() !====================================================================! class ( idDynamicArray ) :: this integer ( i64 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'idDynamicArray%insertSorted: Cannot use insertSorted with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) call insertAt__idDynamicArray ( this , iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_idDynamicArray ( this , val ) !! Overloaded type bound procedure idDynamicArray%insertSortedUnique() !====================================================================! class ( idDynamicArray ) :: this integer ( i64 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'idDynamicArray%insertSortedUnique: Cannot use insertSortedUnique with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) if ( iSearch ( 1 ) == - 1 ) then call insertAt__idDynamicArray ( this , iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_idDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure idDynamicArray%isEmpty() !====================================================================! class ( idDynamicArray ) :: this logical :: yes !! Array is empty yes = ( this % N == 0 ) end function !====================================================================! !====================================================================! function isFilled_idDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure idDynamicArray%isFilled() !====================================================================! class ( idDynamicArray ) :: this logical :: yes !! Array is filled yes = ( this % N == size ( this % values )) end function !====================================================================! !====================================================================! function locationOf_idDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure idDynamicArray%locationOf(). !====================================================================! class ( idDynamicArray ) :: this integer ( i64 ) :: val !! Get the location of this value integer ( i32 ) :: i !! Location of value if (. not . this % sorted ) call eMsg ( 'idDynamicArray%locationOf: Cannot use locationOf with unsorted dynamic array' ) i = binarySearch ( this % values , val , 1 , this % N ) end function !====================================================================! !====================================================================! subroutine prepend_idDynamicArray ( this , val ) !! Overloaded type bound procedure idDynamicArray%prepend() !====================================================================! class ( idDynamicArray ) :: this integer ( i64 ) :: val !! Value to prepend. if ( this % fixed ) call eMsg ( 'idDynamicArray%prepend: Cannot use prepend with fixed array.' ) call insertAt__idDynamicArray ( this , 1 , val ) ! Prepend at first location end subroutine !====================================================================! !====================================================================! subroutine reallocate_idDynamicArray ( this , M ) !! Overloaded type bound procedure idDynamicArray%reallocate(). !====================================================================! class ( idDynamicArray ) :: this integer ( i32 ) :: M !! Reallocate memory to this size. call reallocate ( this % values , M ) end subroutine !====================================================================! !====================================================================! subroutine remove_idDynamicArray ( this , i ) !! Overloaded type bound procedure idDynamicArray%remove(). !====================================================================! class ( idDynamicArray ) :: this integer ( i32 ) :: i !! Remove the value at this location. integer ( i32 ) :: j if ( i < 1 . or . i > this % N ) call Emsg ( 'idDynamic%remove: 1 <= i <= ' // str ( this % N )) do j = i , this % N - 1 this % values ( j ) = this % values ( j + 1 ) enddo this % N = this % N - 1 if (. not . this % fixed ) then if ( this % N < size ( this % values ) / 4 ) call this % reallocate ( this % N ) endif end subroutine !====================================================================! !====================================================================! subroutine tighten_idDynamicArray ( this ) !! Overloaded type bound procedure idDynamicArray%tighten(). !====================================================================! class ( idDynamicArray ) :: this if ( this % fixed ) call eMsg ( 'idDynamicArray%tighten: Cannot use tighten with fixed array.' ) call this % reallocate ( this % N ) end subroutine !====================================================================! !====================================================================! subroutine idDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( idDynamicArray ) :: idda , idda2 integer ( i32 ) :: ia idda = idDynamicArray ( 10 ) call test % test ( size ( idda % values ) == 10 , 'idDynamicArray' ) call test % test ( idda % N == 0 , 'idDynamicArray' ) call idda % insertAt ( 1 , 10_i64 ) call test % test ( idda % values ( 1 ) == 10 , 'idDynamicArray%insert' ) call idda % insertAt ( 1 , 20_i64 ) call test % test ( all ( idda % values ( 1 : 2 ) == [ 20_i64 , 10_i64 ]), 'idDynamicArray%insert' ) call idda % prepend ( 30_i64 ) call test % test ( all ( idda % values ( 1 : 3 ) == [ 30_i64 , 20_i64 , 10_i64 ]), 'idDynamicArray%prepend' ) call idda % append ( 40_i64 ) call test % test ( all ( idda % values ( 1 : 4 ) == [ 30_i64 , 20_i64 , 10_i64 , 40_i64 ]), 'idDynamicArray%append' ) call idda % remove ( 2 ) call test % test ( all ( idda % values ( 1 : 3 ) == [ 30_i64 , 10_i64 , 40_i64 ]), 'idDynamicArray%remove' ) call idda % tighten () call test % test ( size ( idda % values ) == 3 , 'idDynamicArray%tighten' ) idda2 = idda call test % test ( all ( idda2 % values == idda % values ), 'idDynamicArray%copy' ) idda2 % values ( 2 ) = 50_i64 call test % test ( idda2 % values ( 2 ) /= idda % values ( 2 ), 'idDynamicArray%copy' ) call idda % deallocate () call test % test (. not . allocated ( idda % values ), 'idDynamicArray%deallocate' ) call idda2 % deallocate () idda = idDynamicArray ( 3 , sorted = . true .) call idda % insertSorted ( 20_i64 ) call idda % insertSorted ( 30_i64 ) call idda % insertSorted ( 10_i64 ) call test % test ( all ( idda % values == [ 10_i64 , 20_i64 , 30_i64 ]), 'idDynamicArray%insertSorted' ) ia = idda % locationOf ( 20_i64 ) call test % test ( ia == 2 , 'idDynamicArray%locationOf' ) call idda % insertSortedUnique ( 10_i64 ) call test % test ( all ( idda % values == [ 10_i64 , 20_i64 , 30_i64 ]), 'idDynamicArray%insertSortedUnique' ) call idda % insertSortedUnique ( 15_i64 ) call test % test ( all ( idda % values ( 1 : idda % N ) == [ 10_i64 , 15_i64 , 20_i64 , 30_i64 ]), 'idDynamicArray%insertSortedUnique' ) call test % test ( size ( idda % values ) == 6 , 'idDynamicArray%insert' ) call idda % deallocate () idda = idDynamicArray ( 3 , sorted = . true ., fixed = . true .) call idda % insertSorted ( 20_i64 ) call idda % insertSorted ( 30_i64 ) call idda % insertSorted ( 10_i64 ) call test % test ( all ( idda % values ( 1 : idda % N ) == [ 10_i64 , 20_i64 , 30_i64 ]), 'idDynamicArray%insertSorted' ) ia = idda % locationOf ( 20_i64 ) call test % test ( ia == 2 , 'idDynamicArray%locationOf' ) call idda % insertSortedUnique ( 10_i64 ) call test % test ( all ( idda % values ( 1 : idda % N ) == [ 10_i64 , 20_i64 , 30_i64 ]), 'idDynamicArray%insertSortedUnique' ) call idda % insertSortedUnique ( 15_i64 ) call test % test ( all ( idda % values ( 1 : idda % N ) == [ 10_i64 , 15_i64 , 20_i64 ]), 'idDynamicArray%insertSortedUnique' ) call test % test ( size ( idda % values ) == 3 , 'idDynamicArray%insert' ) call idda % deallocate () end subroutine end module","loc":"sourcefile/m_iddynamicarray.f90.html","tags":""},{"title":"m_iDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_idynamicarray.f90~~EfferentGraph sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_idynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_idynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_idynamicarray.f90~~AfferentGraph sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_iDynamicArray Source Code m_iDynamicArray.f90 Source Code module m_iDynamicArray !! Class that act as stacks, queues, and priority queues. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_iDynamicArray, only: iDynamicArray !! !!implicit none !! !!type(iDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = iDynamicArray(10) !!call da%insertAt(1, 10) !!call da%insertAt(1, 20) !!call da%prepend(30) !!call da%append(40) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%values(2) = 50 !!call da%deallocate() !!call da2%deallocate() !! !!da = iDynamicArray(3, sorted=.true.) !!call da%insertSorted(20) !!call da%insertSorted(30) !!call da%insertSorted(10) !!ia = da%locationOf(20) !!call da%insertSortedUnique(10) !!call da%insertSortedUnique(15) !!call da%deallocate() !! !!da = iDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(20) !!call da%insertSorted(30) !!call da%insertSorted(10) !!ia = da%locationOf(20) !!call da%insertSortedUnique(10) !!call da%insertSortedUnique(15) !!call da%deallocate() !!end program !!``` use variableKind , only : i32 use m_allocate , only : allocate use m_searching , only : binarySearch , intervalSearch use m_deallocate , only : deallocate use m_errors , only : eMsg , msg use m_reallocate , only : reallocate use m_sort , only : sort use m_strings , only : str use m_unitTester , only : tester implicit none private public :: iDynamicArray_test public :: insertAt__iDynamicArray public :: iDynamicArray type :: iDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_iDynamicArray]] for more information on how to use this class. integer ( i32 ) :: N !! Current size of the array integer ( i32 ), allocatable :: values (:) !! Memory for values, can be larger than N logical :: sorted = . false . !! Keep track of whether the array is sorted for potential speed increases logical :: fixed = . false . !! Don't allow the memory to change after initial instantiation. contains procedure , public :: append => append_iDynamicArray !! iDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: deallocate => deallocate_iDynamicArray !! iDynamicArray%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_iDynamicArray !! iDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_iDynamicArray !! iDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_iDynamicArray !! iDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_iDynamicArray !! iDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_iDynamicArray !! iDynamicArray%isFilled() - True if the array is filled. procedure , public :: locationOf => locationOf_iDynamicArray !! iDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_iDynamicArray !! iDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: reallocate => reallocate_iDynamicArray !! iDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure , public :: remove => remove_iDynamicArray !! iDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_iDynamicArray !! iDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface iDynamicArray procedure :: init_iDynamicArray_i1 , init_iDynamicArray_d1D end interface interface assignment ( = ) procedure :: copy_iDynamicArray end interface contains !====================================================================! subroutine append_iDynamicArray ( this , val ) !! Overloaded type bound procedure iDynamicArray%append() !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: val !! Value to append. if ( this % fixed ) call eMsg ( 'iDynamicArray%append: Cannot use append with fixed array.' ) call insertAt__iDynamicArray ( this , this % N + 1 , val ) ! Append at last location end subroutine !====================================================================! !====================================================================! subroutine copy_iDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( iDynamicArray ), intent ( in ) :: this !! Class to copy. type ( iDynamicArray ), intent ( out ) :: new !! Copy of this. call allocate ( new % values , size ( this % values )) new % N = this % N new % values = this % values new % sorted = this % sorted new % fixed = this % fixed end subroutine !====================================================================! !====================================================================! subroutine deallocate_iDynamicArray ( this ) !! Overloaded type bound procedure iDynamicArray%deallocate() !====================================================================! class ( iDynamicArray ) :: this call deallocate ( this % values ) this % N = 0 this % sorted = . false . end subroutine !====================================================================! !====================================================================! function init_iDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface iDynamicArray() !====================================================================! integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( iDynamicArray ) :: this !! Return type. integer ( i32 ) :: M_ M_ = 1 if ( present ( M )) then if ( M < 1 ) call eMsg ( 'M must be > 0' ) M_ = M endif call allocate ( this % values , M_ ) this % N = 0 this % sorted = . false . if ( present ( sorted )) this % sorted = sorted this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! function init_iDynamicArray_d1D ( values , M , sorted , fixed ) result ( this ) !! Overloaded by interface iDynamicArray() !====================================================================! integer ( i32 ), intent ( in ) :: values (:) !! Set of values to initialize with. integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( iDynamicArray ) :: this !! Return type if ( present ( M )) then if ( M < size ( values )) call eMsg ( 'M must be >= size(values)' ) call allocate ( this % values , M ) else call allocate ( this % values , size ( values )) endif this % N = size ( values ) this % sorted = . false . if ( present ( sorted )) this % sorted = sorted if ( this % sorted ) then this % values ( 1 : this % N ) = values call sort ( this % values ( 1 : this % N )) else this % values ( 1 : this % N ) = values endif this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! subroutine insertAt_iDynamicArray ( this , i , val ) !! Overloaded type bound procedure rDynamicArray%insertAt() !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. integer ( i32 ) :: val !! Insert this value. if ( this % sorted ) call eMsg ( 'iDynamicArray%insertAt: Cannot use insertAt with sorted array' ) call insertAt__iDynamicArray ( this , i , val ) end subroutine !====================================================================! !====================================================================! subroutine insertAt__iDynamicArray ( this , i , val ) !! Private insert into array without checking for sorted flag. !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. integer ( i32 ) :: val !! Insert this value. integer :: j , N if ( i < 1 . or . i > this % N + 1 ) call Emsg ( 'iDynamicArray%insertAt: 1 <= i <= ' // str ( this % N + 1 )) N = size ( this % values ) if ( this % fixed ) then if ( i > N ) call Emsg ( 'iDynamicArray%insertAt: For fixed array, 1 <= i <= ' // str ( N )) if ( this % N < N ) this % N = this % N + 1 do j = this % N , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo else ! Expand the vector if needed if ( N < this % N + 1 ) call this % reallocate ( 2 * N ) do j = this % N + 1 , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo this % N = this % N + 1 endif this % values ( i ) = val end subroutine !====================================================================! !====================================================================! subroutine insertSorted_iDynamicArray ( this , val ) !! Overloaded type bound procedure iDynamicArray%insertSorted() !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'iDynamicArray%insertSorted: Cannot use insertSorted with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) call insertAt__iDynamicArray ( this , iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_iDynamicArray ( this , val ) !! Overloaded type bound procedure iDynamicArray%insertSortedUnique() !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'iDynamicArray%insertSortedUnique: Cannot use insertSortedUnique with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) if ( iSearch ( 1 ) == - 1 ) then call insertAt__iDynamicArray ( this , iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_iDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure iDynamicArray%isEmpty() !====================================================================! class ( iDynamicArray ) :: this logical :: yes !! Array is empty yes = ( this % N == 0 ) end function !====================================================================! !====================================================================! function isFilled_iDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure iDynamicArray%isFilled() !====================================================================! class ( iDynamicArray ) :: this logical :: yes !! Array is filled yes = ( this % N == size ( this % values )) end function !====================================================================! !====================================================================! function locationOf_iDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure iDynamicArray%locationOf(). !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: val !! Get the location of this value integer ( i32 ) :: i !! Location of value if (. not . this % sorted ) call eMsg ( 'iDynamicArray%locationOf: Cannot use locationOf with unsorted dynamic array' ) i = binarySearch ( this % values , val , 1 , this % N ) end function !====================================================================! !====================================================================! subroutine prepend_iDynamicArray ( this , val ) !! Overloaded type bound procedure iDynamicArray%prepend() !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: val !! Value to prepend. if ( this % fixed ) call eMsg ( 'iDynamicArray%prepend: Cannot use prepend with fixed array.' ) call insertAt__iDynamicArray ( this , 1 , val ) ! Prepend at first location end subroutine !====================================================================! !====================================================================! subroutine reallocate_iDynamicArray ( this , M ) !! Overloaded type bound procedure iDynamicArray%reallocate(). !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: M !! Reallocate memory to this size. call reallocate ( this % values , M ) end subroutine !====================================================================! !====================================================================! subroutine remove_iDynamicArray ( this , i ) !! Overloaded type bound procedure iDynamicArray%remove(). !====================================================================! class ( iDynamicArray ) :: this integer ( i32 ) :: i !! Remove the value at this location. integer ( i32 ) :: j if ( i < 1 . or . i > this % N ) call Emsg ( 'iDynamic%remove: 1 <= i <= ' // str ( this % N )) do j = i , this % N - 1 this % values ( j ) = this % values ( j + 1 ) enddo this % N = this % N - 1 if (. not . this % fixed ) then if ( this % N < size ( this % values ) / 4 ) call this % reallocate ( this % N ) endif end subroutine !====================================================================! !====================================================================! subroutine tighten_iDynamicArray ( this ) !! Overloaded type bound procedure iDynamicArray%tighten(). !====================================================================! class ( iDynamicArray ) :: this if ( this % fixed ) call eMsg ( 'iDynamicArray%tighten: Cannot use tighten with fixed array.' ) call this % reallocate ( this % N ) end subroutine !====================================================================! !====================================================================! subroutine iDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( iDynamicArray ) :: ida , ida2 integer ( i32 ) :: ia ida = iDynamicArray ( 10 ) call test % test ( size ( ida % values ) == 10 , 'iDynamicArray' ) call test % test ( ida % N == 0 , 'iDynamicArray' ) call ida % insertAt ( 1 , 10 ) call test % test ( ida % values ( 1 ) == 10 , 'iDynamicArray%insert' ) call ida % insertAt ( 1 , 20 ) call test % test ( all ( ida % values ( 1 : 2 ) == [ 20 , 10 ]), 'iDynamicArray%insert' ) call ida % prepend ( 30 ) call test % test ( all ( ida % values ( 1 : 3 ) == [ 30 , 20 , 10 ]), 'iDynamicArray%prepend' ) call ida % append ( 40 ) call test % test ( all ( ida % values ( 1 : 4 ) == [ 30 , 20 , 10 , 40 ]), 'iDynamicArray%append' ) call ida % remove ( 2 ) call test % test ( all ( ida % values ( 1 : 3 ) == [ 30 , 10 , 40 ]), 'iDynamicArray%remove' ) call ida % tighten () call test % test ( size ( ida % values ) == 3 , 'iDynamicArray%tighten' ) ida2 = ida call test % test ( all ( ida2 % values == ida % values ), 'iDynamicArray%copy' ) ida2 % values ( 2 ) = 50 call test % test ( ida2 % values ( 2 ) /= ida % values ( 2 ), 'iDynamicArray%copy' ) call ida % deallocate () call test % test (. not . allocated ( ida % values ), 'iDynamicArray%deallocate' ) call ida2 % deallocate () ida = iDynamicArray ( 3 , sorted = . true .) call ida % insertSorted ( 20 ) call ida % insertSorted ( 30 ) call ida % insertSorted ( 10 ) call test % test ( all ( ida % values == [ 10 , 20 , 30 ]), 'iDynamicArray%insertSorted' ) ia = ida % locationOf ( 20 ) call test % test ( ia == 2 , 'iDynamicArray%locationOf' ) call ida % insertSortedUnique ( 10 ) call test % test ( all ( ida % values == [ 10 , 20 , 30 ]), 'iDynamicArray%insertSortedUnique' ) call ida % insertSortedUnique ( 15 ) call test % test ( all ( ida % values ( 1 : ida % N ) == [ 10 , 15 , 20 , 30 ]), 'iDynamicArray%insertSortedUnique' ) call test % test ( size ( ida % values ) == 6 , 'iDynamicArray%insert' ) call ida % deallocate () ida = iDynamicArray ( 3 , sorted = . true ., fixed = . true .) call ida % insertSorted ( 20 ) call ida % insertSorted ( 30 ) call ida % insertSorted ( 10 ) call test % test ( all ( ida % values ( 1 : ida % N ) == [ 10 , 20 , 30 ]), 'iDynamicArray%insertSorted' ) ia = ida % locationOf ( 20 ) call test % test ( ia == 2 , 'iDynamicArray%locationOf' ) call ida % insertSortedUnique ( 10 ) call test % test ( all ( ida % values ( 1 : ida % N ) == [ 10 , 20 , 30 ]), 'iDynamicArray%insertSortedUnique' ) call ida % insertSortedUnique ( 15 ) call test % test ( all ( ida % values ( 1 : ida % N ) == [ 10 , 15 , 20 ]), 'iDynamicArray%insertSortedUnique' ) call test % test ( size ( ida % values ) == 3 , 'iDynamicArray%insert' ) call ida % deallocate () end subroutine end module","loc":"sourcefile/m_idynamicarray.f90.html","tags":""},{"title":"m_rArgDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_rargdynamicarray.f90~~EfferentGraph sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_rargdynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_rargdynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_rArgDynamicArray Source Code m_rArgDynamicArray.f90 Source Code module m_rArgDynamicArray !! Class that act as stacks, queues, and priority queues like [[m_rDynamicArray]] but with an added !! integer index so that 'lists' of both a key and value can be maintained. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given !! like k nearest neighbours, or k smallest. !! !! Example usage !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_iArgDynamicArray, only: iArgDynamicArray !! !!implicit none !! !!type(rArgDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = rArgDynamicArray(10) !!call da%insertAt(1, 10, 10.0) !!call da%insertAt(1, 20, 20.0) !!call da%prepend(30, 30.0) !!call da%append(40, 40.0) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%v%values(2) = 50.0 !!call da%deallocate() !!call da2%deallocate() !! !!da = rArgDynamicArray(3, sorted=.true.) !!call da%insertSorted(1, 20.0) !!call da%insertSorted(2, 30.0) !!call da%insertSorted(3, 10.0) !!ia = da%locationOf(20.0) !!ia = da%argOf(20.0) !!call da%insertSortedUnique(4, 10.0) !!call da%insertSortedUnique(4, 15.0) !!call da%deallocate() !! !!da = rArgDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(1, 20.0) !!call da%insertSorted(2, 30.0) !!call da%insertSorted(3, 10.0) !!ia = da%locationOf(20.0) !!ia = da%argOf(20.0) !!call da%insertSortedUnique(4, 10.0) !!call da%insertSortedUnique(4, 15.0) !!call da%deallocate() !!end program !!``` use variableKind , only : r32 , i32 use m_errors , only : msg , eMsg use m_iDynamicArray , only : iDynamicArray use m_rDynamicArray , only : rDynamicArray , insertAt__rDynamicArray use m_searching , only : intervalSearch use m_strings , only : str use m_unitTester , only : tester implicit none private public :: rArgDynamicArray_test public :: rArgDynamicArray type :: rArgDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_rArgDynamicArray]] for more information on how to use this class. type ( iDynamicArray ) :: i !! Argument of the values. type ( rDynamicArray ) :: v !! Values. contains procedure , public :: append => append_rArgDynamicArray !! rArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: argOf => argOf_rArgDynamicArray !! rArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure , public :: deallocate => deallocate_rArgDynamicArray !! rArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_rArgDynamicArray !! rArgDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_rArgDynamicArray !! rArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_rArgDynamicArray !! rArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_rArgDynamicArray !! rArgDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_rArgDynamicArray !! rArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure , public :: locationOf => locationOf_rArgDynamicArray !! rArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_rArgDynamicArray !! rArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: remove => remove_rArgDynamicArray !! rArgDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_rArgDynamicArray !! rArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type interface rArgDynamicArray procedure :: init_rArgDynamicArray_i1 , init_rArgDynamicArray_r1D end interface interface assignment ( = ) procedure :: copy_rArgDynamicArray end interface contains !====================================================================! subroutine append_rArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure rArgDynamicArray%append(). !====================================================================! class ( rArgDynamicArray ) :: this integer ( i32 ) :: i !! Index of value real ( r32 ) :: val !! Value to append call this % i % append ( i ) call this % v % append ( val ) end subroutine !====================================================================! !====================================================================! function argOf_rArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure rArgDynamicArray%locationOf(). !====================================================================! class ( rArgDynamicArray ) :: this real ( r32 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Argument of the value. integer ( i32 ) :: iSearch iSearch = this % v % locationOf ( val ) i = - 1 if ( iSearch /= - 1 ) i = this % i % values ( iSearch ) end function !====================================================================! !====================================================================! subroutine copy_rArgDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( rArgDynamicArray ), intent ( in ) :: this !! Class to copy. type ( rArgDynamicArray ), intent ( out ) :: new !! Copy of this. new % i = this % i new % v = this % v end subroutine !====================================================================! !====================================================================! subroutine deallocate_rArgDynamicArray ( this ) !! Overloaded type bound procedure rArgDynamicArray%deallocate(). !====================================================================! class ( rArgDynamicArray ) :: this call this % i % deallocate () call this % v % deallocate () end subroutine !====================================================================! !====================================================================! function init_rArgDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface [[rArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ), optional :: M logical , intent ( in ), optional :: sorted logical , intent ( in ), optional :: fixed type ( rArgDynamicArray ) :: this this % i = iDynamicArray ( M , . false ., fixed ) this % v = rDynamicArray ( M , sorted , fixed ) end function !====================================================================! !====================================================================! function init_rArgDynamicArray_r1D ( i , values , M , sorted , fixed ) result ( this ) !! Overloaded by interface [[rArgDynamicArray(type)]] !====================================================================! integer ( i32 ), intent ( in ) :: i (:) real ( r32 ), intent ( in ) :: values (:) integer ( i32 ), intent ( in ), optional :: M logical , intent ( in ), optional :: sorted logical , intent ( in ), optional :: fixed type ( rArgDynamicArray ) :: this integer ( i32 ) :: ii , iv ii = size ( i ) iv = size ( values ) if ( ii /= iv ) call eMsg ( \"rArgDynamicArray: Size of i \" // str ( ii ) // \"must equal size of values \" // str ( iv )) this % i = iDynamicArray ( i , M , . false ., fixed ) this % v = rDynamicArray ( values , M , sorted , fixed ) end function !====================================================================! !====================================================================! subroutine insertAt_rArgDynamicArray ( this , loc , i , val ) !! Overloaded type bound procedure rArgDynamicArray%insertAt(). !====================================================================! class ( rArgDynamicArray ) :: this integer ( i32 ) :: loc !! Insert index and value at this location. integer ( i32 ) :: i !! index/ real ( r32 ) :: val !! Value/ call this % i % insertAt ( loc , i ) call this % v % insertAt ( loc , val ) end subroutine !====================================================================! !====================================================================! subroutine insertSorted_rArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure rArgDynamicArray%insertSorted(). !====================================================================! class ( rArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. real ( r32 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) call this % i % insertAt ( iSearch ( 3 ), i ) call insertAt__rDynamicArray ( this % v , iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_rArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure rArgDynamicArray%insertSortedUnique(). !====================================================================! class ( rArgDynamicArray ) :: this integer ( i32 ) :: i !! Index. real ( r32 ) :: val !! Value. integer ( i32 ) :: iSearch ( 3 ) iSearch = intervalSearch ( this % v % values , val , 1 , this % v % N ) if ( iSearch ( 1 ) == - 1 ) then call this % i % insertAt ( iSearch ( 3 ), i ) call insertAt__rDynamicArray ( this % v , iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_rArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure rArgDynamicArray%isEmpty() !====================================================================! class ( rArgDynamicArray ) :: this logical :: yes !! Array is empty yes = this % v % isEmpty () end function !====================================================================! !====================================================================! function isFilled_rArgDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure rArgDynamicArray%isFilled() !====================================================================! class ( rArgDynamicArray ) :: this logical :: yes !! Array is filled yes = this % v % isFilled () end function !====================================================================! !====================================================================! function locationOf_rArgDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure rArgDynamicArray%locationOf(). !====================================================================! class ( rArgDynamicArray ) :: this real ( r32 ) :: val !! Value to get the argument of. integer ( i32 ) :: i !! Index of the value. i = this % v % locationOf ( val ) end function !====================================================================! !====================================================================! subroutine prepend_rArgDynamicArray ( this , i , val ) !! Overloaded type bound procedure rArgDynamicArray%prepend(). !====================================================================! class ( rArgDynamicArray ) :: this integer ( i32 ) :: i !! Prepend indices with this index. real ( r32 ) :: val !! Prepend values with this value. call this % i % prepend ( i ) call this % v % prepend ( val ) end subroutine !====================================================================! !====================================================================! subroutine remove_rArgDynamicArray ( this , i ) !! Overloaded type bound procedure rArgDynamicArray%remove(). !====================================================================! class ( rArgDynamicArray ) :: this integer ( i32 ) :: i !! Remove the elements at this location. call this % i % remove ( i ) call this % v % remove ( i ) end subroutine !====================================================================! !====================================================================! subroutine tighten_rArgDynamicArray ( this ) !! Overloaded type bound procedure rArgDynamicArray%tighten(). !====================================================================! class ( rArgDynamicArray ) :: this call this % i % tighten () call this % v % tighten () end subroutine !====================================================================! !====================================================================! subroutine rArgDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( rArgDynamicArray ) :: rda , rda2 integer ( i32 ) :: ia call Msg ( '==========================' ) call Msg ( 'Testing : rArgDynamic Arrays' ) call Msg ( '==========================' ) rda = rArgDynamicArray ( 10 ) call test % test ( size ( rda % v % values ) == 10 . and . size ( rda % i % values ) == 10 , 'rArgDynamicArray' ) call test % test ( rda % v % N == 0 . and . rda % i % N == 0 , 'rArgDynamicArray' ) call rda % insertAt ( 1 , 10 , 1 0.0 ) call test % test ( rda % i % values ( 1 ) == 10 . and . rda % v % values ( 1 ) == 1 0.0 , 'rArgDynamicArray%insert' ) call rda % insertAt ( 1 , 20 , 2 0.0 ) call test % test ( all ( rda % i % values ( 1 : 2 ) == [ 20 , 10 ]) . and . all ( rda % v % values ( 1 : 2 ) == [ 2 0.0 , 1 0.0 ]), 'rArgDynamicArray%insert' ) call rda % prepend ( 30 , 3 0.0 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 30 , 20 , 10 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 3 0.0 , 2 0.0 , 1 0.0 ]), 'rArgDynamicArray%prepend' ) call rda % append ( 40 , 4 0.0 ) call test % test ( all ( rda % i % values ( 1 : 4 ) == [ 30 , 20 , 10 , 40 ]) . and . all ( rda % v % values ( 1 : 4 ) == [ 3 0.0 , 2 0.0 , 1 0.0 , 4 0.0 ]), 'rArgDynamicArray%append' ) call rda % remove ( 2 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 30 , 10 , 40 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 3 0.0 , 1 0.0 , 4 0.0 ]), 'rArgDynamicArray%remove' ) call rda % tighten () call test % test ( size ( rda % i % values ) == 3 . and . size ( rda % v % values ) == 3 , 'rArgDynamicArray%tighten' ) rda2 = rda call test % test ( all ( rda2 % i % values == rda % i % values ) . and . all ( rda2 % v % values == rda % v % values ), 'rArgDynamicArray%copy' ) rda2 % v % values ( 2 ) = 5 0.0 call test % test ( rda2 % v % values ( 2 ) /= rda % v % values ( 2 ), 'rArgDynamicArray%copy' ) call rda % deallocate () call test % test (. not . allocated ( rda % i % values ) . and . . not . allocated ( rda % v % values ), 'rArgDynamicArray%deallocate' ) call rda2 % deallocate () rda = rArgDynamicArray ( 3 , sorted = . true .) call rda % insertSorted ( 1 , 2 0.0 ) call rda % insertSorted ( 2 , 3 0.0 ) call rda % insertSorted ( 3 , 1 0.0 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rArgDynamicArray%insertSorted' ) ia = rda % locationOf ( 2 0.0 ) call test % test ( ia == 2 , 'rArgDynamicArray%locationOf' ) ia = rda % argOf ( 2 0.0 ) call test % test ( ia == 1 , 'rArgDynamicArray%argOf' ) call rda % insertSortedUnique ( 4 , 1 0.0 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rArgDynamicArray%insertSortedUnique' ) call rda % insertSortedUnique ( 4 , 1 5.0 ) call test % test ( all ( rda % i % values ( 1 : 4 ) == [ 3 , 4 , 1 , 2 ]) . and . all ( rda % v % values ( 1 : 4 ) == [ 1 0.0 , 1 5.0 , 2 0.0 , 3 0.0 ]), 'rArgDynamicArray%insertSortedUnique' ) call test % test ( size ( rda % i % values ) == 6 . and . size ( rda % v % values ) == 6 , 'rArgDynamicArray%insert' ) call rda % deallocate () rda = rArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call rda % insertSorted ( 1 , 2 0.0 ) call rda % insertSorted ( 2 , 3 0.0 ) call rda % insertSorted ( 3 , 1 0.0 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rArgDynamicArray%insertSorted' ) ia = rda % locationOf ( 2 0.0 ) call test % test ( ia == 2 , 'rArgDynamicArray%locationOf' ) ia = rda % argOf ( 2 0.0 ) call test % test ( ia == 1 , 'rArgDynamicArray%argOf' ) call rda % insertSortedUnique ( 4 , 1 0.0 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 3 , 1 , 2 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rArgDynamicArray%insertSortedUnique' ) call rda % insertSortedUnique ( 4 , 1 5.0 ) call test % test ( all ( rda % i % values ( 1 : 3 ) == [ 3 , 4 , 1 ]) . and . all ( rda % v % values ( 1 : 3 ) == [ 1 0.0 , 1 5.0 , 2 0.0 ]), 'rArgDynamicArray%insertSortedUnique' ) call test % test ( size ( rda % i % values ) == 3 . and . size ( rda % v % values ) == 3 , 'rArgDynamicArray%insert' ) call rda % deallocate () end subroutine end module","loc":"sourcefile/m_rargdynamicarray.f90.html","tags":""},{"title":"m_rDynamicArray.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_rdynamicarray.f90~~EfferentGraph sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_searching.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_reallocate.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_rdynamicarrayf90EfferentGraph = svgPanZoom('#sourcefilem_rdynamicarrayf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_rdynamicarray.f90~~AfferentGraph sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_rDynamicArray Source Code m_rDynamicArray.f90 Source Code module m_rDynamicArray !! Class that act as stacks, queues, and priority queues. !! These classes use dynamically allocated contiguous blocks of memory to store a list of numbers. !! The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers. !! If the allocated memory is filled, the available space is doubled. !! Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. !! !!```fortran !!program dynamicArray_test !!use variableKind, only: i32 !!use m_rDynamicArray, only: rDynamicArray !! !!implicit none !! !!type(rDynamicArray) :: da, da2 !!integer(i32) :: ia !! !!da = rDynamicArray(10) !!call da%insertAt(1, 10.0) !!call da%insertAt(1, 20.0) !!call da%prepend(30.0) !!call da%append(40.0) !!call da%remove(2) !!call da%tighten() !!da2 = da !!da2%values(2) = 50.0 !!call da%deallocate() !!call da2%deallocate() !! !!da = rDynamicArray(3, sorted=.true.) !!call da%insertSorted(20.0) !!call da%insertSorted(30.0) !!call da%insertSorted(10.0) !!ia = da%locationOf(20.0) !!call da%insertSortedUnique(10.0) !!call da%insertSortedUnique(15.0) !!call da%deallocate() !! !!da = rDynamicArray(3, sorted=.true., fixed=.true.) !!call da%insertSorted(20.0) !!call da%insertSorted(30.0) !!call da%insertSorted(10.0) !!ia = da%locationOf(20.0) !!call da%insertSortedUnique(10.0) !!call da%insertSortedUnique(15.0) !!call da%deallocate() !!end program !!``` use variableKind , only : r32 , i32 use m_allocate , only : allocate use m_searching , only : binarySearch , intervalSearch use m_deallocate , only : deallocate use m_errors , only : eMsg , msg use m_reallocate , only : reallocate use m_sort , only : sort use m_strings , only : str use m_unitTester , only : tester implicit none private public :: rDynamicArray_test public :: rDynamicArray type :: rDynamicArray !! Class that act as stacks, queues, and priority queues. See [[m_rDynamicArray]] for more information on how to use this class. integer ( i32 ) :: N !! Current size of the array real ( r32 ), allocatable :: values (:) !! Memory for values, can be larger than N logical :: sorted = . false . !! Keep track of whether the array is sorted for potential speed increases logical :: fixed = . false . !! Don't allow the memory to change after initial instantiation. contains procedure , public :: append => append_rDynamicArray !! rDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure , public :: deallocate => deallocate_rDynamicArray !! rDynamicArray%deallocate() - Deallocate a dynamic array. procedure , public :: insertAt => insertAt_rDynamicArray !! rDynamicArray%insertAt() - Insert a value at a given index. procedure , public :: insertSorted => insertSorted_rDynamicArray !! rDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure , public :: insertSortedUnique => insertSortedUnique_rDynamicArray !! rDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure , public :: isEmpty => isEmpty_rDynamicArray !! rDynamicArray%isEmpty() - True if the array is empty. procedure , public :: isFilled => isFilled_rDynamicArray !! rDynamicArray%isFilled() - True if the array is filled. procedure , public :: locationOf => locationOf_rDynamicArray !! rDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure , public :: prepend => prepend_rDynamicArray !! rDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure , public :: reallocate => reallocate_rDynamicArray !! rDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure , public :: remove => remove_rDynamicArray !! rDynamicArray%remove() - Remove an element from the array. procedure , public :: tighten => tighten_rDynamicArray !! rDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. end type public :: insertAt__rDynamicArray interface rDynamicArray procedure :: init_rDynamicArray_i1 , init_rDynamicArray_d1D end interface interface assignment ( = ) procedure :: copy_rDynamicArray end interface contains !====================================================================! subroutine append_rDynamicArray ( this , val ) !! Overloaded type bound procedure rDynamicArray%append() !====================================================================! class ( rDynamicArray ) :: this real ( r32 ) :: val !! Value to append. if ( this % fixed . or . this % sorted ) call eMsg ( 'rDynamicArray%append: Cannot use append with fixed/sorted array.' ) call insertAt__rDynamicArray ( this , this % N + 1 , val ) ! Append at last location. end subroutine !====================================================================! !====================================================================! subroutine copy_rDynamicArray ( new , this ) !! Overloaded assignment of equals.  new = this !====================================================================! class ( rDynamicArray ), intent ( in ) :: this !! Class to copy. type ( rDynamicArray ), intent ( out ) :: new !! Copy of this. call allocate ( new % values , size ( this % values )) new % N = this % N new % values = this % values new % sorted = this % sorted new % fixed = this % fixed end subroutine !====================================================================! !====================================================================! subroutine deallocate_rDynamicArray ( this ) !! Overloaded type bound procedure rDynamicArray%deallocate() !====================================================================! class ( rDynamicArray ) :: this call deallocate ( this % values ) this % N = 0 this % sorted = . false . end subroutine !====================================================================! !====================================================================! function init_rDynamicArray_i1 ( M , sorted , fixed ) result ( this ) !! Overloaded by interface rDynamicArray() !====================================================================! integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( rDynamicArray ) :: this !! Return type. integer ( i32 ) :: M_ M_ = 1 if ( present ( M )) then if ( M < 1 ) call eMsg ( 'M must be > 0' ) M_ = M endif call allocate ( this % values , M_ ) this % N = 0 this % sorted = . false . if ( present ( sorted )) this % sorted = sorted this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! function init_rDynamicArray_d1D ( values , M , sorted , fixed ) result ( this ) !! Overloaded by interface rDynamicArray() !====================================================================! real ( r32 ), intent ( in ) :: values (:) !! Set of values to initialize with. integer ( i32 ), intent ( in ), optional :: M !! Amount of memory to allocate. logical , intent ( in ), optional :: sorted !! Maintain a sorted array. logical , intent ( in ), optional :: fixed !! Maintain a fixed size array. type ( rDynamicArray ) :: this !! Return type if ( present ( M )) then if ( M < size ( values )) call eMsg ( 'M must be >= size(values)' ) call allocate ( this % values , M ) else call allocate ( this % values , size ( values )) endif this % N = size ( values ) this % sorted = . false . if ( present ( sorted )) this % sorted = sorted if ( this % sorted ) then this % values ( 1 : this % N ) = values call sort ( this % values ( 1 : this % N )) else this % values ( 1 : this % N ) = values endif this % fixed = . false . if ( present ( fixed )) this % fixed = fixed end function !====================================================================! !====================================================================! subroutine insertAt_rDynamicArray ( this , i , val ) !! Overloaded type bound procedure rDynamicArray%insertAt() !====================================================================! class ( rDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. real ( r32 ) :: val !! Insert this value. if ( this % sorted ) call eMsg ( 'rDynamicArray%insertAt: Cannot use insertAt with sorted array' ) call insertAt__rDynamicArray ( this , i , val ) end subroutine !====================================================================! !====================================================================! subroutine insertAt__rDynamicArray ( this , i , val ) !! Private insert into array without checking for sorted flag. !====================================================================! class ( rDynamicArray ) :: this integer ( i32 ) :: i !! Insert value at this location. real ( r32 ) :: val !! Insert this value. integer :: j , N if ( i < 1 . or . i > this % N + 1 ) call Emsg ( 'rDynamicArray%insertAt: 1 <= i <= ' // str ( this % N + 1 )) N = size ( this % values ) if ( this % fixed ) then if ( i > N ) call Emsg ( 'rDynamicArray%insertAt: For fixed array, 1 <= i <= ' // str ( N )) if ( this % N < N ) this % N = this % N + 1 do j = this % N , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo else ! Expand the vector if needed if ( N < this % N + 1 ) call this % reallocate ( 2 * N ) do j = this % N + 1 , i + 1 , - 1 this % values ( j ) = this % values ( j - 1 ) enddo this % N = this % N + 1 endif this % values ( i ) = val end subroutine !====================================================================! !====================================================================! subroutine insertSorted_rDynamicArray ( this , val ) !! Overloaded type bound procedure rDynamicArray%insertSorted() !====================================================================! class ( rDynamicArray ) :: this real ( r32 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'rDynamicArray%insertSorted: Cannot use insertSorted with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) call insertAt__rDynamicArray ( this , iSearch ( 3 ), val ) end subroutine !====================================================================! !====================================================================! subroutine insertSortedUnique_rDynamicArray ( this , val ) !! Overloaded type bound procedure rDynamicArray%insertSortedUnique() !====================================================================! class ( rDynamicArray ) :: this real ( r32 ) :: val !! Insert this value. integer ( i32 ) :: iSearch ( 3 ) ! location and interval of new value if (. not . this % sorted ) call eMsg ( 'rDynamicArray%insertSortedUnique: Cannot use insertSortedUnique with unsorted dynamic array' ) iSearch = intervalSearch ( this % values , val , 1 , this % N ) if ( iSearch ( 1 ) == - 1 ) then call insertAt__rDynamicArray ( this , iSearch ( 3 ), val ) endif end subroutine !====================================================================! !====================================================================! function isEmpty_rDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure rDynamicArray%isEmpty() !====================================================================! class ( rDynamicArray ) :: this logical :: yes !! Array is empty yes = ( this % N == 0 ) end function !====================================================================! !====================================================================! function isFilled_rDynamicArray ( this ) result ( yes ) !! Overloaded type bound procedure rDynamicArray%isFilled() !====================================================================! class ( rDynamicArray ) :: this logical :: yes !! Array is filled yes = ( this % N == size ( this % values )) end function !====================================================================! !====================================================================! function locationOf_rDynamicArray ( this , val ) result ( i ) !! Overloaded type bound procedure rDynamicArray%locationOf(). !====================================================================! class ( rDynamicArray ) :: this real ( r32 ) :: val !! Get the location of this value integer ( i32 ) :: i !! Location of value if (. not . this % sorted ) call eMsg ( 'rDynamicArray%locationOf: Cannot use locationOf with unsorted dynamic array' ) i = binarySearch ( this % values , val , 1 , this % N ) end function !====================================================================! !====================================================================! subroutine prepend_rDynamicArray ( this , val ) !! Overloaded type bound procedure rDynamicArray%prepend() !====================================================================! class ( rDynamicArray ) :: this real ( r32 ) :: val !! Value to prepend. if ( this % fixed . or . this % sorted ) call eMsg ( 'rDynamicArray%prepend: Cannot use prepend with fixed/sorted array.' ) call insertAt__rDynamicArray ( this , 1 , val ) end subroutine !====================================================================! !====================================================================! subroutine reallocate_rDynamicArray ( this , M ) !! Overloaded type bound procedure rDynamicArray%reallocate(). !====================================================================! class ( rDynamicArray ) :: this integer ( i32 ) :: M !! Reallocate memory to this size. call reallocate ( this % values , M ) end subroutine !====================================================================! !====================================================================! subroutine remove_rDynamicArray ( this , i ) !! Overloaded type bound procedure rDynamicArray%remove(). !====================================================================! class ( rDynamicArray ) :: this integer ( i32 ) :: i !! Remove the value at this location. integer ( i32 ) :: j if ( i < 1 . or . i > this % N ) call Emsg ( 'rDynamic%remove: 1 <= i <= ' // str ( this % N )) do j = i , this % N - 1 this % values ( j ) = this % values ( j + 1 ) enddo this % N = this % N - 1 if (. not . this % fixed ) then if ( this % N < size ( this % values ) / 4 ) call this % reallocate ( this % N ) endif end subroutine !====================================================================! !====================================================================! subroutine tighten_rDynamicArray ( this ) !! Overloaded type bound procedure rDynamicArray%tighten(). !====================================================================! class ( rDynamicArray ) :: this if ( this % fixed ) call eMsg ( 'rDynamicArray%tighten: Cannot use tighten with fixed array.' ) call this % reallocate ( this % N ) end subroutine !====================================================================! !====================================================================! subroutine rDynamicArray_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test type ( rDynamicArray ) :: da , da2 integer ( i32 ) :: ia call Msg ( '==========================' ) call Msg ( 'Testing : Dynamic Arrays' ) call Msg ( '==========================' ) da = rDynamicArray ( 10 ) call test % test ( size ( da % values ) == 10 , 'rDynamicArray' ) call test % test ( da % N == 0 , 'rDynamicArray' ) call da % insertAt ( 1 , 1 0.0 ) call test % test ( da % values ( 1 ) == 10 , 'rDynamicArray%insert' ) call da % insertAt ( 1 , 2 0.0 ) call test % test ( all ( da % values ( 1 : 2 ) == [ 2 0.0 , 1 0.0 ]), 'rDynamicArray%insert' ) call da % prepend ( 3 0.0 ) call test % test ( all ( da % values ( 1 : 3 ) == [ 3 0.0 , 2 0.0 , 1 0.0 ]), 'rDynamicArray%prepend' ) call da % append ( 4 0.0 ) call test % test ( all ( da % values ( 1 : 4 ) == [ 3 0.0 , 2 0.0 , 1 0.0 , 4 0.0 ]), 'rDynamicArray%append' ) call da % remove ( 2 ) call test % test ( all ( da % values ( 1 : 3 ) == [ 3 0.0 , 1 0.0 , 4 0.0 ]), 'rDynamicArray%remove' ) call da % tighten () call test % test ( size ( da % values ) == 3 , 'rDynamicArray%tighten' ) da2 = da call test % test ( all ( da2 % values == da % values ), 'rDynamicArray%copy' ) da2 % values ( 2 ) = 5 0.0 call test % test ( da2 % values ( 2 ) /= da % values ( 2 ), 'rDynamicArray%copy' ) call da % deallocate () call test % test (. not . allocated ( da % values ), 'rDynamicArray%deallocate' ) call da2 % deallocate () da = rDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 2 0.0 ) call da % insertSorted ( 3 0.0 ) call da % insertSorted ( 1 0.0 ) call test % test ( all ( da % values == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rDynamicArray%insertSorted' ) ia = da % locationOf ( 2 0.0 ) call test % test ( ia == 2 , 'rDynamicArray%locationOf' ) call da % insertSortedUnique ( 1 0.0 ) call test % test ( all ( da % values == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rDynamicArray%insertSortedUnique' ) call da % insertSortedUnique ( 1 5.0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.0 , 1 5.0 , 2 0.0 , 3 0.0 ]), 'rDynamicArray%insertSortedUnique' ) call test % test ( size ( da % values ) == 6 , 'rDynamicArray%insert' ) call da % deallocate () da = rDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 2 0.0 ) call da % insertSorted ( 3 0.0 ) call da % insertSorted ( 1 0.0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rDynamicArray%insertSorted' ) ia = da % locationOf ( 2 0.0 ) call test % test ( ia == 2 , 'rDynamicArray%locationOf' ) call da % insertSortedUnique ( 1 0.0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.0 , 2 0.0 , 3 0.0 ]), 'rDynamicArray%insertSortedUnique' ) call da % insertSortedUnique ( 1 5.0 ) call test % test ( all ( da % values ( 1 : da % N ) == [ 1 0.0 , 1 5.0 , 2 0.0 ]), 'rDynamicArray%insertSortedUnique' ) call test % test ( size ( da % values ) == 3 , 'rDynamicArray%insert' ) call da % deallocate () end subroutine end module","loc":"sourcefile/m_rdynamicarray.f90.html","tags":""},{"title":"m_maths.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_maths.f90~~EfferentGraph sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_maths.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_errors.f90->sourcefile~m_select.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_maths.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_maths.f90 sourcefile~m_deallocate.f90->sourcefile~m_select.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_unittester.f90->sourcefile~m_maths.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_select.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_maths.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_select.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_mathsf90EfferentGraph = svgPanZoom('#sourcefilem_mathsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_maths.f90~~AfferentGraph sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_maths Source Code m_maths.f90 Source Code module m_maths !! Math routines use variableKind use m_allocate , only : allocate use m_deallocate , only : deallocate use m_errors , only : eMsg , msg use m_sort , only : argsort use m_select , only : argSelect use m_array1D , only : arange use m_unitTester , only : tester implicit none private public :: maths_test public :: crossproduct interface crossproduct !! Compute the cross product between two arrays of length 2 or 3 module function crossproduct_r1D ( a , b ) result ( res ) !! Interfaced with crossproduct() real ( r32 ), intent ( in ) :: a ( 3 ) !! 1D Array real ( r32 ), intent ( in ) :: b ( 3 ) !! 1D Array real ( r32 ) :: res ( 3 ) !! cross product end function module function crossproduct_d1D ( a , b ) result ( res ) !! Interfaced with crossproduct() real ( r64 ), intent ( in ) :: a ( 3 ) !! 1D Array real ( r64 ), intent ( in ) :: b ( 3 ) !! 1D Array real ( r64 ) :: res ( 3 ) !! cross product end function end interface public :: cumprod interface cumprod !! Compute the variance of an array module function cumprod_r1D ( this ) result ( res ) !! Interfaced with cumprod() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res ( size ( this )) !! Cumulative product end function module function cumprod_d1D ( this ) result ( res ) !! Interfaced with cumprod() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res ( size ( this )) !! Cumulative product end function module function cumprod_i1D ( this ) result ( res ) !! Interfaced with cumprod() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res ( size ( this )) !! Cumulative product end function module function cumprod_id1D ( this ) result ( res ) !! Interfaced with cumprod() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res ( size ( this )) !! Cumulative product end function end interface public :: cumsum interface cumsum !! Compute the variance of an array module function cumsum_r1D ( this ) result ( res ) !! Interfaced with cumsum() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res ( size ( this )) !! Cumulative sum end function module function cumsum_d1D ( this ) result ( res ) !! Interfaced with cumsum() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res ( size ( this )) !! Cumulative sum end function module function cumsum_i1D ( this ) result ( res ) !! Interfaced with cumsum() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res ( size ( this )) !! Cumulative sum end function module function cumsum_id1D ( this ) result ( res ) !! Interfaced with cumsum() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res ( size ( this )) !! Cumulative sum end function end interface public :: fastTwoDiff interface fastTwoDiff !! Compute the difference two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoDiff routine module function fastTwoDiff_r ( a , b ) result ( res ) !! Interfaced with fastTwoDiff() real ( r32 ), intent ( in ) :: a !! First number real ( r32 ), intent ( in ) :: b !! Second number real ( r32 ) :: res ( 2 ) !! Result and its error end function module function fastTwoDiff_d ( a , b ) result ( res ) !! Interfaced with fastTwoDiff() real ( r64 ), intent ( in ) :: a !! First number real ( r64 ), intent ( in ) :: b !! Second number real ( r64 ) :: res ( 2 ) !! Result and its error end function end interface public :: fastTwoSum interface fastTwoSum !! Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoSum routine module function fastTwoSum_r ( a , b ) result ( res ) !! Interfaced with fastTwoSum() real ( r32 ), intent ( in ) :: a !! First number real ( r32 ), intent ( in ) :: b !! Second number real ( r32 ) :: res ( 2 ) !! Result and its error end function module function fastTwoSum_d ( a , b ) result ( res ) !! Interfaced with fastTwoSum() real ( r64 ), intent ( in ) :: a !! First number real ( r64 ), intent ( in ) :: b !! Second number real ( r64 ) :: res ( 2 ) !! Result and its error end function end interface public :: geometricMean interface geometricMean !! Compute the geometric mean of a vector module function geometricMean_r1D ( this ) result ( res ) !! Interfaced with geometricMean() real ( r32 ), intent ( in ) :: this (:) real ( r64 ) :: res end function module function geometricMean_d1D ( this ) result ( res ) !! Interfaced with geometricMean() real ( r64 ), intent ( in ) :: this (:) real ( r64 ) :: res end function module function geometricMean_i1D ( this ) result ( res ) !! Interfaced with geometricMean() integer ( i32 ), intent ( in ) :: this (:) real ( r64 ) :: res end function module function geometricMean_id1D ( this ) result ( res ) !! Interfaced with geometricMean() integer ( i64 ), intent ( in ) :: this (:) real ( r64 ) :: res end function end interface public :: mean interface mean !! Compute the mean module function mean_r1D ( this ) result ( res ) !! Interfaced with mean() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function module function mean_d1D ( this ) result ( res ) !! Interfaced with mean() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function module function mean_i1D ( this ) result ( res ) !! Interfaced with mean() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function module function mean_id1D ( this ) result ( res ) !! Interfaced with mean() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! mean end function end interface public :: median interface median !! Compute the median of a set of numbers module function median_r1D ( this ) result ( res ) !! Interfaced with median() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res !! median end function module function median_d1D ( this ) result ( res ) !! Interfaced with median() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! median end function module function median_i1D ( this ) result ( res ) !! Interfaced with median() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! median end function module function median_id1D ( this ) result ( res ) !! Interfaced with median() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! median end function end interface public :: norm1 interface norm1 !! Compute the L1 norm of a set of numbers module function norm1_r1D ( this ) result ( res ) !! Interfaced with norm1() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res !! L1 norm end function module function norm1_d1D ( this ) result ( res ) !! Interfaced with norm1() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! L1 norm end function module function norm1_i1D ( this ) result ( res ) !! Interfaced with norm1() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! L1 norm end function module function norm1_id1D ( this ) result ( res ) !! Interfaced with norm1() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! L1 norm end function end interface public :: normI interface normI !! Compute the Linfinity norm of a set of numbers module function normI_r1D ( this ) result ( res ) !! Interfaced with normI() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ) :: res !! Linfinity norm end function module function normI_d1D ( this ) result ( res ) !! Interfaced with normI() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! Linfinity norm end function module function normI_i1D ( this ) result ( res ) !! Interfaced with normI() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ) :: res !! Linfinity norm end function module function normI_id1D ( this ) result ( res ) !! Interfaced with normI() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i64 ) :: res !! Linfinity norm end function end interface public :: project interface project !! Project a vector a onto vector b module function project_r1D ( a , b ) result ( c ) !! Interfaced with project() real ( r32 ), intent ( in ) :: a (:) !! 1D array real ( r32 ), intent ( in ) :: b ( size ( a )) !! 1D array real ( r32 ) :: c ( size ( a )) !! 1D array end function module function project_d1D ( a , b ) result ( c ) !! Interfaced with project() real ( r64 ), intent ( in ) :: a (:) !! 1D array real ( r64 ), intent ( in ) :: b ( size ( a )) !! 1D array real ( r64 ) :: c ( size ( a )) !! 1D array end function end interface public :: trimmedmean interface trimmedmean !! Compute the Trimmed mean of an array,  alpha is a percent value to trim from either end module function trimmedmean_r1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r32 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function module function trimmedmean_d1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function module function trimmedmean_i1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function module function trimmedmean_id1D ( this , alpha ) result ( res ) !! Interfaced with trimmedmean() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ), intent ( in ) :: alpha !! Percentage to trim off each end real ( r64 ) :: res !! trimmedmean end function end interface public :: twoDiff interface twoDiff !! Compute the difference between two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! If you know that the magnitude of a is greater than or equal to b, use fastTwoDiff module function twoDiff_r ( a , b ) result ( res ) !! Interfaced with twoDiff() real ( r32 ), intent ( in ) :: a !! First number real ( r32 ), intent ( in ) :: b !! Second number real ( r32 ) :: res ( 2 ) !! Result and its error end function module function twoDiff_d ( a , b ) result ( res ) !! Interfaced with twoDiff() real ( r64 ), intent ( in ) :: a !! First number real ( r64 ), intent ( in ) :: b !! Second number real ( r64 ) :: res ( 2 ) !! Result and its error end function end interface public :: twoSum interface twoSum !! Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates !! If you know that the magnitude of a is greater than or equal to b, use fastTwoSum module function twoSum_r ( a , b ) result ( res ) !! Interfaced with twoSum() real ( r32 ), intent ( in ) :: a !! First number in sum real ( r32 ), intent ( in ) :: b !! Second number in sum real ( r32 ) :: res ( 2 ) !! The sum and its error end function module function twoSum_d ( a , b ) result ( res ) !! Interfaced with twoSum() real ( r64 ), intent ( in ) :: a !! First number in sum real ( r64 ), intent ( in ) :: b !! Second number in sum real ( r64 ) :: res ( 2 ) !! The sum and its error end function end interface public :: std interface std !! Compute the standard deviation of an array module function std_r1D ( this ) result ( res ) !! Interfaced with std() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function module function std_d1D ( this ) result ( res ) !! Interfaced with std() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function module function std_i1D ( this ) result ( res ) !! Interfaced with std() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function module function std_id1D ( this ) result ( res ) !! Interfaced with std() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! standard deviation end function end interface public :: variance interface variance !! Compute the variance of an array module function variance_r1D ( this ) result ( res ) !! Interfaced with variance() real ( r32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function module function variance_d1D ( this ) result ( res ) !! Interfaced with variance() real ( r64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function module function variance_i1D ( this ) result ( res ) !! Interfaced with variance() integer ( i32 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function module function variance_id1D ( this ) result ( res ) !! Interfaced with variance() integer ( i64 ), intent ( in ) :: this (:) !! 1D array real ( r64 ) :: res !! variance end function end interface contains !====================================================================! subroutine maths_test ( test ) !! graph: false !====================================================================! class ( tester ) :: test real ( r32 ) :: ar , br real ( r32 ), allocatable :: ar1D (:), br1D (:), cr1D (:) real ( r64 ) :: a , b real ( r64 ), allocatable :: a1D (:), b1D (:), c1D (:) integer ( i32 ) :: ia , ib , ic integer ( i32 ), allocatable :: ia1D (:), ib1D (:) integer ( i64 ) :: iad integer ( i64 ), allocatable :: iad1D (:), ibd1D (:) call Msg ( '==========================' ) call Msg ( 'Testing : Maths' ) call Msg ( '==========================' ) call allocate ( ar1D , 3 ) call allocate ( a1D , 3 ) call allocate ( ia1D , 3 ) call allocate ( iad1D , 3 ) call allocate ( br1D , 2 ) call allocate ( b1D , 2 ) call allocate ( ib1D , 2 ) call allocate ( ibd1D , 2 ) call arange ( ar1D , 1.0 , 3.0 , 1.0 ) call arange ( a1D , 1.d0 , 3.d0 , 1.d0 ) call arange ( ia1D , 1 , 3 , 1 ) call arange ( iad1D , 1_i64 , 3_i64 , 1_i64 ) br1D = [ 5.0 , 6.0 , 7.0 ] b1D = [ 5.d0 , 6.d0 , 7.d0 ] ib1D = [ 5 , 6 , 7 ] ibd1D = [ 5_i64 , 6_i64 , 7_i64 ] cr1D = crossproduct ( ar1D , br1D ) call test % test ( all ( cr1D == [ - 4.0 , 8.0 , - 4.0 ]), 'crossproduct_r1D' ) c1D = crossproduct ( a1D , b1D ) call test % test ( all ( cr1D == [ - 4.d0 , 8.d0 , - 4.d0 ]), 'crossproduct_d1D' ) cr1D = cumprod ( ar1D ) call test % test ( all ( cr1D == [ 1.0 , 2.0 , 6.0 ]), 'cumprod_r1D' ) c1D = cumprod ( a1D ) call test % test ( all ( c1D == [ 1.d0 , 2.d0 , 6.d0 ]), 'cumprod_d1D' ) ib1D = cumprod ( ia1D ) call test % test ( all ( ib1D == [ 1 , 2 , 6 ]), 'cumprod_i1D' ) ibd1D = cumprod ( iad1D ) call test % test ( all ( ibd1D == [ 1 , 2 , 6 ]), 'cumprod_id1D' ) cr1D = cumsum ( ar1D ) call test % test ( all ( cr1D == [ 1.0 , 3.0 , 6.0 ]), 'cumsum_r1D' ) c1D = cumsum ( a1D ) call test % test ( all ( c1D == [ 1.d0 , 3.d0 , 6.d0 ]), 'cumsum_d1D' ) ib1D = cumsum ( ia1D ) call test % test ( all ( ib1D == [ 1 , 3 , 6 ]), 'cumsum_i1D' ) ibd1D = cumsum ( iad1D ) call test % test ( all ( ibd1D == [ 1 , 3 , 6 ]), 'cumsum_id1D' ) ar1D = [ 1.0 , 2.0 , 3.0 ] br1D = [ 0.0 , 0.5 , 0.0 ] a1D = [ 1.d0 , 2.d0 , 3.d0 ] b1D = [ 0.d0 , 0.5d0 , 0.d0 ] cr1D = project ( ar1D , br1D ) call test % test ( all ( cr1D == [ 0.0 , 2.0 , 0.0 ]), 'project_r1D' ) c1D = project ( a1D , b1D ) call test % test ( all ( c1D == [ 0.d0 , 2.d0 , 0.d0 ]), 'project_d1D' ) a = mean ( ar1D ) call test % test ( a == 2.d0 , 'mean_r1D' ) a = mean ( a1D ) call test % test ( a == 2.d0 , 'mean_d1D' ) a = mean ( ia1D ) call test % test ( a == 2.d0 , 'mean_i1D' ) a = mean ( iad1D ) call test % test ( a == 2.d0 , 'mean_id1D' ) a = norm1 ( ar1D ) call test % test ( a == 6.d0 , 'norm1_r1D' ) a = norm1 ( a1D ) call test % test ( a == 6.d0 , 'norm1_d1D' ) a = norm1 ( a1D ) call test % test ( a == 6.d0 , 'norm1_i1D' ) a = norm1 ( a1D ) call test % test ( a == 6.d0 , 'norm1_id1D' ) ar = normI ( ar1D ) call test % test ( ar == 3.0 , 'normI_r1D' ) a = normI ( a1D ) call test % test ( a == 3.d0 , 'normI_d1D' ) ia = normI ( ia1D ) call test % test ( a == 3 , 'normI_i1D' ) iad = normI ( iad1D ) call test % test ( a == 3 , 'normI_id1D' ) a = geometricMean ( ar1D ) call test % test ( a == 21 6.d0 , 'geometricMean_r1D' ) a = geometricMean ( a1D ) call test % test ( a == 21 6.d0 , 'geometricMean_d1D' ) a = geometricMean ( ia1D ) call test % test ( a == 21 6.d0 , 'geometricMean_i1D' ) a = geometricMean ( iad1D ) call test % test ( a == 21 6.d0 , 'geometricMean_id1D' ) call allocate ( a1D , 2 ) call allocate ( ar1D , 2 ) ar = 0.2 br = 0.1 a = 0.2d0 b = 0.1d0 ar1D = twoSum ( ar , br ) call test % test ( abs ( ar1D ( 2 )) < 1.d-7 , 'twoSum_r' ) a1D = twoSum ( a , b ) call test % test ( abs ( a1D ( 2 )) < 1.d-15 , 'twoSum_d' ) ar1D = fastTwoSum ( ar , br ) call test % test ( abs ( ar1D ( 2 )) < 1.d-7 , 'fastTwoSum_r' ) a1D = fastTwoSum ( a , b ) call test % test ( abs ( a1D ( 2 )) < 1.d-15 , 'fastTwoSum_d' ) ar1D = [ 1.0 , 2.0 , 3.0 ] br1D = [ 0.0 , 0.5 , 0.0 ] a1D = [ 1.d0 , 2.d0 , 3.d0 ] b1D = [ 0.d0 , 0.5d0 , 0.d0 ] a = std ( ar1D ) call test % test ( a == 1.d0 , 'std_r1D' ) a = std ( a1D ) call test % test ( a == 1.d0 , 'std_d1D' ) a = std ( ia1D ) call test % test ( a == 1.d0 , 'std_i1D' ) a = std ( iad1D ) call test % test ( a == 1.d0 , 'std_id1D' ) a = variance ( ar1D ) call test % test ( a == 1.d0 , 'variance_r1D' ) a = variance ( a1D ) call test % test ( a == 1.d0 , 'variance_d1D' ) a = variance ( ia1D ) call test % test ( a == 1.d0 , 'variance_i1D' ) a = variance ( iad1D ) call test % test ( a == 1.d0 , 'variance_id1D' ) a = median ( ar1D ) call test % test ( a == 2.d0 , 'median_r1D' ) a = median ( a1D ) call test % test ( a == 2.d0 , 'median_d1D' ) a = median ( ia1D ) call test % test ( a == 2.d0 , 'median_i1D' ) a = median ( iad1D ) call test % test ( a == 2.d0 , 'median_id1D' ) call deallocate ( ar1D ) call deallocate ( a1D ) call deallocate ( ia1D ) call deallocate ( iad1D ) call deallocate ( br1D ) call deallocate ( b1D ) call deallocate ( ib1D ) call deallocate ( ibd1D ) call deallocate ( cr1D ) call deallocate ( c1D ) end subroutine end module","loc":"sourcefile/m_maths.f90.html","tags":""},{"title":"m_random.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_random.f90~~EfferentGraph sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_randomf90EfferentGraph = svgPanZoom('#sourcefilem_randomf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_random.f90~~AfferentGraph sourcefile~m_random.f90 m_random.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_random Source Code m_random.f90 Source Code module m_random !! Routines for random number generation.  The original code is provided via Netlib at http://www.netlib.org/random/random.f90 ! Original Version ! Author: Alan Miller ! Updated version: ! Version 2.00, 11 November 2016 ! Increased precision to double ! Added seed setters ! Added overloaded operations for single number, nD arrays !     Author: Leon Foks use variableKind use m_allocate , only : allocate use m_deallocate , only : deallocate use m_errors , only : eMsg , mErr , msg use m_strings , only : printOptions , str use iso_fortran_env , only : output_unit use m_array1D , only : arange use m_unitTester , only : tester implicit none private public :: random_test real ( r64 ), parameter , private :: zero = 0.d0 , half = 0.5d0 , one = 1.d0 , two = 2.d0 real ( r64 ), parameter , private :: vsmall = TINY ( 1.d0 ), vlarge = HUGE ( 1.d0 ) public :: setRNG interface setRNG !! Sets the random number with or without a seed module procedure :: setRNG_Wseed , setRNG_WOseed end interface public rngChisq interface rngChisq !! Pull from a Chi Ssquared distribution !! !! Example !!```fortran !!program Chisq_test !!use variableKind, only: r64 !!use m_allocate, only: allocate !!use m_random, only: rngChiSq !!implicit none !!real(r64), allocatable :: a !!call allocate(a, 10000) !!call rngChiSq(a, ) !!end program !!``` !====================================================================! module subroutine rngChisq_d1 ( this , ndf , first ) !! Interfaced with [[rngChiSq]] !====================================================================! ! Generates a random variate from the chi-squared distribution with ! ndf degrees of freedom real ( r64 ) :: this INTEGER , INTENT ( IN ) :: ndf LOGICAL , INTENT ( IN ) :: first END subroutine !====================================================================! !====================================================================! module subroutine rngChisq_d1D ( this , ndf , first ) !! Interfaced with [[rngChiSq]] !====================================================================! real ( r64 ) :: this (:) INTEGER , INTENT ( IN ) :: ndf LOGICAL , INTENT ( IN ) :: first end subroutine !====================================================================! end interface public :: rngExponential interface rngExponential !====================================================================! module subroutine rngExponential_d1 ( this ) !! Interfaced with [[rngExponential]] !====================================================================! real ( r64 ) :: this !! Random number end subroutine !====================================================================! !====================================================================! module subroutine rngExponential_d1D ( this ) !! Interfaced with [[rngExponential]] !====================================================================! real ( r64 ) :: this (:) !! Random numbers end subroutine !====================================================================! end interface public :: rngGamma interface rngGamma !====================================================================! module subroutine rngGamma_d1D ( this , s , first ) !! Interfaced with [[rngGamma]] !====================================================================! real ( r64 ) :: this (:) real ( r64 ), INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first end subroutine !====================================================================! !====================================================================! module subroutine rngGamma_d1 ( this , s , first ) !! Interfaced with [[rngGamma]] !====================================================================! real ( r64 ) :: this real ( r64 ), INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first END subroutine !====================================================================! end interface public :: rngInteger interface rngInteger !! Generate size(this) random integers starting from imin !====================================================================! module subroutine rngInteger_i1 ( this , imin , imax ) !! Interfaced with [[rngInteger]] !====================================================================! integer ( i32 ), intent ( inout ) :: this integer ( i32 ), intent ( in ) :: imin integer ( i32 ), intent ( in ) :: imax end subroutine !====================================================================! !====================================================================! module subroutine rngInteger_i1D ( this , imin , imax ) !! Interfaced with [[rngInteger]] !====================================================================! integer ( i32 ), intent ( inout ) :: this (:) integer ( i32 ), intent ( in ) :: imin integer ( i32 ), intent ( in ) :: imax end subroutine !====================================================================! !====================================================================! module subroutine rngInteger_i2D ( this , imin , imax ) !! Interfaced with [[rngInteger]] !====================================================================! integer ( i32 ), intent ( inout ) :: this (:,:) integer ( i32 ), intent ( in ) :: imin integer ( i32 ), intent ( in ) :: imax end subroutine !====================================================================! !====================================================================! module subroutine rngInteger_i3D ( this , imin , imax ) !! Interfaced with [[rngInteger]] !====================================================================! integer ( i32 ), intent ( inout ) :: this (:,:,:) integer ( i32 ), intent ( in ) :: imin integer ( i32 ), intent ( in ) :: imax end subroutine !====================================================================! !====================================================================! module subroutine rngInteger_i1D_i1 ( this , imin ) !! Interfaced with [[rngInteger]] !====================================================================! integer ( i32 ), intent ( inout ) :: this (:) integer ( i32 ), intent ( in ) :: imin end subroutine !====================================================================! end interface public :: rngNormal interface rngNormal !====================================================================! module subroutine rngNormal_d1 ( this , mean , std ) !! Interfaced with [[rngNormal]] !====================================================================! real ( r64 ), intent ( inout ) :: this real ( r64 ), intent ( in ), optional :: mean , std end subroutine !====================================================================! !====================================================================! module subroutine rngNormal_d1D ( this , mean , std ) !! Interfaced with [[rngNormal]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:) real ( r64 ), optional , intent ( in ) :: mean , std end subroutine !====================================================================! !====================================================================! module subroutine rngNormal_d2D ( this , mean , std ) !! Interfaced with [[rngNormal]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:,:) real ( r64 ), optional , intent ( in ) :: mean , std end subroutine !====================================================================! !====================================================================! module subroutine rngNormal_d3D ( this , mean , std ) !! Interfaced with [[rngNormal]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:,:,:) real ( r64 ), optional , intent ( in ) :: mean , std end subroutine !====================================================================! end interface public shuffle interface shuffle !! Perform Knuth shuffling on an array !====================================================================! module subroutine shuffle_r1D ( this ) !! Interfaced with [[shuffle]] !====================================================================! !! Interfaced with shuffle() real ( r32 ), intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine shuffle_d1D ( this ) !! Interfaced with [[shuffle]] !====================================================================! !! Interfaced with shuffle() real ( r64 ), intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine shuffle_i1D ( this ) !! Interfaced with [[shuffle]] !====================================================================! !! Interfaced with shuffle() integer ( i32 ), intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! !====================================================================! module subroutine shuffle_id1D ( this ) !! Interfaced with [[shuffle]] !====================================================================! !! Interfaced with shuffle() integer ( i64 ), intent ( inout ) :: this (:) !! 1D array end subroutine !====================================================================! end interface public :: rngUniform interface rngUniform !====================================================================! module subroutine rngUniform_d1 ( this , rmin , rmax ) !! Interfaced with [[rngUniform]] !====================================================================! real ( r64 ), intent ( inout ) :: this real ( r64 ), intent ( in ), optional :: rmin , rmax end subroutine !====================================================================! !====================================================================! module subroutine rngUniform_d1D ( this , rmin , rmax ) !! Interfaced with [[rngUniform]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:) real ( r64 ), optional , intent ( in ) :: rmin , rmax end subroutine !====================================================================! !====================================================================! module subroutine rngUniform_d2D ( this , rmin , rmax ) !! Interfaced with [[rngUniform]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:,:) real ( r64 ), optional , intent ( in ) :: rmin , rmax end subroutine !====================================================================! !====================================================================! module subroutine rngUniform_d3D ( this , rmin , rmax ) !! Interfaced with [[rngUniform]] !====================================================================! real ( r64 ), intent ( inout ) :: this (:,:,:) real ( r64 ), optional , intent ( in ) :: rmin , rmax end subroutine !====================================================================! end interface public :: rngWeibull interface rngWeibull !====================================================================! module subroutine rngWeibull_d1 ( this , den ) !! Interfaced with [[rngWeibull]] !====================================================================! !     Generates a random variate from the Weibull distribution with !     probability density real ( r64 ) :: this !! Random number real ( r64 ), intent ( in ) :: den !! Weibull probability density end subroutine !====================================================================! !====================================================================! module subroutine rngWeibull_d1D ( this , den ) !! Interfaced with [[rngWeibull]] !====================================================================! real ( r64 ) :: this (:) !! Random numbers real ( r64 ), intent ( in ) :: den !! Weibull probability density end subroutine !====================================================================! end interface logical , protected :: isInitialized = . false . contains !====================================================================! subroutine setRNG_Wseed ( seed ) !! Interfaced to setRNG() !! Sets the seed of the random number generator with a specified seed !====================================================================! integer :: seed (:) integer :: n if ( isInitialized ) return call random_seed ( size = n ) if ( size ( seed ) /= n ) call Emsg ( 'setRNG : Seed muse be size ' // str ( n )) call random_seed ( put = seed ) isInitialized = . true . end subroutine !====================================================================! !====================================================================! subroutine setRNG_WOseed ( display ) !! Interfaced to setRNG() !! 'Randomly' sets the seed of the random number generator !====================================================================! integer , allocatable :: seed (:) integer :: n , istat logical :: display if ( isInitialized ) return call random_seed ( size = n ) allocate ( seed ( n ), stat = istat ); call Merr ( istat , 'setRNG : Seed' , 1 ) call randomizeSeed ( seed ) call random_seed ( put = seed ) if ( display ) then istat = printOptions % threshold printOptions % threshold = 0 write ( output_unit , '(a)' ) 'Random Seed: ' // str ( seed ) printOptions % threshold = istat end if isInitialized = . true . end subroutine !====================================================================! !====================================================================! subroutine randomizeSeed ( seed ) !! Randomizes the seed for the random number generator !====================================================================! integer ( i32 ) :: seed (:) integer ( i32 ) :: i , n , un , istat , dt ( 8 ) integer ( i64 ) :: t n = size ( seed ) if ( size ( seed ) /= n ) call Emsg ( 'setRNG : Seed muse be size ' // str ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then read ( un ) seed close ( un ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_i64 * 86400000 & + dt ( 2 ) * 31_i64 * 86400000 & + dt ( 3 ) * 86400000 & + dt ( 5 ) * 3600000 & + dt ( 6 ) * 60000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if ! Getpid is a Gnu function.  Intel must use ifport, but the integer is only int*4 :( !pid = getpid() !t = ieor(t, int(pid, kind(t))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if contains !====================================================================! !====================================================================! function lcg ( s ) result ( res ) !! This simple PRNG might not be good enough for real work, but is !! sufficient for seeding a better PRNG. !====================================================================! integer ( i32 ) :: res integer ( i64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_i64 ) end if s = mod ( s * 279470273_i64 , 4294967291_i64 ) res = int ( mod ( s , int ( huge ( 0 ), i64 )), kind ( 0 )) end function end subroutine !====================================================================! !====================================================================! subroutine random_test ( test , fixedSeed ) !! graph: false !====================================================================! class ( tester ) :: test logical :: fixedSeed integer ( i32 ) :: ia integer ( i32 ), allocatable :: ia1D (:) real ( r64 ) :: a , a1D ( 10 ), a2D ( 10 , 10 ) character ( len = :), allocatable :: cTest call Msg ( '==========================' ) call Msg ( 'Testing : Random' ) call Msg ( '==========================' ) ! !  write(*,1) 'Setting the random seed' ! if ( fixedSeed ) then call random_seed ( size = ia ) call allocate ( ia1D , ia ) !ia1D = [-370590921, -2121812073] ia1D = [ - 330169315 , - 420956545 ] call setRNG ( ia1D ) else call setRNG (. true .) endif !  !call setRNG([546420601, 1302718556, 802583095, 136684118, 1163051410, 592779069, 660876855, 767615536, 1788597594, 775517554, 657867655, 1334969129]) call allocate ( ia1D , 3 ) ia = 1 call rngInteger ( ia1D , ia ) write ( * , 1 ) 'Random integers' write ( * , 1 ) str ( ia1D ) call rngNormal ( a ) write ( * , 1 ) 'Dble random number' write ( * , 1 ) str ( a ) call rngNormal ( a1D ) write ( * , 1 ) '~N(mean=0.0,std=1.0)' write ( * , 1 ) str ( a1D ) call rngNormal ( a1D , 1.d0 , 5.d0 ) write ( * , 1 ) '~N(mean=1.0,std=5.0) 1D array' write ( * , 1 ) str ( a1D ) a2D = 0.d0 call rngNormal ( a2D , 5 0.d0 , 1 0.d0 ) write ( * , 1 ) '~N(mean=50.0,std=10.0) 2D array reduced output' cTest = str ( a2D ) write ( * , 1 ) cTest 1 format ( a ) end subroutine !====================================================================! !====================================================================! ! EXTRA CODES TO BE TRANSLATED LATER!!! !====================================================================! ! ! !  FUNCTION random_beta(aa, bb, first) RESULT(fn_val) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM VARIATE IN [0,1] !! FROM A BETA DISTRIBUTION WITH DENSITY !! PROPORTIONAL TO BETA**(AA-1) * (1-BETA)**(BB-1). !! USING CHENG'S LOG LOGISTIC METHOD. ! !!     AA = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) !!     BB = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) ! !REAL, INTENT(IN)    :: aa, bb !LOGICAL, INTENT(IN) :: first !REAL                :: fn_val ! !!     Local variables !REAL, PARAMETER  :: aln4 = 1.3862944 !REAL             :: a, b, g, r, s, x, y, z !REAL, SAVE       :: d, f, h, t, c !LOGICAL, SAVE    :: swap ! !IF (aa <= zero .OR. bb <= zero) THEN !  WRITE(*, *) 'IMPERMISSIBLE SHAPE PARAMETER VALUE(S)' !  STOP !END IF ! !IF (first) THEN                        ! Initialization, if necessary !  a = aa !  b = bb !  swap = b > a !  IF (swap) THEN !    g = b !    b = a !    a = g !  END IF !  d = a/b !  f = a+b !  IF (b > one) THEN !    h = SQRT((two*a*b - f)/(f - two)) !    t = one !  ELSE !    h = b !    t = one/(one + (a/(vlarge*b))**b) !  END IF !  c = a+h !END IF ! !DO !  CALL RANDOM_NUMBER(r) !  CALL RANDOM_NUMBER(x) !  s = r*r*x !  IF (r < vsmall .OR. s <= zero) CYCLE !  IF (r < t) THEN !    x = LOG(r/(one - r))/h !    y = d*EXP(x) !    z = c*x + f*LOG((one + d)/(one + y)) - aln4 !    IF (s - one > z) THEN !      IF (s - s*z > one) CYCLE !      IF (LOG(s) > z) CYCLE !    END IF !    fn_val = y/(one + y) !  ELSE !    IF (4.0*s > (one + one/d)**f) CYCLE !    fn_val = one !  END IF !  EXIT !END DO ! !IF (swap) fn_val = one - fn_val !RETURN !END FUNCTION random_beta ! ! ! !FUNCTION random_t(m) RESULT(fn_val) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM VARIATE FROM A !! T DISTRIBUTION USING KINDERMAN AND MONAHAN'S RATIO METHOD. ! !!     M = DEGREES OF FREEDOM OF DISTRIBUTION !!           (1 <= 1NTEGER) ! !INTEGER, INTENT(IN) :: m !REAL                :: fn_val ! !!     Local variables !REAL, SAVE      :: s, c, a, f, g !REAL            :: r, x, v ! !REAL, PARAMETER :: three = 3.0, four = 4.0, quart = 0.25,   & !                   five = 5.0, sixteen = 16.0 !INTEGER         :: mm = 0 ! !IF (m < 1) THEN !  WRITE(*, *) 'IMPERMISSIBLE DEGREES OF FREEDOM' !  STOP !END IF ! !IF (m /= mm) THEN                    ! Initialization, if necessary !  s = m !  c = -quart*(s + one) !  a = four/(one + one/s)**c !  f = sixteen/a !  IF (m > 1) THEN !    g = s - one !    g = ((s + one)/g)**c*SQRT((s+s)/g) !  ELSE !    g = one !  END IF !  mm = m !END IF ! !DO !  CALL RANDOM_NUMBER(r) !  IF (r <= zero) CYCLE !  CALL RANDOM_NUMBER(v) !  x = (two*v - one)*g/r !  v = x*x !  IF (v > five - a*r) THEN !    IF (m >= 1 .AND. r*(v + three) > f) CYCLE !    IF (r > (one + v/s)**c) CYCLE !  END IF !  EXIT !END DO ! !fn_val = x !RETURN !END FUNCTION random_t ! ! ! !SUBROUTINE random_mvnorm(n, h, d, f, first, x, ier) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! N.B. An extra argument, ier, has been added to Dagpunar's routine ! !!     SUBROUTINE GENERATES AN N VARIATE RANDOM NORMAL !!     VECTOR USING A CHOLESKY DECOMPOSITION. ! !! ARGUMENTS: !!        N = NUMBER OF VARIATES IN VECTOR !!           (INPUT,INTEGER >= 1) !!     H(J) = J'TH ELEMENT OF VECTOR OF MEANS !!           (INPUT,REAL) !!     X(J) = J'TH ELEMENT OF DELIVERED VECTOR !!           (OUTPUT,REAL) !! !!    D(J*(J-1)/2+I) = (I,J)'TH ELEMENT OF VARIANCE MATRIX (J> = I) !!            (INPUT,REAL) !!    F((J-1)*(2*N-J)/2+I) = (I,J)'TH ELEMENT OF LOWER TRIANGULAR !!           DECOMPOSITION OF VARIANCE MATRIX (J <= I) !!            (OUTPUT,REAL) ! !!    FIRST = .TRUE. IF THIS IS THE FIRST CALL OF THE ROUTINE !!    OR IF THE DISTRIBUTION HAS CHANGED SINCE THE LAST CALL OF THE ROUTINE. !!    OTHERWISE SET TO .FALSE. !!            (INPUT,LOGICAL) ! !!    ier = 1 if the input covariance matrix is not +ve definite !!        = 0 otherwise ! !INTEGER, INTENT(IN)   :: n !REAL, INTENT(IN)      :: h(:), d(:)   ! d(n*(n+1)/2) !REAL, INTENT(IN OUT)  :: f(:)         ! f(n*(n+1)/2) !REAL, INTENT(OUT)     :: x(:) !LOGICAL, INTENT(IN)   :: first !INTEGER, INTENT(OUT)  :: ier ! !!     Local variables !INTEGER       :: j, i, m !REAL          :: y, v !INTEGER, SAVE :: n2 ! !IF (n < 1) THEN !  WRITE(*, *) 'SIZE OF VECTOR IS NON POSITIVE' !  STOP !END IF ! !ier = 0 !IF (first) THEN                        ! Initialization, if necessary !  n2 = 2*n !  IF (d(1) < zero) THEN !    ier = 1 !    RETURN !  END IF ! !  f(1) = SQRT(d(1)) !  y = one/f(1) !  DO j = 2,n !    f(j) = d(1+j*(j-1)/2) * y !  END DO ! !  DO i = 2,n !    v = d(i*(i-1)/2+i) !    DO m = 1,i-1 !      v = v - f((m-1)*(n2-m)/2+i)**2 !    END DO ! !    IF (v < zero) THEN !      ier = 1 !      RETURN !    END IF ! !    v = SQRT(v) !    y = one/v !    f((i-1)*(n2-i)/2+i) = v !    DO j = i+1,n !      v = d(j*(j-1)/2+i) !      DO m = 1,i-1 !        v = v - f((m-1)*(n2-m)/2+i)*f((m-1)*(n2-m)/2 + j) !      END DO ! m = 1,i-1 !      f((i-1)*(n2-i)/2 + j) = v*y !    END DO ! j = i+1,n !  END DO ! i = 2,n !END IF ! !x(1:n) = h(1:n) !DO j = 1,n !  y = random_normal() !  DO i = j,n !    x(i) = x(i) + f((j-1)*(n2-j)/2 + i) * y !  END DO ! i = j,n !END DO ! j = 1,n ! !RETURN !END SUBROUTINE random_mvnorm ! ! ! !FUNCTION random_inv_gauss(h, b, first) RESULT(fn_val) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY] FROM !! A REPARAMETERISED GENERALISED INVERSE GAUSSIAN (GIG) DISTRIBUTION !! WITH DENSITY PROPORTIONAL TO  GIG**(H-1) * EXP(-0.5*B*(GIG+1/GIG)) !! USING A RATIO METHOD. ! !!     H = PARAMETER OF DISTRIBUTION (0 <= REAL) !!     B = PARAMETER OF DISTRIBUTION (0 < REAL) ! !REAL, INTENT(IN)    :: h, b !LOGICAL, INTENT(IN) :: first !REAL                :: fn_val ! !!     Local variables !REAL            :: ym, xm, r, w, r1, r2, x !REAL, SAVE      :: a, c, d, e !REAL, PARAMETER :: quart = 0.25 ! !IF (h < zero .OR. b <= zero) THEN !  WRITE(*, *) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' !  STOP !END IF ! !IF (first) THEN                        ! Initialization, if necessary !  IF (h > quart*b*SQRT(vlarge)) THEN !    WRITE(*, *) 'THE RATIO H:B IS TOO SMALL' !    STOP !  END IF !  e = b*b !  d = h + one !  ym = (-d + SQRT(d*d + e))/b !  IF (ym < vsmall) THEN !    WRITE(*, *) 'THE VALUE OF B IS TOO SMALL' !    STOP !  END IF ! !  d = h - one !  xm = (d + SQRT(d*d + e))/b !  d = half*d !  e = -quart*b !  r = xm + one/xm !  w = xm*ym !  a = w**(-half*h) * SQRT(xm/ym) * EXP(-e*(r - ym - one/ym)) !  IF (a < vsmall) THEN !    WRITE(*, *) 'THE VALUE OF H IS TOO LARGE' !    STOP !  END IF !  c = -d*LOG(xm) - e*r !END IF ! !DO !  CALL RANDOM_NUMBER(r1) !  IF (r1 <= zero) CYCLE !  CALL RANDOM_NUMBER(r2) !  x = a*r2/r1 !  IF (x <= zero) CYCLE !  IF (LOG(r1) < d*LOG(x) + e*(x + one/x) + c) EXIT !END DO ! !fn_val = x ! !RETURN !END FUNCTION random_inv_gauss ! ! ! !FUNCTION random_Poisson(mu, first) RESULT(ival) !!********************************************************************** !!     Translated to Fortran 90 by Alan Miller from: !!                           RANLIB !! !!     Library of Fortran Routines for Random Number Generation !! !!                    Compiled and Written by: !! !!                         Barry W. Brown !!                          James Lovato !! !!             Department of Biomathematics, Box 237 !!             The University of Texas, M.D. Anderson Cancer Center !!             1515 Holcombe Boulevard !!             Houston, TX      77030 !! !! This work was supported by grant CA-16672 from the National Cancer Institute. ! !!                    GENerate POIsson random deviate ! !!                            Function ! !! Generates a single random deviate from a Poisson distribution with mean mu. ! !!                            Arguments ! !!     mu --> The mean of the Poisson distribution from which !!            a random deviate is to be generated. !!                              REAL mu ! !!                              Method ! !!     For details see: ! !!               Ahrens, J.H. and Dieter, U. !!               Computer Generation of Poisson Deviates !!               From Modified Normal Distributions. !!               ACM Trans. Math. Software, 8, 2 !!               (June 1982),163-179 ! !!     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT !!     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL ! !!     SEPARATION OF CASES A AND B ! !!     .. Scalar Arguments .. !REAL, INTENT(IN)    :: mu !LOGICAL, INTENT(IN) :: first !INTEGER             :: ival !!     .. !!     .. Local Scalars .. !REAL          :: b1, b2, c, c0, c1, c2, c3, del, difmuk, e, fk, fx, fy, g,  & !                 omega, px, py, t, u, v, x, xx !REAL, SAVE    :: s, d, p, q, p0 !INTEGER       :: j, k, kflag !LOGICAL, SAVE :: full_init !INTEGER, SAVE :: l, m !!     .. !!     .. Local Arrays .. !REAL, SAVE    :: pp(35) !!     .. !!     .. Data statements .. !REAL, PARAMETER :: a0 = -.5, a1 = .3333333, a2 = -.2500068, a3 = .2000118,  & !                   a4 = -.1661269, a5 = .1421878, a6 = -.1384794,   & !                   a7 = .1250060 ! !REAL, PARAMETER :: fact(10) = (/ 1., 1., 2., 6., 24., 120., 720., 5040.,  & !                                 40320., 362880. /) ! !!     .. !!     .. Executable Statements .. !IF (mu > 10.0) THEN !!     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED) ! !  IF (first) THEN !    s = SQRT(mu) !    d = 6.0*mu*mu ! !!             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL !!             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484) !!             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 . ! !    l = mu - 1.1484 !    full_init = .false. !  END IF ! ! !!     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE ! !  g = mu + s*random_normal() !  IF (g > 0.0) THEN !    ival = g ! !!     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH ! !    IF (ival>=l) RETURN ! !!     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U ! !    fk = ival !    difmuk = mu - fk !    CALL RANDOM_NUMBER(u) !    IF (d*u >= difmuk*difmuk*difmuk) RETURN !  END IF ! !!     STEP P. PREPARATIONS FOR STEPS Q AND H. !!             (RECALCULATIONS OF PARAMETERS IF NECESSARY) !!             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7. !!             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE !!             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK. !!             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION. ! !  IF (.NOT. full_init) THEN !    omega = .3989423/s !    b1 = .4166667E-1/mu !    b2 = .3*b1*b1 !    c3 = .1428571*b1*b2 !    c2 = b2 - 15.*c3 !    c1 = b1 - 6.*b2 + 45.*c3 !    c0 = 1. - b1 + 3.*b2 - 15.*c3 !    c = .1069/mu !    full_init = .true. !  END IF ! !  IF (g < 0.0) GO TO 50 ! !!             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN) ! !  kflag = 0 !  GO TO 70 ! !!     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE) ! !  40 IF (fy-u*fy <= py*EXP(px-fx)) RETURN ! !!     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL !!             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT' !!             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.) ! !  50 e = random_exponential() !  CALL RANDOM_NUMBER(u) !  u = u + u - one !  t = 1.8 + SIGN(e, u) !  IF (t <= (-.6744)) GO TO 50 !  ival = mu + s*t !  fk = ival !  difmuk = mu - fk ! !!             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN) ! !  kflag = 1 !  GO TO 70 ! !!     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION) ! !  60 IF (c*ABS(u) > py*EXP(px+e) - fy*EXP(fx+e)) GO TO 50 !  RETURN ! !!     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY. !!             CASE ival < 10 USES FACTORIALS FROM TABLE FACT ! !  70 IF (ival>=10) GO TO 80 !  px = -mu !  py = mu**ival/fact(ival+1) !  GO TO 110 ! !!             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION !!             A0-A7 FOR ACCURACY WHEN ADVISABLE !!             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5) ! !  80 del = .8333333E-1/fk !  del = del - 4.8*del*del*del !  v = difmuk/fk !  IF (ABS(v)>0.25) THEN !    px = fk*LOG(one + v) - difmuk - del !  ELSE !    px = fk*v*v* (((((((a7*v+a6)*v+a5)*v+a4)*v+a3)*v+a2)*v+a1)*v+a0) - del !  END IF !  py = .3989423/SQRT(fk) !  110 x = (half - difmuk)/s !  xx = x*x !  fx = -half*xx !  fy = omega* (((c3*xx + c2)*xx + c1)*xx + c0) !  IF (kflag <= 0) GO TO 40 !  GO TO 60 ! !!--------------------------------------------------------------------------- !!     C A S E  B.    mu < 10 !!     START NEW TABLE AND CALCULATE P0 IF NECESSARY ! !ELSE !  IF (first) THEN !    m = MAX(1, INT(mu)) !    l = 0 !    p = EXP(-mu) !    q = p !    p0 = p !  END IF ! !!     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD ! !  DO !    CALL RANDOM_NUMBER(u) !    ival = 0 !    IF (u <= p0) RETURN ! !!     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE !!             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES !!             (0.458=PP(9) FOR MU=10) ! !    IF (l == 0) GO TO 150 !    j = 1 !    IF (u > 0.458) j = MIN(l, m) !    DO k = j, l !      IF (u <= pp(k)) GO TO 180 !    END DO !    IF (l == 35) CYCLE ! !!     STEP C. CREATION OF NEW POISSON PROBABILITIES P !!             AND THEIR CUMULATIVES Q=PP(K) ! !    150 l = l + 1 !    DO k = l, 35 !      p = p*mu / k !      q = q + p !      pp(k) = q !      IF (u <= q) GO TO 170 !    END DO !    l = 35 !  END DO ! !  170 l = k !  180 ival = k !  RETURN !END IF ! !RETURN !END FUNCTION random_Poisson ! ! ! !FUNCTION random_binomial1(n, p, first) RESULT(ival) ! !! FUNCTION GENERATES A RANDOM BINOMIAL VARIATE USING C.D.Kemp's method. !! This algorithm is suitable when many random variates are required !! with the SAME parameter values for n & p. ! !!    P = BERNOULLI SUCCESS PROBABILITY !!           (0 <= REAL <= 1) !!    N = NUMBER OF BERNOULLI TRIALS !!           (1 <= INTEGER) !!    FIRST = .TRUE. for the first call using the current parameter values !!          = .FALSE. if the values of (n,p) are unchanged from last call ! !! Reference: Kemp, C.D. (1986). `A modal method for generating binomial !!            variables', Commun. Statist. - Theor. Meth. 15(3), 805-813. ! !INTEGER, INTENT(IN) :: n !REAL, INTENT(IN)    :: p !LOGICAL, INTENT(IN) :: first !INTEGER             :: ival ! !!     Local variables ! !INTEGER         :: ru, rd !INTEGER, SAVE   :: r0 !REAL            :: u, pd, pu !REAL, SAVE      :: odds_ratio, p_r !REAL, PARAMETER :: zero = 0.0, one = 1.0 ! !IF (first) THEN !  r0 = (n+1)*p !  p_r = bin_prob(n, p, r0) !  odds_ratio = p / (one - p) !END IF ! !CALL RANDOM_NUMBER(u) !u = u - p_r !IF (u < zero) THEN !  ival = r0 !  RETURN !END IF ! !pu = p_r !ru = r0 !pd = p_r !rd = r0 !DO !  rd = rd - 1 !  IF (rd >= 0) THEN !    pd = pd * (rd+1) / (odds_ratio * (n-rd)) !    u = u - pd !    IF (u < zero) THEN !      ival = rd !      RETURN !    END IF !  END IF ! !  ru = ru + 1 !  IF (ru <= n) THEN !    pu = pu * (n-ru+1) * odds_ratio / ru !    u = u - pu !    IF (u < zero) THEN !      ival = ru !      RETURN !    END IF !  END IF !END DO ! !!     This point should not be reached, but just in case: ! !ival = r0 !RETURN ! !END FUNCTION random_binomial1 ! ! ! !FUNCTION bin_prob(n, p, r) RESULT(fn_val) !!     Calculate a binomial probability ! !INTEGER, INTENT(IN) :: n, r !REAL, INTENT(IN)    :: p !REAL                :: fn_val ! !!     Local variable !REAL                :: one = 1.0 ! !fn_val = EXP( lngamma(DBLE(n+1)) - lngamma(DBLE(r+1)) - lngamma(DBLE(n-r+1)) & !              + r*LOG(p) + (n-r)*LOG(one - p) ) !RETURN ! !END FUNCTION bin_prob ! ! ! !FUNCTION lngamma(x) RESULT(fn_val) ! !! Logarithm to base e of the gamma function. !! !! Accurate to about 1.e-14. !! Programmer: Alan Miller ! !! Latest revision of Fortran 77 version - 28 February 1988 ! !REAL (dp), INTENT(IN) :: x !REAL (dp)             :: fn_val ! !!       Local variables ! !REAL (dp) :: a1 = -4.166666666554424D-02, a2 = 2.430554511376954D-03,  & !             a3 = -7.685928044064347D-04, a4 = 5.660478426014386D-04,  & !             temp, arg, product, lnrt2pi = 9.189385332046727D-1,       & !             pi = 3.141592653589793D0 !LOGICAL   :: reflect ! !!       lngamma is not defined if x = 0 or a negative integer. ! !IF (x > 0.d0) GO TO 10 !IF (x /= INT(x)) GO TO 10 !fn_val = 0.d0 !RETURN ! !!       If x < 0, use the reflection formula: !!               gamma(x) * gamma(1-x) = pi * cosec(pi.x) ! !10 reflect = (x < 0.d0) !IF (reflect) THEN !  arg = 1.d0 - x !ELSE !  arg = x !END IF ! !!       Increase the argument, if necessary, to make it > 10. ! !product = 1.d0 !20 IF (arg <= 10.d0) THEN !  product = product * arg !  arg = arg + 1.d0 !  GO TO 20 !END IF ! !!  Use a polynomial approximation to Stirling's formula. !!  N.B. The real Stirling's formula is used here, not the simpler, but less !!       accurate formula given by De Moivre in a letter to Stirling, which !!       is the one usually quoted. ! !arg = arg - 0.5D0 !temp = 1.d0/arg**2 !fn_val = lnrt2pi + arg * (LOG(arg) - 1.d0 + & !                  (((a4*temp + a3)*temp + a2)*temp + a1)*temp) - LOG(product) !IF (reflect) THEN !  temp = SIN(pi * x) !  fn_val = LOG(pi/temp) - fn_val !END IF !RETURN !END FUNCTION lngamma ! ! ! !FUNCTION random_binomial2(n, pp, first) RESULT(ival) !!********************************************************************** !!     Translated to Fortran 90 by Alan Miller from: !!                              RANLIB !! !!     Library of Fortran Routines for Random Number Generation !! !!                      Compiled and Written by: !! !!                           Barry W. Brown !!                            James Lovato !! !!               Department of Biomathematics, Box 237 !!               The University of Texas, M.D. Anderson Cancer Center !!               1515 Holcombe Boulevard !!               Houston, TX      77030 !! !! This work was supported by grant CA-16672 from the National Cancer Institute. ! !!                    GENerate BINomial random deviate ! !!                              Function ! !!     Generates a single random deviate from a binomial !!     distribution whose number of trials is N and whose !!     probability of an event in each trial is P. ! !!                              Arguments ! !!     N  --> The number of trials in the binomial distribution !!            from which a random deviate is to be generated. !!                              INTEGER N ! !!     P  --> The probability of an event in each trial of the !!            binomial distribution from which a random deviate !!            is to be generated. !!                              REAL P ! !!     FIRST --> Set FIRST = .TRUE. for the first call to perform initialization !!               the set FIRST = .FALSE. for further calls using the same pair !!               of parameter values (N, P). !!                              LOGICAL FIRST ! !!     random_binomial2 <-- A random deviate yielding the number of events !!                from N independent trials, each of which has !!                a probability of event P. !!                              INTEGER random_binomial ! !!                              Method ! !!     This is algorithm BTPE from: ! !!         Kachitvichyanukul, V. and Schmeiser, B. W. !!         Binomial Random Variate Generation. !!         Communications of the ACM, 31, 2 (February, 1988) 216. ! !!********************************************************************** ! !!*****DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY ! !!     .. !!     .. Scalar Arguments .. !REAL, INTENT(IN)    :: pp !INTEGER, INTENT(IN) :: n !LOGICAL, INTENT(IN) :: first !INTEGER             :: ival !!     .. !!     .. Local Scalars .. !REAL            :: alv, amaxp, f, f1, f2, u, v, w, w2, x, x1, x2, ynorm, z, z2 !REAL, PARAMETER :: zero = 0.0, half = 0.5, one = 1.0 !INTEGER         :: i, ix, ix1, k, mp !INTEGER, SAVE   :: m !REAL, SAVE      :: p, q, xnp, ffm, fm, xnpq, p1, xm, xl, xr, c, al, xll,  & !                   xlr, p2, p3, p4, qn, r, g ! !!     .. !!     .. Executable Statements .. ! !!*****SETUP, PERFORM ONLY WHEN PARAMETERS CHANGE ! !IF (first) THEN !  p = MIN(pp, one-pp) !  q = one - p !  xnp = n * p !END IF ! !IF (xnp > 30.) THEN !  IF (first) THEN !    ffm = xnp + p !    m = ffm !    fm = m !    xnpq = xnp * q !    p1 = INT(2.195*SQRT(xnpq) - 4.6*q) + half !    xm = fm + half !    xl = xm - p1 !    xr = xm + p1 !    c = 0.134 + 20.5 / (15.3 + fm) !    al = (ffm-xl) / (ffm - xl*p) !    xll = al * (one + half*al) !    al = (xr - ffm) / (xr*q) !    xlr = al * (one + half*al) !    p2 = p1 * (one + c + c) !    p3 = p2 + c / xll !    p4 = p3 + c / xlr !  END IF ! !!*****GENERATE VARIATE, Binomial mean at least 30. ! !  20 CALL RANDOM_NUMBER(u) !  u = u * p4 !  CALL RANDOM_NUMBER(v) ! !!     TRIANGULAR REGION ! !  IF (u <= p1) THEN !    ix = xm - p1 * v + u !    GO TO 110 !  END IF ! !!     PARALLELOGRAM REGION ! !  IF (u <= p2) THEN !    x = xl + (u-p1) / c !    v = v * c + one - ABS(xm-x) / p1 !    IF (v > one .OR. v <= zero) GO TO 20 !    ix = x !  ELSE ! !!     LEFT TAIL ! !    IF (u <= p3) THEN !      ix = xl + LOG(v) / xll !      IF (ix < 0) GO TO 20 !      v = v * (u-p2) * xll !    ELSE ! !!     RIGHT TAIL ! !      ix = xr - LOG(v) / xlr !      IF (ix > n) GO TO 20 !      v = v * (u-p3) * xlr !    END IF !  END IF ! !!*****DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST ! !  k = ABS(ix-m) !  IF (k <= 20 .OR. k >= xnpq/2-1) THEN ! !!     EXPLICIT EVALUATION ! !    f = one !    r = p / q !    g = (n+1) * r !    IF (m < ix) THEN !      mp = m + 1 !      DO i = mp, ix !        f = f * (g/i-r) !      END DO ! !    ELSE IF (m > ix) THEN !      ix1 = ix + 1 !      DO i = ix1, m !        f = f / (g/i-r) !      END DO !    END IF ! !    IF (v > f) THEN !      GO TO 20 !    ELSE !      GO TO 110 !    END IF !  END IF ! !!     SQUEEZING USING UPPER AND LOWER BOUNDS ON LOG(F(X)) ! !  amaxp = (k/xnpq) * ((k*(k/3. + .625) + .1666666666666)/xnpq + half) !  ynorm = -k * k / (2.*xnpq) !  alv = LOG(v) !  IF (alv<ynorm - amaxp) GO TO 110 !  IF (alv>ynorm + amaxp) GO TO 20 ! !!     STIRLING'S (actually de Moivre's) FORMULA TO MACHINE ACCURACY FOR !!     THE FINAL ACCEPTANCE/REJECTION TEST ! !  x1 = ix + 1 !  f1 = fm + one !  z = n + 1 - fm !  w = n - ix + one !  z2 = z * z !  x2 = x1 * x1 !  f2 = f1 * f1 !  w2 = w * w !  IF (alv - (xm*LOG(f1/x1) + (n-m+half)*LOG(z/w) + (ix-m)*LOG(w*p/(x1*q)) +    & !      (13860.-(462.-(132.-(99.-140./f2)/f2)/f2)/f2)/f1/166320. +               & !      (13860.-(462.-(132.-(99.-140./z2)/z2)/z2)/z2)/z/166320. +                & !      (13860.-(462.-(132.-(99.-140./x2)/x2)/x2)/x2)/x1/166320. +               & !      (13860.-(462.-(132.-(99.-140./w2)/w2)/w2)/w2)/w/166320.) > zero) THEN !    GO TO 20 !  ELSE !    GO TO 110 !  END IF ! !ELSE !!     INVERSE CDF LOGIC FOR MEAN LESS THAN 30 !  IF (first) THEN !    qn = q ** n !    r = p / q !    g = r * (n+1) !  END IF ! !  90 ix = 0 !  f = qn !  CALL RANDOM_NUMBER(u) !  100 IF (u >= f) THEN !    IF (ix > 110) GO TO 90 !    u = u - f !    ix = ix + 1 !    f = f * (g/ix - r) !    GO TO 100 !  END IF !END IF ! !110 IF (pp > half) ix = n - ix !ival = ix !RETURN ! !END FUNCTION random_binomial2 ! ! ! ! !FUNCTION random_neg_binomial(sk, p) RESULT(ival) ! !! Adapted from Fortran 77 code from the book: !!     Dagpunar, J. 'Principles of random variate generation' !!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! !! FUNCTION GENERATES A RANDOM NEGATIVE BINOMIAL VARIATE USING UNSTORED !! INVERSION AND/OR THE REPRODUCTIVE PROPERTY. ! !!    SK = NUMBER OF FAILURES REQUIRED (Dagpunar's words!) !!       = the `power' parameter of the negative binomial !!           (0 < REAL) !!    P = BERNOULLI SUCCESS PROBABILITY !!           (0 < REAL < 1) ! !! THE PARAMETER H IS SET SO THAT UNSTORED INVERSION ONLY IS USED WHEN P <= H, !! OTHERWISE A COMBINATION OF UNSTORED INVERSION AND !! THE REPRODUCTIVE PROPERTY IS USED. ! !REAL, INTENT(IN)   :: sk, p !INTEGER            :: ival ! !!     Local variables !! THE PARAMETER ULN = -LOG(MACHINE'S SMALLEST REAL NUMBER). ! !REAL, PARAMETER    :: h = 0.7 !REAL               :: q, x, st, uln, v, r, s, y, g !INTEGER            :: k, i, n ! !IF (sk <= zero .OR. p <= zero .OR. p >= one) THEN !  WRITE(*, *) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' !  STOP !END IF ! !q = one - p !x = zero !st = sk !IF (p > h) THEN !  v = one/LOG(p) !  k = st !  DO i = 1,k !    DO !      CALL RANDOM_NUMBER(r) !      IF (r > zero) EXIT !    END DO !    n = v*LOG(r) !    x = x + n !  END DO !  st = st - k !END IF ! !s = zero !uln = -LOG(vsmall) !IF (st > -uln/LOG(q)) THEN !  WRITE(*, *) ' P IS TOO LARGE FOR THIS VALUE OF SK' !  STOP !END IF ! !y = q**st !g = st !CALL RANDOM_NUMBER(r) !DO !  IF (y > r) EXIT !  r = r - y !  s = s + one !  y = y*p*g/s !  g = g + one !END DO ! !ival = x + s + half !RETURN !END FUNCTION random_neg_binomial ! ! ! !FUNCTION random_von_Mises(k, first) RESULT(fn_val) ! !!     Algorithm VMD from: !!     Dagpunar, J.S. (1990) `Sampling from the von Mises distribution via a !!     comparison of random numbers', J. of Appl. Statist., 17, 165-168. ! !!     Fortran 90 code by Alan Miller !!     CSIRO Division of Mathematical & Information Sciences ! !!     Arguments: !!     k (real)        parameter of the von Mises distribution. !!     first (logical) set to .TRUE. the first time that the function !!                     is called, or the first time with a new value !!                     for k.   When first = .TRUE., the function sets !!                     up starting values and may be very much slower. ! !REAL, INTENT(IN)     :: k !LOGICAL, INTENT(IN)  :: first !REAL                 :: fn_val ! !!     Local variables ! !INTEGER          :: j, n !INTEGER, SAVE    :: nk !REAL, PARAMETER  :: pi = 3.14159265 !REAL, SAVE       :: p(20), theta(0:20) !REAL             :: sump, r, th, lambda, rlast !REAL (dp)        :: dk ! !IF (first) THEN                        ! Initialization, if necessary !  IF (k < zero) THEN !    WRITE(*, *) '** Error: argument k for random_von_Mises = ', k !    RETURN !  END IF ! !  nk = k + k + one !  IF (nk > 20) THEN !    WRITE(*, *) '** Error: argument k for random_von_Mises = ', k !    RETURN !  END IF ! !  dk = k !  theta(0) = zero !  IF (k > half) THEN ! !!     Set up array p of probabilities. ! !    sump = zero !    DO j = 1, nk !      IF (j < nk) THEN !        theta(j) = ACOS(one - j/k) !      ELSE !        theta(nk) = pi !      END IF ! !!     Numerical integration of e&#94;[k.cos(x)] from theta(j-1) to theta(j) ! !      CALL integral(theta(j-1), theta(j), p(j), dk) !      sump = sump + p(j) !    END DO !    p(1:nk) = p(1:nk) / sump !  ELSE !    p(1) = one !    theta(1) = pi !  END IF                         ! if k > 0.5 !END IF                           ! if first ! !CALL RANDOM_NUMBER(r) !DO j = 1, nk !  r = r - p(j) !  IF (r < zero) EXIT !END DO !r = -r/p(j) ! !DO !  th = theta(j-1) + r*(theta(j) - theta(j-1)) !  lambda = k - j + one - k*COS(th) !  n = 1 !  rlast = lambda ! !  DO !    CALL RANDOM_NUMBER(r) !    IF (r > rlast) EXIT !    n = n + 1 !    rlast = r !  END DO ! !  IF (n .NE. 2*(n/2)) EXIT         ! is n even? !  CALL RANDOM_NUMBER(r) !END DO ! !fn_val = SIGN(th, (r - rlast)/(one - rlast) - half) !RETURN !END FUNCTION random_von_Mises ! ! ! !SUBROUTINE integral(a, b, result, dk) ! !!     Gaussian integration of exp(k.cosx) from a to b. ! !REAL (dp), INTENT(IN) :: dk !REAL, INTENT(IN)      :: a, b !REAL, INTENT(OUT)     :: result ! !!     Local variables ! !REAL (dp)  :: xmid, range, x1, x2,                                    & !  x(3) = (/0.238619186083197_dp, 0.661209386466265_dp, 0.932469514203152_dp/), & !  w(3) = (/0.467913934572691_dp, 0.360761573048139_dp, 0.171324492379170_dp/) !INTEGER    :: i ! !xmid = (a + b)/2._dp !range = (b - a)/2._dp ! !result = 0._dp !DO i = 1, 3 !  x1 = xmid + x(i)*range !  x2 = xmid - x(i)*range !  result = result + w(i)*(EXP(dk*COS(x1)) + EXP(dk*COS(x2))) !END DO ! !result = result * range !RETURN !END SUBROUTINE integral ! ! ! !FUNCTION random_Cauchy() RESULT(fn_val) ! !!     Generate a random deviate from the standard Cauchy distribution ! !REAL     :: fn_val ! !!     Local variables !REAL     :: v(2) ! !DO !  CALL RANDOM_NUMBER(v) !  v = two*(v - half) !  IF (ABS(v(2)) < vsmall) CYCLE               ! Test for zero !  IF (v(1)**2 + v(2)**2 < one) EXIT !END DO !fn_val = v(1) / v(2) ! !RETURN !END FUNCTION random_Cauchy end module","loc":"sourcefile/m_random.f90.html","tags":""},{"title":"m_searching.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_searching.f90~~EfferentGraph sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_searching.f90~~AfferentGraph sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_searching.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_searching Source Code m_searching.f90 Source Code module m_searching !! Contains routines to perform a simple binary search on a vector !! !! Example usage !!```fortran !!program binarySearch_test !!use variableKind, only: i32, r64 !!use m_BinarySearch, only: binarySearch !! !!implicit none !! !!real(r64) :: arr(20) !!integer(i32) :: i !!integer(i32) :: j !!arr=[(dble(i), i = 1, 20)] !!j = binarySearch(arr, 10.d0, 1, 20) !!write(*,*) 'Location of 10.0 in arr is 10? ',j == 10 !!end program !!``` !! Perform a binary search but also return the neighbouring interval if the actual value is not found. !! This is useful if you need to find a number that is not contained in the array and you want the interval !! !! Example usage !!```fortran !!use variableKind !!use m_BinarySearch, only: intervalSearch !!real(r64) :: arr(20) !!integer(i32) :: i !!integer(i32) :: j(3) !!arr=[(dble(i), i = 1, 20)] !!j = intervalSearch(arr, 10.5d0, 1, 20) !!write(*,*) 'Location of 10.5 in arr is -1? ',j(1) == -1 !!write(*,*) 'The interval containing 10.5 is [10,11]? ',j(2:3) == [10,11] !!``` use variableKind implicit none private public :: binarySearch public :: intervalSearch public :: simpleSearch interface binarySearch !! Perform a binary search.  See [[m_searching]] for more information on how to use this interface !====================================================================! module recursive function binarySearch_i1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! integer ( i32 ) :: this (:) !! Vector to search within integer ( i32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present end function !====================================================================! !====================================================================! module recursive function binarySearch_id1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! integer ( i64 ) :: this (:) !! Vector to search within integer ( i64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present end function !====================================================================! !====================================================================! module recursive function binarySearch_r1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! real ( r32 ) :: this (:) !! Vector to search within real ( r32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present end function !====================================================================! !====================================================================! module recursive function binarySearch_d1D ( this , v , imin , imax ) result ( iout ) !! Search for the value i in an integer vector !! Assumes this is sorted! !====================================================================! real ( r64 ) :: this (:) !! Vector to search within real ( r64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout !! Location of i in this. Returns -1 if not present end function !====================================================================! end interface interface intervalSearch !! Perform an interval search on an array !! Returns a length 3 integer(i32) array where the last two entries are the left and right neighbours !! The first entry of iout is -1 if the value is not present in the vector !! Assumes this is sorted!See [[m_searching]] for more information on how to use this interface !====================================================================! module recursive function intervalSearch_i1D ( this , v , imin , imax ) result ( iout ) !! interfaced with [[intervalSearch]] !====================================================================! integer ( i32 ) :: this (:) !! Vector to search within integer ( i32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval end function !====================================================================! !====================================================================! module recursive function intervalSearch_id1D ( this , v , imin , imax ) result ( iout ) !! interfaced with [[intervalSearch]] !====================================================================! integer ( i64 ) :: this (:) !! Vector to search within integer ( i64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval end function !====================================================================! !====================================================================! module recursive function intervalSearch_r1D ( this , v , imin , imax ) result ( iout ) !! interfaced with [[intervalSearch]] !====================================================================! real ( r32 ) :: this (:) !! Vector to search within real ( r32 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval end function !====================================================================! !====================================================================! module recursive function intervalSearch_d1D ( this , v , imin , imax ) result ( iout ) !! interfaced with [[intervalSearch]] !====================================================================! real ( r64 ) :: this (:) !! Vector to search within real ( r64 ) :: v !! Number to find in the vector integer ( i32 ) :: imin !! Left integer integer ( i32 ) :: imax !! Right integer integer ( i32 ) :: iout ( 3 ) !! Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval end function !====================================================================! end interface interface simpleSearch !! Carry out a brute force search on an array for a given number. Returns -1 if the value is not found. !====================================================================! module function simpleSearch_i1D ( this , val ) result ( iout ) !! Interfaced with [[simpleSearch]] !====================================================================! integer ( i32 ) :: this (:) !! Search this vector integer ( i32 ) :: val !! Number to find in the vector integer ( i32 ) :: iout !! Location of i in this end function !====================================================================! !====================================================================! module function simpleSearch_id1D ( this , val ) result ( iout ) !! Interfaced with [[simpleSearch]] !====================================================================! integer ( i64 ) :: this (:) !! Search this vector integer ( i64 ) :: val !! Number to find in the vector integer ( i32 ) :: iout !! Location of i in this end function !====================================================================! !====================================================================! module function simpleSearch_r1D ( this , val ) result ( iout ) !! Interfaced with [[simpleSearch]] !====================================================================! real ( r32 ) :: this (:) !! Search this vector real ( r32 ) :: val !! Number to find in the vector integer ( i32 ) :: iout !! Location of i in this end function !====================================================================! !====================================================================! module function simpleSearch_d1D ( this , val ) result ( iout ) !! Interfaced with [[simpleSearch]] !====================================================================! real ( r64 ) :: this (:) !! Search this vector real ( r64 ) :: val !! Number to find in the vector integer ( i32 ) :: iout !! Location of i in this end function !====================================================================! end interface end module","loc":"sourcefile/m_searching.f90.html","tags":""},{"title":"m_medianOf3.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_medianof3.f90~~EfferentGraph sourcefile~m_medianof3.f90 m_medianOf3.f90 sourcefile~m_swap.f90 m_swap.f90 sourcefile~m_swap.f90->sourcefile~m_medianof3.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_medianof3.f90 sourcefile~m_variablekind.f90->sourcefile~m_swap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_medianOf3 Source Code m_medianOf3.f90 Source Code module m_medianOf3 !! Given three numbers, find their median and sort at the same time use variableKind use m_swap , only : swap implicit none private public medianOf3 interface medianOf3 !! Sort three numbers in an array and return the location of the median module procedure :: medianOf3_r1D , medianOf3_d1D , medianOf3_i1D , medianOf3_id1D end interface public argMedianOf3 interface argMedianOf3 !! Sort the indices of three numbers into an array and return the location of the median module procedure :: argMedianOf3_r1D , argMedianOf3_d1D , argMedianOf3_i1D , argMedianOf3_id1D end interface contains !====================================================================! subroutine medianOf3_r1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! real ( r32 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine medianOf3_d1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! real ( r64 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine medianOf3_i1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! integer ( i32 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine medianOf3_id1D ( this , left , mid , right ) !! Interfaced with medianOf3() !====================================================================! integer ( i64 ) :: this (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( right ) < this ( left )) call swap ( this ( left ), this ( right )) if ( this ( mid ) < this ( left )) call swap ( this ( mid ), this ( left )) if ( this ( right ) < this ( mid )) call swap ( this ( right ), this ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_r1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! real ( r32 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_d1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! real ( r64 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_i1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! integer ( i32 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! !====================================================================! subroutine argMedianOf3_id1D ( this , i , left , mid , right ) !! Interfaced with argMedianOf3() !====================================================================! integer ( i64 ) :: this (:) integer ( i32 ) :: i (:) integer ( i32 ) :: left integer ( i32 ) :: mid integer ( i32 ) :: right if ( this ( i ( right )) < this ( i ( left ))) call swap ( i ( left ), i ( right )) if ( this ( i ( mid )) < this ( i ( left ))) call swap ( i ( mid ), i ( left )) if ( this ( i ( right )) < this ( i ( mid ))) call swap ( i ( right ), i ( mid )) end subroutine !====================================================================! end module","loc":"sourcefile/m_medianof3.f90.html","tags":""},{"title":"m_select.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_select.f90~~EfferentGraph sourcefile~m_select.f90 m_select.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_select.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_select.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_select.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_selectf90EfferentGraph = svgPanZoom('#sourcefilem_selectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_select.f90~~AfferentGraph sourcefile~m_select.f90 m_select.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_select Source Code m_select.f90 Source Code module m_select !! Perform a quickselect on an array. Quick select finds the kth smallest number in an array. It also puts values lower than the kth on the left, and those higher on the right !! This makes it perfect for finding the median. use variableKind use m_errors , only : msg use m_allocate , only : allocate use m_array1D , only : arange use m_deallocate , only : deallocate use m_random , only : rngNormal , rngInteger use m_sort , only : sort use m_unitTester , only : tester implicit none private public :: select_test public :: select interface select !!Use an in-place quick select on an array of numbers !! !!Example usage !!```fortran !!program selectTest !!use variableKind !!use m_strings, only: str !!use m_allocate, only: allocate !!use m_random, only: rngInteger,rngNormal !!use m_select, only: select !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32) :: k !!real(r64) :: dv !!integer(i32) :: iv !! !!write(*,'(a)') 'Select the kth smallest element from a 10000 length array of random double precision numbers' !!call allocate(d1D, 10000) !!call rngNormal(d1D) !!k = (1+size(d1D))/2 !!dv = select(d1D,k) !!write(*,'(a)') 'kth element? '//str(dv) !!write(*,'(a)') 'Select the kth smallest element from a 10000 length array of random integers'' !!call allocate(i1D, 10000) !!call rngInteger(i1D) !!iv = select(i1D, k) !!write(*,'(a)') 'kth element? '//str(iv) !!end program !!``` module subroutine quickSelect_i1D ( this , k , res ) !! Interfaced with select() integer ( i32 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res end subroutine module subroutine quickSelect_id1D ( this , k , res ) !! Interfaced with select() integer ( i64 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i64 ) :: res end subroutine module subroutine quickSelect_r1D ( this , k , res ) !! Interfaced with select() real ( r32 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element real ( r32 ) :: res end subroutine module subroutine quickSelect_d1D ( this , k , res ) !! Interfaced with select() real ( r64 ), intent ( inout ) :: this (:) !! Array to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element real ( r64 ) :: res end subroutine end interface public :: argSelect interface argSelect !!Use an indirect introspection sort on an array of numbers !! !!Example usage !!```fortran !!program argSortTest !!use variableKind !!use m_strings, only: str !!use m_random, only: rngInteger,rngNormal !!use m_arrays, only: isSorted !!use m_Sort, only: argSort !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32),allocatable :: indx(:) !!integer(i32) :: i, k, N !!N = 10000 !!call allocate(indx,N) !!call arange(indx, 1, N) !!call allocate(d1D,N) !!call rngNormal(d1D) !!k = (size(d1D)+1)/2 !!call argSelect(d1D, indx, k) !!write(*,'(a)') 'Double array is indirectly sorted? '//str(isSorted(d1D(indx))) !! !!call arange(indx, 1, N) !!call allocate(i1D,N) !!call rngInteger(i1D) !!call argSelectt(i1D, indx, k) !!write(*,'(a)') 'Integer array is indirectly sorted? '//str(isSorted(i1D(indx))) !!end program !!``` module subroutine argQuickSelect_i1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() integer ( i32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine module subroutine argQuickSelect_id1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() integer ( i64 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine module subroutine argQuickSelect_r1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() real ( r32 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine module subroutine argQuickSelect_d1D ( this , indx , k , res , left , right ) !! Interfaced with argSelect() real ( r64 ), intent ( in ) :: this (:) !! 1D array integer ( i32 ), intent ( inout ) :: indx (:) !! Index to choose kth smallest from integer ( i32 ), intent ( in ) :: k !! kth smallest element integer ( i32 ) :: res !! Index of the kth smallest element integer ( i32 ), intent ( in ), optional :: left !! Select over the region left:right integer ( i32 ), intent ( in ), optional :: right !! Select over the region left:right end subroutine end interface contains !====================================================================! subroutine select_test ( test , N ) !! graph: false !====================================================================! class ( tester ) :: test integer ( i32 ) :: N real ( r32 ) :: ar real ( r32 ), allocatable :: ar1D (:), br1D (:), cr1D (:) real ( r64 ) :: a real ( r64 ), allocatable :: a1D (:), b1D (:), c1D (:) integer ( i32 ) :: i , ia , ib , ic integer ( i32 ), allocatable :: ia1D (:), ib1D (:), ic1D (:), id1D (:) integer ( i64 ) :: iad integer ( i64 ), allocatable :: iad1D (:), ibd1D (:), icd1D (:) logical :: la , lb call Msg ( '==========================' ) call Msg ( 'Testing : Select' ) call Msg ( '==========================' ) call allocate ( ar1D , N ) call allocate ( br1D , N ) call allocate ( cr1D , N ) call allocate ( a1D , N ) call allocate ( ia1D , N ) call allocate ( ic1D , N ) call rngNormal ( a1D ) ar1D = real ( a1D ) call rngInteger ( ia1D , 1 , N ) br1D = ar1D ic = ( size ( br1D ) + 1 ) / 2 ! Get the median call select ( br1D , ic , ar ) la = all ( br1D ( 1 : ic - 1 ) <= br1D ( ic )) . and . all ( br1D ( ic + 1 : N ) >= br1D ( ic )) call sort ( br1D ) call test % test ( ar == br1D ( ic ) . and . la , 'quickselect_r1D' ) br1D = ar1D ic = 3 call select ( br1D , ic , ar ) la = all ( br1D ( 1 : ic - 1 ) <= br1D ( ic )) . and . all ( br1D ( ic + 1 : N ) >= br1D ( ic )) call sort ( br1D ) call test % test ( ar == br1D ( ic ) . and . la , 'quickselect_r1D' ) br1D = ar1D call arange ( ic1D , 1 , N ) ic = ( size ( br1D ) + 1 ) / 2 ! Get the median call argSelect ( br1D , ic1D , ic , ia ) do i = 1 , N cr1D ( i ) = br1D ( ic1D ( i )) enddo la = all ( cr1D ( 1 : ic - 1 ) <= cr1D ( ic )) . and . all ( cr1D ( ic + 1 : N ) >= cr1D ( ic )) call test % test ( la , 'argQuickSelect_r1D' ) call deallocate ( ar1D ) call deallocate ( br1D ) call deallocate ( cr1D ) call allocate ( b1D , N ) call allocate ( c1D , N ) b1D = a1D ic = ( size ( b1D ) + 1 ) / 2 ! Get the median call select ( b1D , ic , a ) la = all ( b1D ( 1 : ic - 1 ) <= b1D ( ic )) . and . all ( b1D ( ic + 1 : N ) >= b1D ( ic )) call sort ( b1D ) call test % test ( a == b1D ( ic ) . and . la , 'quickselect_d1D' ) b1D = a1D ic = ( size ( b1D ) + 1 ) / 2 ! Get the median call arange ( ic1D , 1 , N ) call argSelect ( b1D , ic1D , ic , ia ) do i = 1 , N c1D ( i ) = b1D ( ic1D ( i )) enddo lb = all ( c1D ( 1 : ic - 1 ) < c1D ( ic )) . and . all ( c1D ( ic + 1 : N ) > c1D ( ic )) call test % test ( la , 'argQuickselect_d1D' ) call deallocate ( a1D ) call deallocate ( b1D ) call deallocate ( c1D ) call allocate ( ib1D , N ) call allocate ( id1D , N ) ib1D = ia1D ic = ( size ( ib1D ) + 1 ) / 2 ! Get the median call select ( ib1D , ic , ia ) la = all ( ib1D ( 1 : ic - 1 ) <= ib1D ( ic )) . and . all ( ib1D ( ic + 1 : N ) >= ib1D ( ic )) call sort ( ib1D ) call test % test ( ia == ib1D ( ic ) . and . la , 'quickselect_i1D' ) ib1D = ia1D ic = ( size ( ib1D ) + 1 ) / 2 ! Get the median call arange ( ic1D , 1 , N ) call argSelect ( ib1D , ic1D , ic , ia ) do i = 1 , N id1D ( i ) = ib1D ( ic1D ( i )) enddo lb = all ( id1D ( 1 : ic - 1 ) < id1D ( ic )) . and . all ( id1D ( ic + 1 : N ) > id1D ( ic )) call test % test ( la , 'argQuickselect_i1D' ) call allocate ( iad1D , N ) call allocate ( ibd1D , N ) call allocate ( icd1D , N ) ibd1D = ia1D ic = ( size ( ibd1D + 1 )) / 2 ! Get the median call select ( ibd1D , ic , iad ) la = all ( ibd1D ( 1 : ic - 1 ) <= ibd1D ( ic )) . and . all ( ibd1D ( ic + 1 : N ) >= ibd1D ( ic )) call sort ( ibd1D ) call test % test ( iad == ibd1D ( ic ) . and . la , 'quickselect_id1D' ) ibd1D = ia1D ic = ( size ( ibd1D + 1 )) / 2 ! Get the median call arange ( ic1D , 1 , N ) call argSelect ( ibd1D , ic1D , ic , ia ) do i = 1 , N icd1D ( i ) = ibd1D ( ic1D ( i )) enddo lb = all ( icd1D ( 1 : ic - 1 ) < icd1D ( ic )) . and . all ( icd1D ( ic + 1 : N ) > icd1D ( ic )) call test % test ( la , 'argQuickselect_id1D' ) end subroutine !====================================================================! end module","loc":"sourcefile/m_select.f90.html","tags":""},{"title":"m_sort.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_sort.f90~~EfferentGraph sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_sortf90EfferentGraph = svgPanZoom('#sourcefilem_sortf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_sort.f90~~AfferentGraph sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_rdynamicarray.f90 m_rDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_rdynamicarray.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_iddynamicarray.f90 m_idDynamicArray.f90 sourcefile~m_sort.f90->sourcefile~m_iddynamicarray.f90 sourcefile~m_rargdynamicarray.f90 m_rArgDynamicArray.f90 sourcefile~m_rdynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_rargdynamicarray.f90 sourcefile~m_iargdynamicarray.f90 m_iArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_iargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idargdynamicarray.f90 m_idArgDynamicArray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_iddynamicarray.f90->sourcefile~m_idargdynamicarray.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_sort Source Code m_sort.f90 Source Code module m_sort !! Module containing in-place and indirect routines to sort an array of numbers. !! !! Uses an introspective sort on a set of number. See this http://www.geeksforgeeks.org/know-your-sorting-algorithm-set-2-introsort-cs-sorting-weapon/ for more information !! !! To begin, a quicksort with a median of three pivot is used until the size of the array is less than 16.  At this point, an insertion sort is used to reduce cache overhead and tail recursion. !! Unfortunately, a quicksort is not ideal for sorted/almost sorted arrays or arrays with duplicate values.  Therefore if the number of iterations exceededs a threshold, a heapsort is used instead. !! This provides a robust sorting algorithm that is still very fast for almost sorted arrays. !! !! In this implementation, the quicksort and heapsort are unstable sorts. A stable merge sort is therefore provided as an alternative but it has an order(N) memory overhead. !! !! Often, the numbers wish to be maintained in their given order, so with an O(N) memory overhead we can sort an integer array instead by calling argsort() !! !! See [[sort]] and [[argSort]] for more information. use variableKind use m_errors , only : msg use m_allocate , only : allocate use m_array1D , only : arange , isSorted use m_random , only : rngNormal , rngInteger use m_unitTester , only : tester implicit none private public :: sorting_test public :: sort interface sort !!Use an in-place introspection sort on an array of numbers !! !!Example usage !!```fortran !!program sortTest !!use variableKind, only: i32, r64 !!use m_strings, only: str !!use m_allocate, only: allocate !!use m_random, only: rngInteger, rngNormal !!use m_arrays, only: arange, isSorted !!use m_sort, only: sort !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32) :: N !! !!N = 10000 !!write(*,'(a)') 'In-place sort a 10000 length array of random double precision numbers' !!call allocate(d1D,N) !!call rngNormal(d1D) !!call sort(d1D) !!write(*,'(a)') 'Double array is sorted? '//str(isSorted(d1D)) !!write(*,'(a)') 'In-place sort a 10000 length array of random integers'' !!call allocate(i1D,N) !!call rngInteger(i1D) !!call sort(i1D) !!write(*,'(a)') 'Integer array is sorted? '//str(isSorted(i1D)) !!end program !!``` module subroutine sort_i1D ( this , stable ) !! Interfaced with [[sort]] integer ( i32 ) :: this (:) logical , optional :: stable end subroutine module subroutine sort_id1D ( this , stable ) !! Interfaced with [[sort]] integer ( i64 ) :: this (:) logical , optional :: stable end subroutine module subroutine sort_r1D ( this , stable ) !! Interfaced with [[sort]] real ( r32 ) :: this (:) logical , optional :: stable end subroutine module subroutine sort_d1D ( this , stable ) !! Interfaced with [[sort]] real ( r64 ) :: this (:) logical , optional :: stable end subroutine end interface private :: sort_i1D , sort_id1D , sort_r1D , sort_d1D public :: argSort interface argSort !!Use an indirect introspection sort on an array of numbers !! !!Example usage !!```fortran !!program argSortTest !!use variableKind !!use m_strings, only: str !!use m_random, only: rngInteger, rngNormal !!use m_arrays, only: arange, isSorted !!use m_Sort, only: argSort !!real(r64),allocatable :: d1D(:) !!integer(i32),allocatable :: i1D(:) !!integer(i32),allocatable :: indx(:) !!integer(i32) :: i, N !! !!N=10000 !!call allocate(indx, N) !!call arange(indx, 1, N) !!call allocate(d1D, N) !!call rngNormal(d1D) !!call argSort(d1D, indx) !!write(*,'(a)') 'Double array is indirectly sorted? '//str(isSorted(d1D(indx))) !! !!call arange(indx, 1, N) !!call allocate(i1D,N) !!call rngInteger(i1D) !!call argSort(i1D, indx) !!write(*,'(a)') 'Integer array is indirectly sorted? '//str(isSorted(i1D(indx))) !!end program !!``` module subroutine argSort_i1D ( this , i , stable ) !! Interfaced with [[argSort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine module subroutine argSort_id1D ( this , i , stable ) !! Interfaced with [[argSort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine module subroutine argSort_r1D ( this , i , stable ) !! Interfaced with [[argSort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine module subroutine argSort_d1D ( this , i , stable ) !! Interfaced with [[argSort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Index to sort logical , optional :: stable !! Stable sort? end subroutine end interface private :: argSort_i1D , argSort_id1D , argSort_r1D , argSort_d1D private :: introsort interface introsort !! Perform an in-place introspective sort on an array module subroutine introsort_r1D ( this ) !! Interfaced with [[introsort]] real ( r32 ) :: this (:) !! 1D array end subroutine module subroutine introsort_d1D ( this ) !! Interfaced with [[introsort]] real ( r64 ) :: this (:) !! 1D array end subroutine module subroutine introsort_i1D ( this ) !! Interfaced with [[introsort]] integer ( i32 ) :: this (:) !! 1D array end subroutine module subroutine introsort_id1D ( this ) !! Interfaced with [[introsort]] integer ( i64 ) :: this (:) !! 1D array end subroutine end interface private :: argIntrosort interface argintrosort !! Perform an indirect introsort on an array module subroutine argintrosort_r1D ( this , i ) !! Interfaced with [[argIntrosort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argintrosort_d1D ( this , i ) !! Interfaced with [[argIntrosort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argintrosort_i1D ( this , i ) !! Interfaced with [[argIntrosort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argintrosort_id1D ( this , i ) !! Interfaced with [[argIntrosort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine end interface interface MergeSort !! Perform an in-place stable merge sort on an array module subroutine mergesort_r1D ( this ) !! Interf aced with [[mergesort]] real ( r32 ) :: this (:) !! 1D array end subroutine module subroutine mergesort_d1D ( this ) !! Interfaced with [[mergesort]] real ( r64 ) :: this (:) !! 1D array end subroutine module subroutine mergesort_i1D ( this ) !! Interfaced with [[mergesort]] integer ( i32 ) :: this (:) !! 1D array end subroutine module subroutine mergesort_id1D ( this ) !! Interfaced with [[mergesort]] integer ( i64 ) :: this (:) !! 1D array end subroutine end interface interface argMergeSort !! Perform an indirect stable merge sort on an array module subroutine argmergesort_r1D ( this , i ) !! Interfaced with [[argmergesort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argmergesort_d1D ( this , i ) !! Interfaced with [[argmergesort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argmergesort_i1D ( this , i ) !! Interfaced with [[argmergesort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine module subroutine argmergesort_id1D ( this , i ) !! Interfaced with [[argmergesort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: i (:) !! Sort this integer key end subroutine end interface public :: insertionSort interface insertionsort !! Perform an in-place insertion sort on an array module subroutine insertionsort_r1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine insertionsort_d1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine insertionsort_i1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine insertionsort_id1D ( this , iLeft , iRight ) !! Interfaced with [[insertionsort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine end interface private :: insertionsort_r1D , insertionsort_d1D , insertionsort_i1D , insertionsort_id1D public :: argInsertionsort interface argInsertionsort !! Perform an indirect insertion sort on an array module subroutine argInsertionsort_r1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine argInsertionsort_d1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine argInsertionsort_i1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine module subroutine argInsertionsort_id1D ( this , indx , iLeft , iRight ) !! Interfaced with [[arginsertionsort]] integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: indx (:) !! Sort this integer key integer ( i32 ) :: iLeft !! Left index integer ( i32 ) :: iRight !! Right index end subroutine end interface private :: argInsertionsort_r1D , argInsertionsort_d1D , argInsertionsort_i1D , argInsertionsort_id1D private :: heapsort interface heapsort !! Perform an in-place heapsort on an array module subroutine heapsort_r1D ( this ) !! Interfaced with heapsort() real ( r32 ) :: this ( 0 :) !! 1D array end subroutine module subroutine heapsort_d1D ( this ) !! Interfaced with heapsort() real ( r64 ) :: this ( 0 :) !! 1D array end subroutine module subroutine heapsort_i1D ( this ) !! Interfaced with heapsort() integer ( i32 ) :: this ( 0 :) !! 1D array end subroutine module subroutine heapsort_id1D ( this ) !! Interfaced with heapsort() integer ( i64 ) :: this ( 0 :) !! 1D array end subroutine end interface private :: argHeapsort interface argHeapsort !! Perform an indirect heapsort on an array module subroutine argHeapsort_r1D ( this , indx ) !! Interfaced with argHeapsort() real ( r32 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine module subroutine argHeapsort_d1D ( this , indx ) !! Interfaced with argHeapsort() real ( r64 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine module subroutine argHeapsort_i1D ( this , indx ) !! Interfaced with argHeapsort() integer ( i32 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine module subroutine argHeapsort_id1D ( this , indx ) !! Interfaced with argHeapsort() integer ( i64 ) :: this (:) !! 1D array integer ( i32 ) :: indx ( 0 :) !! Sort this integer key end subroutine end interface contains !====================================================================! subroutine sorting_test ( test , N ) !! graph: false !====================================================================! class ( tester ) :: test integer ( i32 ) :: N real ( r32 ), allocatable :: ar1D (:), br1D (:) real ( r64 ), allocatable :: a1D (:), b1D (:) integer ( i32 ), allocatable :: ia1D (:), ib1D (:), ic1D (:) integer ( i64 ), allocatable :: iad1D (:), ibd1D (:) call Msg ( '==========================' ) call Msg ( 'Testing : Sorting' ) call Msg ( '==========================' ) !   Initial setup for testing call allocate ( ar1D , N ) call allocate ( br1D , N ) call allocate ( a1D , N ) call allocate ( b1D , N ) call allocate ( ia1D , N ) call allocate ( ib1D , N ) call allocate ( ic1D , N ) call allocate ( iad1D , N ) call allocate ( ibd1D , N ) call rngNormal ( a1D ) ar1D = real ( a1D ) br1D = ar1D call sort ( br1D ) call test % test ( isSorted ( br1D ), 'Introsort_r1D' ) br1D = ar1D call arange ( ia1D , 1 , N ) call argsort ( br1D , ia1D ) call test % test ( isSorted ( br1D , ia1D ), 'argIntrosort_r1D' ) br1D = ar1D call Sort ( br1D ,. true .) call test % test ( isSorted ( br1D ), 'Mergesort_r1D' ) br1D = ar1D call arange ( ia1D , 1 , N ) call argsort ( br1D , ia1D ,. true .) call test % test ( isSorted ( br1D , ia1D ), 'argMergesort_r1D' ) b1D = a1D call sort ( b1D ) call test % test ( isSorted ( b1D ), 'Introsort_d1D on Sorted array' ) b1D = a1D call arange ( ia1D , 1 , N ) call argsort ( b1D , ia1D ) call test % test ( isSorted ( b1D , ia1D ), 'argIntrosort_d1D' ) b1D = a1D call Sort ( b1D ,. true .) call test % test ( isSorted ( b1D ), 'Mergesort_d1D' ) b1D = a1D call arange ( ia1D , 1 , N ) call argsort ( b1D , ia1D ,. true .) call test % test ( isSorted ( b1D , ia1D ), 'argMergesort_d1D' ) call rngInteger ( ia1D , 1 , N ) ib1D = ia1D call sort ( ib1D ) call test % test ( isSorted ( ib1D ), 'Introsort_i1D' ) ib1D = ia1D call arange ( ic1D , 1 , N ) call argsort ( ib1D , ic1D ) call test % test ( isSorted ( ib1D , ic1D ), 'argIntrosort_i1D' ) ib1D = ia1D call sort ( ib1D ,. true .) call test % test ( isSorted ( ib1D ), 'Mergesort_i1D' ) ib1D = ia1D call arange ( ic1D , 1 , N ) call argsort ( ib1D , ic1D ,. true .) call test % test ( isSorted ( ib1D , ic1D ), 'argMergesort_i1D' ) end subroutine !====================================================================! end module","loc":"sourcefile/m_sort.f90.html","tags":""},{"title":"m_KdTree.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_kdtree.f90~~EfferentGraph sourcefile~m_kdtree.f90 m_KdTree.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90 m_iDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_select.f90 m_select.f90 sourcefile~m_errors.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90 m_array1D.f90 sourcefile~m_errors.f90->sourcefile~m_array1d.f90 sourcefile~m_maths.f90 m_maths.f90 sourcefile~m_errors.f90->sourcefile~m_maths.f90 sourcefile~m_dargdynamicarray.f90 m_dArgDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_random.f90 m_random.f90 sourcefile~m_errors.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_reallocate.f90 m_reallocate.f90 sourcefile~m_errors.f90->sourcefile~m_reallocate.f90 sourcefile~m_sort.f90 m_sort.f90 sourcefile~m_errors.f90->sourcefile~m_sort.f90 sourcefile~m_ddynamicarray.f90 m_dDynamicArray.f90 sourcefile~m_errors.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_idynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_allocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_allocate.f90->sourcefile~m_select.f90 sourcefile~m_allocate.f90->sourcefile~m_array1d.f90 sourcefile~m_allocate.f90->sourcefile~m_maths.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_random.f90 sourcefile~m_allocate.f90->sourcefile~m_reallocate.f90 sourcefile~m_allocate.f90->sourcefile~m_sort.f90 sourcefile~m_allocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_kdtree.f90 sourcefile~m_deallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_deallocate.f90->sourcefile~m_select.f90 sourcefile~m_deallocate.f90->sourcefile~m_array1d.f90 sourcefile~m_deallocate.f90->sourcefile~m_maths.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_random.f90 sourcefile~m_deallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_select.f90->sourcefile~m_kdtree.f90 sourcefile~m_select.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_kdtree.f90 sourcefile~m_array1d.f90->sourcefile~m_select.f90 sourcefile~m_array1d.f90->sourcefile~m_maths.f90 sourcefile~m_array1d.f90->sourcefile~m_random.f90 sourcefile~m_array1d.f90->sourcefile~m_sort.f90 sourcefile~m_maths.f90->sourcefile~m_kdtree.f90 sourcefile~m_dargdynamicarray.f90->sourcefile~m_kdtree.f90 sourcefile~m_strings.f90->sourcefile~m_kdtree.f90 sourcefile~m_strings.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_strings.f90->sourcefile~m_random.f90 sourcefile~m_strings.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_random.f90->sourcefile~m_kdtree.f90 sourcefile~m_random.f90->sourcefile~m_select.f90 sourcefile~m_random.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_kdtree.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_select.f90 sourcefile~m_variablekind.f90->sourcefile~m_array1d.f90 sourcefile~m_variablekind.f90->sourcefile~m_maths.f90 sourcefile~m_variablekind.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_random.f90 sourcefile~m_searching.f90 m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_searching.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90->sourcefile~m_reallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_sort.f90 sourcefile~m_variablekind.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_searching.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_searching.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 sourcefile~m_unittester.f90->sourcefile~m_select.f90 sourcefile~m_unittester.f90->sourcefile~m_array1d.f90 sourcefile~m_unittester.f90->sourcefile~m_maths.f90 sourcefile~m_unittester.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_random.f90 sourcefile~m_unittester.f90->sourcefile~m_reallocate.f90 sourcefile~m_unittester.f90->sourcefile~m_sort.f90 sourcefile~m_unittester.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_reallocate.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_idynamicarray.f90 sourcefile~m_sort.f90->sourcefile~m_select.f90 sourcefile~m_sort.f90->sourcefile~m_maths.f90 sourcefile~m_sort.f90->sourcefile~m_ddynamicarray.f90 sourcefile~m_ddynamicarray.f90->sourcefile~m_dargdynamicarray.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 var pansourcefilem_kdtreef90EfferentGraph = svgPanZoom('#sourcefilem_kdtreef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_KdTree Source Code m_KdTree.f90 Source Code module m_KdTree !!# KdTree !!Build and search k-dimensional trees in 2, 3, and K dimensions. !!This KdTree is balanced, in that splits are made along the dimension with the largest variance. !!A quickselect is used to quickly find the median in each splitting dimension as the splitting value. !!The ends of each branch contain multiple leaves to prevent tail recursion. !!An in-depth example is given below on how to use all the aspects of the KdTree and KdTreeSearch classes. !! !!Important: Once a tree has been built with a set, do not change their values.  The KdTree does NOT make !!a copy of the input values used to build it. !!Important: Generating the tree does not modify the values used to build it. !! !!## Building the KdTree !!The KdTree object can be initialized on assignment by entering point co-ordinates. !!To build a 2-D tree, you can use two 1-D arrays as the x, y, co-ordinates, and optionally a third 1-D array !!to build a 3-D tree. !!```fortran !!use m_KdTree !!type(KdTree) :: tree !!tree = KdTree(x, y, [z]) !!``` !!Or you can build a k-dimensional tree using a 2-D array, where the first dimension is the number of items, !!and the second is the number of dimensions, k. !!```fortran !!use m_KdTree !!type(KdTree) :: tree !!tree = KdTree(D) !!``` !! !!## Querying the KdTree !!After the tree is initialized, a search class can be used to perform search for the nearest neighbour, !!the k nearest neighbours, all neighbours within a radius, k nearest within a radius, and items within !!upper and lower bounds in each dimension. !!The searches are thread safe and can be used in a parallel region. !! !!After the KdTree is built, various queries can be carried out.  Searches that return multiple values !!are called using the argDynamicArray within coretran. The [[m_dArgDynamicArray]] contains an integer index !!containing the indices into the co-ordinates that are closest, and a double precision that contains the !!distance from the query point to those points. !! !!```fortran !!use m_dArgDynamicArray !!use m_KdTree !!type(KdTreeSearch) :: search !!integer(i32) :: i !!type(dArgDynamicArray) :: da !!! Nearest Neighbour to (0, 0), for 3D add z, and zQuery !!i = search%nearest(tree, x, y, [z], xQuery = 0.d0, yQuery = 0.d0, [zQuery = 0.d0]) !!! K-Nearest to (0, 0), for 3D add z, and zQuery !!da = search%kNearest(tree, x, y, [z], xQuery = 0.d0, yQuery = 0.d0, [zQuery = 0.d0], k = 10) !!! Search for all points within a given distance !!da = search%kNearest(tree, x, y, [z], xQuery = 0.d0, yQuery = 0.d0, [zQuery = 0.d0], radius = 10.d0) !!! Search for all k points within a given distance !!da = search%kNearest(tree, x, y, [z], xQuery = 0.d0, yQuery = 0.d0, [zQuery = 0.d0], k = 10, radius = 10.d0) !!``` !! !!## Full Example !!```fortran !!program kdTree_test !!use variableKind, only: i32, r64 !!use m_allocate, only: allocate !!use m_deallocate, only: deallocate !!use m_random, only: rngNormal !!use m_KdTree, only: KdTree, KdTreeSearch !!use m_dArgDynamicArray, only: dArgDynamicArray !!use m_string, only: str !!implicit none !!real(r64), allocatable :: x(:), y(:), z(:), D(:,:) !!integer(i32) :: ia, N !!type(KdTree) :: tree !!type(KdSearch) :: search !!type(dArgDynamicArray) :: da !! !!!====================================================================! !!! 2D KdTree example !!!====================================================================! !!! Create some random points in space !!N = 1d6 !!call allocate(x, N) !!call allocate(y, N) !!call rngNormal(x) !!call rngNormal(y) !!! Build the tree !!tree = KdTree(x, y) !!! Get the nearest neighbour to (0, 0) !!ia = search%kNearest(tree, x, y, xQuery = 0.d0, yQuery = 0.d0) !!write(*,'(a)') 'Nearest point to the query location: '//str(x(ia))//str(y(ia)) !!! Get the 10 nearest neighbours to the query !!da = search%kNearest(tree, x, y, xQuery = 0.d0, yQuery = 0.d0, k = 10) !!write(*,'(a)') 'The 10 nearest neighbour indices and distances:' !!call da%print() !!! Find all the points within a 1.d0 !!da = search%kNearest(tree, x, y, xQuery = 0.d0, yQuery = 0.d0, radius = 1.d0) !!write(*,'(a)') 'The points within a distance of 1.d0' !!call da%print() !!Deallocate any tree memory !!call tree%deallocate() !! !!!====================================================================! !!! 3D KdTree example !!!====================================================================! !!! Create the third dimension !!call allocate(z, N) !!call rngNormal(z) !!! Build the tree !!tree = KdTree(x, y, z) !!! Get the nearest neighbour to (0, 0, 0) !!ia = search%kNearest(tree, x, y, z, xQuery = 0.d0, yQuery = 0.d0, zQuery = 0.d0) !!write(*,'(a)')'Nearest point to the query location: '//str(x(ia))//str(y(ia))//str(z(ia)) !!! Get the 10 nearest neighbours to the query !!da = search%kNearest(tree, x, y, z, xQuery = 0.d0, yQuery = 0.d0, zQuery = 0.d0, k = 10) !!write(*,'(a)') 'The 10 nearest neighbour indices and distances:' !!call da%print() !!! Find all the points within a 1.d0 !!da = search%kNearest(tree, x, y, z, xQuery = 0.d0, yQuery = 0.d0, zQuery = 0.d0, radius = 1.d0) !!write(*,'(a)') 'The points within a distance of 1.d0' !!call da%print() !!Deallocate any tree memory !!call tree%deallocate() !! !!!====================================================================! !!! KD KdTree example !!!====================================================================! !!call allocate(D, [N, 3]) !!D(:,1) = x !!D(:,2) = y !!D(:,3) = z !!! Build the tree !!tree = KdTree(D) !!! Get the nearest neighbour to (0, 0, 0) !!ia = search%kNearest(tree, D, query = [0.d0, 0.d0, 0.d0]) !!write(*,'(a)')'Nearest point to the query location: '//str(D(ia, 1))//str(D(ia, 2))//str(D(ia, 3)) !!! Get the 10 nearest neighbours to the query !!da = search%kNearest(tree, D, query = [0.d0, 0.d0, 0.d0], k = 10) !!write(*,'(a)') 'The 10 nearest neighbour indices and distances:' !!call da%print() !!! Find all the points within a 1.d0 !!da = search%kNearest(tree, D,  query = [0.d0, 0.d0, 0.d0], radius = 1.d0) !!write(*,'(a)') 'The points within a distance of 1.d0' !!call da%print() !!Deallocate any tree memory !!call tree%deallocate() !!call deallocate(x) !!call deallocate(y) !!call deallocate(z) !!call deallocate(D) !!end program !!``` use variableKind , only : i32 , r64 use m_errors , only : eMsg , mErr use m_allocate , only : allocate use m_deallocate , only : deallocate use m_array1D , only : arange use m_random , only : rngNormal use m_select , only : argSelect use m_maths , only : variance use m_iDynamicArray , only : iDynamicArray use m_dArgDynamicArray , only : dArgDynamicArray use m_strings , only : str implicit none private !====================================================================! ! Type Definitions !====================================================================! !====================================================================! type , private :: KdTreebranch private !! A branch of the tree, could be a leaf, or branch integer ( i32 ) :: splitAlong !index of median in dat d real ( r64 ) :: median !median value in dat x integer ( i32 ) :: left , right ! left and right indices type ( KdTreeBranch ), pointer :: buds (:) => null () contains procedure :: init => init_branch !! KdTreeBranch%init() - Initialize the class procedure :: deallocate => deallocate_branch !! KdTreeBranch%deallocate() - deallocate the branch end type !====================================================================! !====================================================================! type , public :: KdTree !!KdTree in 2, 3, or N dimensions.  See [[m_KdTree]] for more information on how to use this class. private type ( KdTreebranch ) :: trunk integer ( i32 ), allocatable :: indx (:) integer ( i32 ) :: nDims integer ( i32 ) :: N logical ( i32 ) :: set = . false . contains procedure , public :: deallocate => deallocate_KdTree !! kdTree%deallocate() - deallocate the recursive pointers end type !====================================================================! !====================================================================! type , public :: KdTreeSearch !!Class to search a KdTree.  See [[m_KdTree]] for more information on how to use this class. contains generic , public :: nearest => nearest2D , nearest3D , nearestKD !! KdTreeSearch%nearest() - Perform a nearest neighbour search procedure , private :: nearest2D => nearest_2D !! Overloaded type bound procedure with KdTreeSearch%nearest() procedure , private :: nearest3D => nearest_3D !! Overloaded type bound procedure with KdTreeSearch%nearest() procedure , private :: nearestKD => nearest_KD !! Overloaded type bound procedure with KdTreeSearch%nearest() generic , public :: kNearest => kNearest2D , kNearest3D , kNearestKD !! KdTreeSearch%kNearest() - Perform a k nearest neighbour search or a radius search. procedure , private :: kNearest2D => kNearest_2D !! Overloaded type bound procedure with KdTreeSearch%kNearest() procedure , private :: kNearest3D => kNearest_3D !! Overloaded type bound procedure with KdTreeSearch%kNearest() procedure , private :: kNearestKD => kNearest_KD !! Overloaded type bound procedure with KdTreeSearch%kNearest() generic , public :: rangeSearch => rangeSearch2D , rangeSearch3D , rangeSearchKD !! KdTreeSearch%rangeSearch() - Find all points within axis aligned lower and upper bounds procedure , private :: rangeSearch2D => rangeSearch_2D !! Overloaded type bound procedure with KdTreeSearch%rangeSearch() procedure , private :: rangeSearch3D => rangeSearch_3D !! Overloaded type bound procedure with KdTreeSearch%rangeSearch() procedure , private :: rangeSearchKD => rangeSearch_KD !! Overloaded type bound procedure with KdTreeSearch%rangeSearch() end type !====================================================================! !====================================================================! ! Interface definitions !====================================================================! interface !====================================================================! module subroutine init_branch ( this , left , right ) !! Overloaded Type bound procedure KdTreeBranch%init() !====================================================================! class ( KdTreebranch ) :: this !! KdTreeBranch class integer ( i32 ), intent ( in ) :: left !! Left index, first call normally = 1 integer ( i32 ), intent ( in ) :: right !! Right index, first call normally = size of coordinates end subroutine !====================================================================! !====================================================================! module recursive subroutine deallocate_branch ( this ) !====================================================================! class ( KdTreebranch ) :: this !! KdTreeBranch class end subroutine !====================================================================! end interface interface KdTree !!Overloaded Initializer for a KdTree. !! !!Can be used to create a 2D, 3D, or ND, KdTree class. !! !!See [[m_KdTree]] for more information on how to use this class !====================================================================! module function init2D_KdTree ( x , y ) result ( this ) !! Overloaded by interface [[KdTree(type)]] !====================================================================! type ( kdTree ) :: this !! KdTree Class real ( r64 ), intent ( in ) :: x (:) !! x-coordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y-coordinates of the points end function !====================================================================! !====================================================================! module function init3D_KdTree ( x , y , z ) result ( this ) !! Overloaded by interface [[KdTree(type)]] !====================================================================! type ( kdTree ) :: this !! KdTree Class real ( r64 ), intent ( in ) :: x (:) !! x-coordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y-coordinates of the points real ( r64 ), intent ( in ) :: z (:) !! z-coordinates of the points end function !====================================================================! !====================================================================! module function initKD_KdTree ( D ) result ( this ) !! Overloaded by interface [[KdTree(type)]] !====================================================================! type ( kdTree ) :: this !! KdTree Class real ( r64 ), intent ( in ) :: D (:,:) !! Coordinates of the points, the k columns contain the k dimensional values. end function !====================================================================! end interface interface !====================================================================! module subroutine deallocate_KdTree ( this ) !! Overloaded Type bound procedure KdTree%deallocate() !====================================================================! class ( KdTree ) :: this !! KdTree Class end subroutine !====================================================================! end interface interface !====================================================================! module function nearest_2D ( search , tree , x , y , xQuery , yQuery ) result ( nearest ) !! Overloaded Type bound procedure KdTreeSearch%nearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points real ( r64 ), intent ( in ) :: xQuery !! x co-ordinate of the query location real ( r64 ), intent ( in ) :: yQuery !! y co-ordinate of the query location integer ( i32 ) :: nearest !! Index of the nearest point to the query location end function !====================================================================! !====================================================================! module function nearest_3D ( search , tree , x , y , z , xQuery , yQuery , zQuery ) result ( nearest ) !! Overloaded Type bound procedure KdTreeSearch%nearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points real ( r64 ), intent ( in ) :: z (:) !! z co-ordinates of the points real ( r64 ), intent ( in ) :: xQuery !! x co-ordinate of the query location real ( r64 ), intent ( in ) :: yQuery !! y co-ordinate of the query location real ( r64 ), intent ( in ) :: zQuery !! z co-ordinate of the query location integer ( i32 ) :: nearest !! Index of the nearest point to the query location end function !====================================================================! !====================================================================! module function nearest_KD ( search , tree , D , query ) result ( nearest ) !! Overloaded Type bound procedure KdTreeSearch%nearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: D (:,:) !! Co-ordinates of the points, the second dimension contains the k dimensions real ( r64 ), intent ( in ) :: query (:) !! C-ordinate of the query location integer ( i32 ) :: nearest !! Index of the nearest point to the query location end function !====================================================================! end interface interface !====================================================================! module function kNearest_2D ( search , tree , x , y , xQuery , yQuery , k , radius ) result ( kNearest ) !! Overloaded Type bound procedure KdTreeSearch%kNearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points real ( r64 ), intent ( in ) :: xQuery !! x co-ordinate of the query location real ( r64 ), intent ( in ) :: yQuery !! y co-ordinate of the query location integer ( i32 ), intent ( in ), optional :: k !! Number of points to find that are closest to the query real ( r64 ), intent ( in ), optional :: radius !! Only find neighbours within this distance from the query type ( dArgDynamicArray ) :: kNearest !! Indices of the nearest points to the query location end function !====================================================================! !====================================================================! module function kNearest_3D ( search , tree , x , y , z , xQuery , yQuery , zQuery , k , radius ) result ( kNearest ) !! Overloaded Type bound procedure KdTreeSearch%kNearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points real ( r64 ), intent ( in ) :: z (:) !! z co-ordinates of the points real ( r64 ), intent ( in ) :: xQuery !! x co-ordinate of the query location real ( r64 ), intent ( in ) :: yQuery !! y co-ordinate of the query location real ( r64 ), intent ( in ) :: zQuery !! z co-ordinate of the query location integer ( i32 ), intent ( in ), optional :: k !! Number of points to find that are closest to the query real ( r64 ), intent ( in ), optional :: radius !! Only find neighbours within this distance from the query type ( dArgDynamicArray ) :: kNearest !! Indices of the nearest points to the query location end function !====================================================================! !====================================================================! module function kNearest_KD ( search , tree , D , query , k , radius ) result ( kNearest ) !! Overloaded Type bound procedure KdTreeSearch%kNearest() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: D (:,:) !! Co-ordinates of the points, the second dimension contains the k dimensions real ( r64 ), intent ( in ) :: query (:) !! Co-ordinate of the query location integer ( i32 ), intent ( in ), optional :: k !! Number of points to find that are closest to the query real ( r64 ), intent ( in ), optional :: radius !! Only find neighbours within this distance from the query type ( dArgDynamicArray ) :: kNearest !! Indices of the nearest points to the query location end function !====================================================================! end interface interface !====================================================================! module function rangeSearch_2D ( search , tree , x , y , lowerBound , upperBound ) result ( iPoints ) !! Overloaded Type bound procedure KdTreeSearch%rangeSearch() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points. real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points. real ( r64 ), intent ( in ) :: lowerBound ( 2 ) !! Lower bounds in x and y for the range search [xLow, yLow]. real ( r64 ), intent ( in ) :: upperBound ( 2 ) !! Upper bounds in x and y for the range search [xHigh, yHigh]. type ( iDynamicArray ) :: iPoints !! Indices of the points inside the axis aligned range. end function !====================================================================! !====================================================================! module function rangeSearch_3D ( search , tree , x , y , z , lowerBound , upperBound ) result ( iPoints ) !! Overloaded Type bound procedure KdTreeSearch%rangeSearch() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: x (:) !! x co-ordinates of the points. real ( r64 ), intent ( in ) :: y (:) !! y co-ordinates of the points. real ( r64 ), intent ( in ) :: z (:) !! y co-ordinates of the points. real ( r64 ), intent ( in ) :: lowerBound ( 3 ) !! Lower bounds in x and y for the range search [xLow, yLow]. real ( r64 ), intent ( in ) :: upperBound ( 3 ) !! Upper bounds in x and y for the range search [xHigh, yHigh]. type ( iDynamicArray ) :: iPoints !! Indices of the points inside the axis aligned range. end function !====================================================================! !====================================================================! module function rangeSearch_KD ( search , tree , D , lowerBound , upperBound ) result ( iPoints ) !! Overloaded Type bound procedure KdTreeSearch%rangeSearch() !====================================================================! class ( KdTreeSearch ), intent ( inout ) :: search !! KdTreeSearch class class ( kdTree ), intent ( in ) :: tree !! KdTree class real ( r64 ), intent ( in ) :: D (:,:) !! Co-ordinates of the points, the second dimension contains the k dimensions real ( r64 ), intent ( in ) :: lowerBound ( size ( D , 2 )) !! Lower bounds in each dimension for the range search [Low1, Low2, ..., LowK]. real ( r64 ), intent ( in ) :: upperBound ( size ( D , 2 )) !! Upper bounds in each dimension for the range search [High1, High2, ..., HighK]. type ( iDynamicArray ) :: iPoints !! Indices of the points inside the axis aligned range. end function !====================================================================! end interface end module","loc":"sourcefile/m_kdtree.f90.html","tags":""},{"title":"m_time.f90 – Fortran Program","text":"This File Depends On sourcefile~~m_time.f90~~EfferentGraph sourcefile~m_time.f90 m_time.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_errors.f90->sourcefile~m_time.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~m_time.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_unittester.f90->sourcefile~m_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~m_time.f90~~AfferentGraph sourcefile~m_time.f90 m_time.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~m_time.f90->sourcefile~progressbar_class.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_time.f90->sourcefile~stopwatch_class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules m_time Source Code m_time.f90 Source Code module m_time !! Contains functions that handle time use variableKind use m_errors , only : msg use m_unitTester , only : tester implicit none contains !=====================================================================! function timeinseconds ( values ) result ( res ) !! Convert hours minutes seconds etc. to seconds !=====================================================================! integer ( i32 ) :: values ( 8 ) !! values containing amounts of days hours etc. real ( r64 ) :: res !! time in seconds res = dble (( 86400 * values ( 3 )) + ( 3600 * values ( 5 )) + ( 60 * values ( 6 )) + values ( 7 ))& + ( 0.001d0 * dble ( values ( 8 ))) end function !=====================================================================! !=====================================================================! function daysinMonth ( month , year ) result ( days ) !! Get the number of days in a month. Accounts for leap years !=====================================================================! integer ( i32 ) :: month !! How many days in this month integer ( i32 ), optional :: year !! Check if a leap year? integer ( i32 ) :: days !! Number of days days = 0 select case ( month ) case ( 1 , 3 , 5 , 7 , 8 , 10 , 12 ) days = 31 case ( 2 ) days = 28 if ( present ( year )) then if ( isLeapYear ( year )) days = 29 endif case ( 4 , 6 , 9 , 11 ) days = 30 end select end function !=====================================================================! !=====================================================================! function daysinYear ( year ) result ( days ) !! Get the number of days in a year, accounts for leap years !=====================================================================! integer ( i32 ) :: year !! How many days in this year integer ( i32 ) :: days !! Number of days days = 365 if ( isLeapYear ( year )) days = 366 end function !=====================================================================! !=====================================================================! function isLeapYear ( year ) result ( yes ) !! Determine whether the year is a leap year !=====================================================================! integer ( i32 ) :: year !! Year to check logical :: yes !! is a leap year yes = . false . if ( iand ( year , 3 ) == 0 . and . ( mod ( year , 25 ) /= 0 . or . iand ( year , 15 ) == 0 )) yes = . true . end function !=====================================================================! !=====================================================================! function absTimetoHMS ( t ) result ( res ) !! Convert an absolute time to HH:MM:SS.MSEC !=====================================================================! real ( r64 ) :: t !! Time in seconds character ( len = 22 ) :: res !! Resulting string contains the time integer ( i32 ) :: days , hrs , min , sec , msec real ( r64 ) :: tmp days = floor ( t / 8640 0.d0 ); tmp = t - ( dble ( days * 86400 )) hrs = floor ( tmp / 360 0.d0 ); tmp = tmp - ( dble ( hrs * 3600 )) hrs = hrs + ( 24 * days ) min = floor ( tmp / 6 0.d0 ); tmp = tmp - ( dble ( min * 60 )) sec = floor ( tmp ); msec = int ( 1000 * ( tmp - ( dble ( sec )))) write ( res , 10 ) hrs , min , sec , msec 10 format ( i0 , ':' , i2 , ':' , i2 , '.' , i3 , ' (h:m:s)' ) end function !=====================================================================! !=====================================================================! subroutine time_test ( test ) !! graph: false !=====================================================================! class ( tester ) :: test call Msg ( '==========================' ) call Msg ( 'Testing : time' ) call Msg ( '==========================' ) call test % test ( timeinseconds ([ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 8 ]) == 8.d-3 , 'timeinseconds' ) call test % test ( timeinseconds ([ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) == 1.d0 , 'timeinseconds' ) call test % test ( timeinseconds ([ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ]) == 6 0.d0 , 'timeinseconds' ) call test % test ( timeinseconds ([ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ]) == 360 0.d0 , 'timeinseconds' ) call test % test ( timeinseconds ([ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ]) == 8640 0.d0 , 'timeinseconds' ) call test % test ( timeinseconds ([ 0 , 0 , 1 , 0 , 1 , 1 , 1 , 8 ]) == 9006 1.008d0 , 'timeinseconds' ) call test % test ( daysinMonth ( 2 , 2012 ) == 29 , 'daysinMonth' ) call test % test ( daysinMonth ( 2 , 2014 ) == 28 , 'daysinMonth' ) call test % test ( daysinYear ( 2012 ) == 366 , 'daysinYear' ) call test % test ( isLeapYear ( 2012 ). eqv . . true ., 'isLeapYear' ) call test % test ( absTimetoHMS ( 9003 1.008d0 ) == '25: 0:31.  8 (h:m:s)' , 'absTimetoHMS' ) end subroutine !=====================================================================! end module","loc":"sourcefile/m_time.f90.html","tags":""},{"title":"ProgressBar_Class.f90 – Fortran Program","text":"This File Depends On sourcefile~~progressbar_class.f90~~EfferentGraph sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~progressbar_class.f90 sourcefile~m_variablekind.f90->sourcefile~stopwatch_class.f90 sourcefile~m_time.f90 m_time.f90 sourcefile~m_variablekind.f90->sourcefile~m_time.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_time.f90->sourcefile~progressbar_class.f90 sourcefile~m_time.f90->sourcefile~stopwatch_class.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_errors.f90->sourcefile~m_time.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_time.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 var pansourcefileprogressbar_classf90EfferentGraph = svgPanZoom('#sourcefileprogressbar_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules ProgressBar_Class Source Code ProgressBar_Class.f90 Source Code module ProgressBar_Class !! An inline and updateable command prompt progress bar !! !! Example usage !!```fortran !!use variableKind !!use ProgressBar_Class !!type(ProgressBar) :: P !!integer(i32) :: i, N !!N = 100000 !!call P%set(N, time = .false.) !!call P%print(0) !!do i = 1, N !!  Compute some stuff !!  call P%print(i) !!enddo !!call P%set(N, time = .true.) !!call P%print(0) !!do i = 1, N !!  Compute some stuff !!  call P%print(i) !!enddo !!``` use iso_fortran_env , only : output_unit use variableKind , only : i32 , i64 , r32 , r64 use Stopwatch_Class use m_time , only : absTimetoHMS implicit none private type , public :: ProgressBar !! A progress bar that displays a moving counter with percentage and optional estimated time remaining private type ( Stopwatch ) :: clk !! Stopwatch to estimate time remaining character ( len = 14 ) :: title !! Give a title for the progress bar integer ( i64 ) :: N !! Total number of iterations integer ( i32 ) :: old1p !! 1% counter integer ( i32 ) :: old10p !! 10% counter integer ( i32 ) :: next1p !! 1% counter integer ( i32 ) :: next10p !! 10% counter logical :: time !! Provide an estimated time remaining? integer ( i32 ) :: iTime !! Counter to estimate time real ( r64 ) :: cumTime !! Cumulative time character ( len = 88 ) :: bar !! String to write the progress bar to output contains !generic, public :: set => set_i1_ProgressBar_,set_id1_ProgressBar_ !! Print the progress Bar !procedure, private :: set_i1_ProgressBar_ => set_i1_ProgressBar !procedure, private :: set_id1_ProgressBar_ => set_id1_ProgressBar !! Initialize the Progress Bar generic , public :: print => print_i1_ProgressBar_ , print_id1_ProgressBar_ !! Print the progress Bar procedure , private :: print_i1_ProgressBar_ => print_i1_ProgressBar procedure , private :: print_id1_ProgressBar_ => print_id1_ProgressBar end type interface ProgressBar module procedure ProgressBar_i1 !! Interfaced with class instantiation ProgressBar() module procedure ProgressBar_id1 !! Interfaced with class instantiation ProgressBar() end interface contains !====================================================================! function ProgressBar_i1 ( N , title , time ) result ( res ) !! Interfaced with class instantiation ProgressBar() !====================================================================! integer ( i32 ), intent ( in ) :: N !! Maximum expected number of iterations character ( len =* ), intent ( in ), optional :: title !! Title to give the progress bar logical , intent ( in ), optional :: time !! Show an estimated time to completion? type ( ProgressBar ) :: res res = ProgressBar_id1 ( int ( N , i64 ), title , time ) end function !====================================================================! !====================================================================! function ProgressBar_id1 ( N , title , time ) result ( res ) !! Interfaced with class instantiation ProgressBar() !====================================================================! integer ( i64 ), intent ( in ) :: N !! Maximum expected number of iterations character ( len =* ), intent ( in ), optional :: title !! Title to give the progress bar logical , intent ( in ), optional :: time !! Show an estimated time to completion? type ( ProgressBar ) :: res res % old1p = 0 res % old10p = 0 res % N = N write ( res % title , '(14x)' ) if ( present ( title )) res % title = title res % time = . false . if ( present ( time )) then res % time = time !    call res%clk%start() res % cumTime = 0.d0 res % iTime = 0 end if if ( res % time ) then res % bar = '     Completed:' // res % title // '-    % |          | Est. Remaining --:--:--.--- (h:m:s)' write ( output_unit , '(a1,a88)' , advance = 'no' ) char ( 13 ), res % bar else res % bar = '     Completed:' // res % title // '-    % |          |' write ( output_unit , '(a1,a48)' , advance = 'no' ) char ( 13 ), res % bar endif flush ( output_unit ) end function !====================================================================! !====================================================================! subroutine print_i1_ProgressBar ( this , i ) !! Interfaced with ProgressBar%print() !====================================================================! class ( ProgressBar ) :: this !! ProgressBar Class integer ( i32 ), intent ( in ) :: i !! Current iteration number call print_id1_ProgressBar ( this , int ( i , i64 )) end subroutine !====================================================================! !====================================================================! subroutine print_id1_ProgressBar ( this , i ) !! Interfaced with ProgressBar%print() !====================================================================! class ( ProgressBar ) :: this !! ProgressBar Class integer ( i64 ), intent ( in ) :: i !! Current iteration number integer ( i32 ) :: kk real ( r64 ) :: tmp real ( r64 ) :: avgTime integer ( i64 ) :: iTmp logical :: printMe ! If we are estimating the time left till completion printMe = . false . tmp = dble ( i ) / dble ( this % N ) ! Get the current 1% discretization this % next1p = int ( tmp * 10 0.d0 ) ! Current 1% ! Get the current 10% discretization this % next10p = int ( mod ( tmp * 1 0.d0 , 1 0.d0 )) ! Current 10% ! Check for 100% if ( this % next1p == 100 ) this % next10p = 10 ! Avoids write out error ! If the 10% level has changed, add a counter to the progress bar kk = 37 + this % next10p if ( this % next10p > this % old10p ) then this % bar ( kk : kk ) = '=' ! Write the bar this % old10p = this % next10p end if ! If the 1% has changed, update the bar and print if ( this % next1p > this % old1p ) then ! Write % to the bar write ( this % bar ( 32 : 34 ), '(i3)' ) this % next1p ! Update the output this % old1p = this % next1p printMe = . true . end if if ( this % time ) then this % iTime = this % iTime + 1 iTmp = this % N / 200 if ( this % iTime == iTmp ) then ! Get the time for this many iterations this % cumTime = this % cumTime + this % clk % lapInSeconds () ! Get the average time per iteration avgTime = this % cumTime / dble ( i ) ! Estimate time left my multiplying average time by iterations left. avgTime = avgTime * dble ( this % N - i ) if ( avgTime > 1.d-7 ) write ( this % bar ( 65 : 88 ), '(a22)' ) absTimetoHMS ( avgTime ) printMe = . true . endif if ( this % iTime > iTmp ) this % iTime = 0 if ( this % next10p == 10 ) this % bar ( 50 : 88 ) = 'Finished in ' // this % clk % elapsed () end if if ( printMe ) then if ( this % time ) then write ( output_unit , '(a1,a88)' , advance = 'no' ) char ( 13 ), this % bar else write ( output_unit , '(a1,a48)' , advance = 'no' ) char ( 13 ), this % bar endif flush ( output_unit ) endif if ( this % next10p == 10 ) write ( output_unit , * ) end subroutine !====================================================================! end module","loc":"sourcefile/progressbar_class.f90.html","tags":""},{"title":"Stopwatch_Class.f90 – Fortran Program","text":"This File Depends On sourcefile~~stopwatch_class.f90~~EfferentGraph sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_strings.f90->sourcefile~stopwatch_class.f90 sourcefile~m_variablekind.f90 m_variableKind.f90 sourcefile~m_variablekind.f90->sourcefile~stopwatch_class.f90 sourcefile~m_variablekind.f90->sourcefile~m_strings.f90 sourcefile~m_time.f90 m_time.f90 sourcefile~m_variablekind.f90->sourcefile~m_time.f90 sourcefile~m_errors.f90 m_errors.f90 sourcefile~m_variablekind.f90->sourcefile~m_errors.f90 sourcefile~m_parameters.f90 m_parameters.f90 sourcefile~m_variablekind.f90->sourcefile~m_parameters.f90 sourcefile~m_allocate.f90 m_allocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_allocate.f90 sourcefile~m_deallocate.f90 m_deallocate.f90 sourcefile~m_variablekind.f90->sourcefile~m_deallocate.f90 sourcefile~m_unittester.f90 m_unitTester.f90 sourcefile~m_variablekind.f90->sourcefile~m_unittester.f90 sourcefile~m_time.f90->sourcefile~stopwatch_class.f90 sourcefile~m_errors.f90->sourcefile~m_strings.f90 sourcefile~m_errors.f90->sourcefile~m_time.f90 sourcefile~m_errors.f90->sourcefile~m_allocate.f90 sourcefile~m_errors.f90->sourcefile~m_deallocate.f90 sourcefile~m_errors.f90->sourcefile~m_unittester.f90 sourcefile~m_parameters.f90->sourcefile~m_strings.f90 sourcefile~m_allocate.f90->sourcefile~m_strings.f90 sourcefile~m_deallocate.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_strings.f90 sourcefile~m_unittester.f90->sourcefile~m_time.f90 sourcefile~m_unittester.f90->sourcefile~m_allocate.f90 var pansourcefilestopwatch_classf90EfferentGraph = svgPanZoom('#sourcefilestopwatch_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~stopwatch_class.f90~~AfferentGraph sourcefile~stopwatch_class.f90 Stopwatch_Class.f90 sourcefile~progressbar_class.f90 ProgressBar_Class.f90 sourcefile~stopwatch_class.f90->sourcefile~progressbar_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules Stopwatch_Class Source Code Stopwatch_Class.f90 Source Code module Stopwatch_Class !! Contains code timing capabilities !! !! Example usage !!```fortran !!program stopwatch_test !!use variableKind, only: i32 !!use Stopwatch_Class, only: Stopwatch !!type(Stopwatch) :: clk !!integer(i32) :: i, N !!call clk%start('Some Title') !!N = 100000 !!do i = 1, N !!  Compute some stuff !!enddo !!call clk%stop() !!call clk%elapsed() !!write(*,'(a)') 'Finished on '//clk%datetime() !!end program !!``` use iso_fortran_env , only : output_unit use variableKind , only : i32 , r64 use m_strings , only : str use m_time , only : absTimetoHMS , timeinseconds implicit none private type , public :: Stopwatch !! Class for timing sections of code, See the Stopwatch_Class module documentation for usage. private logical :: running = . false . integer ( i32 ) :: LapTime_ ( 8 ) = 0 integer ( i32 ) :: startTime_ ( 8 ) = 0 integer ( i32 ) :: stopTime_ ( 8 ) = 0 contains procedure , public :: start => start_Stopwatch !! Start the Stopwatch procedure , public :: stop => stop_Stopwatch !! Stop the Stopwatch procedure , public :: reset => reset_Stopwatch !! Reset the Stopwatch procedure , public :: restart => restart_Stopwatch !! Restart the Stopwatch procedure , public :: time => time_Stopwatch !! Get the current or stopped time procedure , public :: lap => lap_Stopwatch !! Lap the Stopwatch procedure , public :: lapInSeconds => lapInSeconds_Stopwatch !! Get the lap time in seconds procedure , public :: elapsed => elapsed_Stopwatch !! Get the current elapsed time procedure , public :: elapsedInSeconds => elapsedInSeconds_Stopwatch !! Get the elapsed time in seconds procedure , public :: date => date_Stopwatch !! Print the date procedure , public :: dateAndTime => dateAndTime_Stopwatch !! Print the date and time end type contains !=====================================================================! subroutine start_Stopwatch ( this , title , iunit ) !! Start the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len =* ), optional :: title !! Name to label the start of the stopwatch integer ( i32 ), optional :: iunit !! File ID to write to if (. not . this % running ) then this % running = . true . call date_and_time ( values = this % StartTime_ ) this % LapTime_ = this % StartTime_ if ( present ( title )) then if ( present ( iunit )) then write ( iunit , '(a)' ) trim ( title ) // ' started on: ' // trim ( this % dateAndTime ()) write ( output_unit , '(a)' ) trim ( title ) // ' started on: ' // trim ( this % dateAndTime ()) else write ( output_unit , '(a)' ) trim ( title ) // ' started on: ' // trim ( this % dateAndTime ()) endif endif endif end subroutine !=====================================================================! !=====================================================================! subroutine stop_Stopwatch ( this , title , iunit ) !! Stop the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len =* ), optional :: title !! Name to label the stopped stopwatch integer ( i32 ), optional :: iunit !! File ID to write to if ( this % running ) then call date_and_time ( values = this % StopTime_ ) this % running = . false . if ( present ( title )) then if ( present ( iunit )) then write ( iunit , '(a)' ) trim ( title ) // ' finished on: ' // trim ( this % date ()) // ' in ' // str ( this % elapsedInSeconds ()) // '(s)' write ( output_unit , '(a)' ) trim ( title ) // ' finished on: ' // trim ( this % date ()) // ' in ' // str ( this % elapsedInSeconds ()) // '(s)' else write ( output_unit , '(a)' ) trim ( title ) // ' finished on: ' // trim ( this % date ()) // ' in ' // str ( this % elapsedInSeconds ()) // '(s)' endif endif endif end subroutine !=====================================================================! !=====================================================================! subroutine reset_Stopwatch ( this ) !! Reset the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class call this % stop () this % StartTime_ = 0 ; this % LapTime_ = 0 ; this % StopTime_ = 0 end subroutine !=====================================================================! subroutine restart_Stopwatch ( this ) !! Restart the Stopwatch !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class call this % reset () call this % start () end subroutine !=====================================================================! !=====================================================================! function elapsed_Stopwatch ( this ) result ( res ) !! Get the elapsed time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Elapsed time in format HH:MM:SS.MSEC res = absTimetoHMS ( this % elapsedInSeconds ()) end function !=====================================================================! !=====================================================================! function lap_Stopwatch ( this ) result ( res ) !! Get the lap time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Lap time in format HH:MM:SS.MSEC res = absTimetoHMS ( this % lapInSeconds ()) end function !=====================================================================! !=====================================================================! function lapInSeconds_Stopwatch ( this ) result ( res ) !! Get the lap time in seconds !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class real ( r64 ) :: res !! Laptime in seconds integer ( i32 ) :: tmp ( 8 ) if ( this % running ) then call date_and_time ( values = tmp ) res = timeinseconds ( tmp ) - timeinseconds ( this % lapTime_ ) this % laptime_ = tmp else res = timeinseconds ( this % StopTime_ ) - timeinseconds ( this % lapTime_ ) endif end function !=====================================================================! !=====================================================================! function elapsedInSeconds_Stopwatch ( this ) result ( res ) !! Get the elapsed time in seconds !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class real ( r64 ) :: res !! Elapsed time in seconds integer ( i32 ) :: tmp ( 8 ) if ( this % running ) then call date_and_time ( values = tmp ) res = timeinseconds ( tmp ) - timeinseconds ( this % StartTime_ ) else res = timeinseconds ( this % StopTime_ ) - timeinseconds ( this % StartTime_ ) endif end function !=====================================================================! !=====================================================================! function dateAndTime_Stopwatch ( this ) result ( res ) !! Get the date and time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Date and time in format DD/MM/YYYY HH:MM:SS.MSEC res = trim ( this % date ()) // ' at ' // trim ( this % time ()) end function !=====================================================================! !=====================================================================! function date_Stopwatch ( this ) result ( res ) !! Get the date !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Date in format DD/MM/YYYY integer ( i32 ) :: tmp ( 8 ) res = '' if ( this % running ) then call date_and_time ( values = tmp ) res = trim ( str ( tmp ( 3 ))) // '/' // trim ( str ( tmp ( 2 ))) // '/' // trim ( str ( tmp ( 1 ))) else res = trim ( str ( this % StopTime_ ( 3 ))) // '/' // trim ( str ( this % StopTime_ ( 2 ))) // '/' // trim ( str ( this % StopTime_ ( 1 ))) endif end function !=====================================================================! !=====================================================================! function time_Stopwatch ( this ) result ( res ) !! Get the time !=====================================================================! class ( Stopwatch ) :: this !! Stopwatch Class character ( len = :), allocatable :: res !! Time in format HH:MM:SS.MSEC integer :: tmp ( 8 ) res = '' if ( this % running ) then call date_and_time ( values = tmp ) res = trim ( str ( tmp ( 5 ))) // ':' // trim ( str ( tmp ( 6 ))) // ':' // trim ( str ( tmp ( 7 ))) // '.' // trim ( str ( tmp ( 8 ))) else res = trim ( str ( this % StopTime_ ( 5 ))) // ':' // trim ( str ( this % StopTime_ ( 6 ))) // ':' // trim ( str ( this % StopTime_ ( 7 ))) // '.' // trim ( str ( this % StopTime_ ( 8 ))) endif end function !=====================================================================! end module","loc":"sourcefile/stopwatch_class.f90.html","tags":""},{"title":"c_printOptions – Fortran Program ","text":"type, public :: c_printOptions Print options similar to numpy's print_options Variables precision threshold edgeitems nanstr infstr Components Type Visibility Attributes Name Initial integer(kind=i32), public :: precision = 3 Force this precision on the written number integer(kind=i32), public :: threshold = 10 Omit the middle entries if the size is greater than threshold integer(kind=i32), public :: edgeitems = 3 Only write the first and last threshold elements from rows and/or columns character(len=32), public :: nanstr = 'nan' Print NAN as this character(len=32), public :: infstr = 'inf' Print infinity as this","loc":"type/c_printoptions.html","tags":""},{"title":"tester – Fortran Program ","text":"type, public :: tester Constructor tester Type-Bound Procedures test summary Constructor public interface tester private function init_tester() result(this) Arguments None Return Value type( tester ) Type-Bound Procedures procedure, public :: test => test_tester private subroutine test_tester(this, l, msg) Arguments Type Intent Optional Attributes Name class( tester ) :: this logical :: l character(len=*) :: msg procedure, public :: summary => summary_tester private subroutine summary_tester(this) Arguments Type Intent Optional Attributes Name class( tester ) :: this","loc":"type/tester.html","tags":""},{"title":"dArgDynamicArray – Fortran Program ","text":"type, public :: dArgDynamicArray type~~dargdynamicarray~~InheritsGraph type~dargdynamicarray dArgDynamicArray iDynamicArray iDynamicArray iDynamicArray->type~dargdynamicarray i dDynamicArray dDynamicArray dDynamicArray->type~dargdynamicarray v Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Class that act as stacks, queues, and priority queues. See m_dArgDynamicArray for more information on how to use this class. Variables i v Constructor dArgDynamicArray Type-Bound Procedures append argOf deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend print remove tighten Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(dDynamicArray), public :: v Values. Constructor public interface dArgDynamicArray private function init_dArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[dArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dArgDynamicArray ) private function init_dArgDynamicArray_d1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[dArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) Set of value indices to initialize with. real(kind=r64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dArgDynamicArray ) Type-Bound Procedures procedure, public :: append => append_dArgDynamicArray dArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_dArgDynamicArray(this, i, val) Overloaded type bound procedure dArgDynamicArray%append(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this integer(kind=i32) :: i Index of value real(kind=r64) :: val Value to append procedure, public :: argOf => argOf_dArgDynamicArray dArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array private function argOf_dArgDynamicArray(this, val) result(i) Overloaded type bound procedure dArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this real(kind=r64) :: val Value to get the argument of. Return Value integer(kind=i32) Argument of the value. procedure, public :: deallocate => deallocate_dArgDynamicArray dArgDynamicArray%%deallocate() - Deallocate a dynamic array. private subroutine deallocate_dArgDynamicArray(this) Overloaded type bound procedure dArgDynamicArray%deallocate(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this procedure, public :: insertAt => insertAt_dArgDynamicArray dArgDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_dArgDynamicArray(this, loc, i, val) Overloaded type bound procedure dArgDynamicArray%insertAt(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this integer(kind=i32) :: loc Insert index and value at this location. integer(kind=i32) :: i index/ real(kind=r64) :: val Value/ procedure, public :: insertSorted => insertSorted_dArgDynamicArray dArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_dArgDynamicArray(this, i, val) Overloaded type bound procedure dArgDynamicArray%insertSorted(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this integer(kind=i32) :: i Index. real(kind=r64) :: val Value. procedure, public :: insertSortedUnique => insertSortedUnique_dArgDynamicArray dArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_dArgDynamicArray(this, i, val) Overloaded type bound procedure dArgDynamicArray%insertSortedUnique(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this integer(kind=i32) :: i Index. real(kind=r64) :: val Value. procedure, public :: isEmpty => isEmpty_dArgDynamicArray dArgDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_dArgDynamicArray(this) result(yes) Overloaded type bound procedure dArgDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_dArgDynamicArray dArgDynamicArray%isFilled() - True if the allocated memory has been filled. private function isFilled_dArgDynamicArray(this) result(yes) Overloaded type bound procedure dArgDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_dArgDynamicArray dArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_dArgDynamicArray(this, val) result(i) Overloaded type bound procedure dArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this real(kind=r64) :: val Value to get the argument of. Return Value integer(kind=i32) Index of the value. procedure, public :: prepend => prepend_dArgDynamicArray dArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_dArgDynamicArray(this, i, val) Overloaded type bound procedure dArgDynamicArray%prepend(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this integer(kind=i32) :: i Prepend indices with this index. real(kind=r64) :: val Prepend values with this value. procedure, public :: print => print_dArgDynamicArray dArgDynamicArray%print() - Print to the screen private subroutine print_dArgDynamicArray(this) Overloaded type bound procedure dArgDynamicArray%print() Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this procedure, public :: remove => remove_dArgDynamicArray dArgDynamicArray%remove() - Remove an element from the array. private subroutine remove_dArgDynamicArray(this, i) Overloaded type bound procedure dArgDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this integer(kind=i32) :: i Remove the elements at this location. procedure, public :: tighten => tighten_dArgDynamicArray dArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_dArgDynamicArray(this) Overloaded type bound procedure dArgDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( dArgDynamicArray ) :: this","loc":"type/dargdynamicarray.html","tags":""},{"title":"dDynamicArray – Fortran Program ","text":"type, public :: dDynamicArray Class that act as stacks, queues, and priority queues. See m_dDynamicArray for more information on how to use this class. Variables N values sorted fixed Constructor dDynamicArray Type-Bound Procedures append deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend reallocate remove tighten Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array real(kind=r64), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor public interface dDynamicArray private function init_dDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface dDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dDynamicArray ) Return type. private function init_dDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface dDynamicArray() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dDynamicArray ) Return type Type-Bound Procedures procedure, public :: append => append_dDynamicArray dDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_dDynamicArray(this, val) Overloaded type bound procedure dDynamicArray%append() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this real(kind=r64) :: val Value to append. procedure, public :: deallocate => deallocate_dDynamicArray dDynamicArray%deallocate() - Deallocate a dynamic array. private subroutine deallocate_dDynamicArray(this) Overloaded type bound procedure dDynamicArray%deallocate() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this procedure, public :: insertAt => insertAt_dDynamicArray dDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_dDynamicArray(this, i, val) Overloaded type bound procedure dDynamicArray%insertAt() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. real(kind=r64) :: val Insert this value. procedure, public :: insertSorted => insertSorted_dDynamicArray dDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_dDynamicArray(this, val) Overloaded type bound procedure dDynamicArray%insertSorted() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this real(kind=r64) :: val Insert this value. procedure, public :: insertSortedUnique => insertSortedUnique_dDynamicArray dDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_dDynamicArray(this, val) Overloaded type bound procedure dDynamicArray%insertSortedUnique() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this real(kind=r64) :: val Insert this value. procedure, public :: isEmpty => isEmpty_dDynamicArray dDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_dDynamicArray(this) result(yes) Overloaded type bound procedure dDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_dDynamicArray dDynamicArray%isFilled() - True if the array is filled. private function isFilled_dDynamicArray(this) result(yes) Overloaded type bound procedure dDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_dDynamicArray dDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_dDynamicArray(this, val) result(i) Overloaded type bound procedure dDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this real(kind=r64) :: val Get the location of this value Return Value integer(kind=i32) Location of value procedure, public :: prepend => prepend_dDynamicArray dDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_dDynamicArray(this, val) Overloaded type bound procedure dDynamicArray%prepend() Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this real(kind=r64) :: val Value to prepend. procedure, public :: reallocate => reallocate_dDynamicArray dDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. private subroutine reallocate_dDynamicArray(this, M) Overloaded type bound procedure dDynamicArray%reallocate(). Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this integer(kind=i32) :: M Reallocate memory to this size. procedure, public :: remove => remove_dDynamicArray dDynamicArray%remove() - Remove an element from the array. private subroutine remove_dDynamicArray(this, i) Overloaded type bound procedure dDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this integer(kind=i32) :: i Remove the value at this location. procedure, public :: tighten => tighten_dDynamicArray dDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_dDynamicArray(this) Overloaded type bound procedure dDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( dDynamicArray ) :: this","loc":"type/ddynamicarray.html","tags":""},{"title":"iArgDynamicArray – Fortran Program ","text":"type, public :: iArgDynamicArray type~~iargdynamicarray~~InheritsGraph type~iargdynamicarray iArgDynamicArray iDynamicArray iDynamicArray iDynamicArray->type~iargdynamicarray i, v Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Class that act as stacks, queues, and priority queues. See m_iArgDynamicArray for more information on how to use this class. Variables i v Constructor iArgDynamicArray Type-Bound Procedures append argOf deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend remove tighten Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(iDynamicArray), public :: v Values. Constructor public interface iArgDynamicArray private function init_iArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[iArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( iArgDynamicArray ) private function init_iArgDynamicArray_i1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[iArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) integer(kind=i32), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( iArgDynamicArray ) Type-Bound Procedures procedure, public :: append => append_iArgDynamicArray iArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_iArgDynamicArray(this, i, val) Overloaded type bound procedure iArgDynamicArray%append(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: i Index of value integer(kind=i32) :: val Value to append procedure, public :: argOf => argOf_iArgDynamicArray iArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array private function argOf_iArgDynamicArray(this, val) result(i) Overloaded type bound procedure iArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: val Value to get the argument of. Return Value integer(kind=i32) Argument of the value. procedure, public :: deallocate => deallocate_iArgDynamicArray iArgDynamicArray%%deallocate() - Deallocate a dynamic array. private subroutine deallocate_iArgDynamicArray(this) Overloaded type bound procedure iArgDynamicArray%deallocate(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this procedure, public :: insertAt => insertAt_iArgDynamicArray iArgDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_iArgDynamicArray(this, loc, i, val) Overloaded type bound procedure iArgDynamicArray%insertAt(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: loc Insert index and value at this location. integer(kind=i32) :: i index. integer(kind=i32) :: val Value. procedure, public :: insertSorted => insertSorted_iArgDynamicArray iArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_iArgDynamicArray(this, i, val) Overloaded type bound procedure iArgDynamicArray%insertSorted(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: i Index. integer(kind=i32) :: val Value. procedure, public :: insertSortedUnique => insertSortedUnique_iArgDynamicArray iArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_iArgDynamicArray(this, i, val) Overloaded type bound procedure iArgDynamicArray%insertSortedUnique(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: i Index. integer(kind=i32) :: val Value. procedure, public :: isEmpty => isEmpty_iArgDynamicArray iArgDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_iArgDynamicArray(this) result(yes) Overloaded type bound procedure iArgDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_iArgDynamicArray iArgDynamicArray%isFilled() - True if the allocated memory has been filled. private function isFilled_iArgDynamicArray(this) result(yes) Overloaded type bound procedure iArgDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_iArgDynamicArray iArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_iArgDynamicArray(this, val) result(i) Overloaded type bound procedure iArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: val Value to get the argument of. Return Value integer(kind=i32) Index of the value. procedure, public :: prepend => prepend_iArgDynamicArray iArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_iArgDynamicArray(this, i, val) Overloaded type bound procedure iArgDynamicArray%prepend(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: i Prepend indices with this index. integer(kind=i32) :: val Prepend values with this value. procedure, public :: remove => remove_iArgDynamicArray iArgDynamicArray%remove() - Remove an element from the array. private subroutine remove_iArgDynamicArray(this, i) Overloaded type bound procedure iArgDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this integer(kind=i32) :: i Remove the elements at this location. procedure, public :: tighten => tighten_iArgDynamicArray iArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_iArgDynamicArray(this) Overloaded type bound procedure iArgDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( iArgDynamicArray ) :: this","loc":"type/iargdynamicarray.html","tags":""},{"title":"idArgDynamicArray – Fortran Program ","text":"type, public :: idArgDynamicArray type~~idargdynamicarray~~InheritsGraph type~idargdynamicarray idArgDynamicArray idDynamicArray idDynamicArray idDynamicArray->type~idargdynamicarray v iDynamicArray iDynamicArray iDynamicArray->type~idargdynamicarray i Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Class that act as stacks, queues, and priority queues. See m_idArgDynamicArray for more information on how to use this class. Variables i v Constructor idArgDynamicArray Type-Bound Procedures append argOf deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend remove tighten Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(idDynamicArray), public :: v Values. Constructor public interface idArgDynamicArray private function init_idArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[idArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( idArgDynamicArray ) private function init_idArgDynamicArray_id1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[idArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) integer(kind=i64), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( idArgDynamicArray ) Type-Bound Procedures procedure, public :: append => append_idArgDynamicArray idArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_idArgDynamicArray(this, i, val) Overloaded type bound procedure idArgDynamicArray%append(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i32) :: i Index of value integer(kind=i64) :: val Value to append procedure, public :: argOf => argOf_idArgDynamicArray idArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array private function argOf_idArgDynamicArray(this, val) result(i) Overloaded type bound procedure idArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i64) :: val Value to get the argument of. Return Value integer(kind=i32) Argument of the value. procedure, public :: deallocate => deallocate_idArgDynamicArray idArgDynamicArray%%deallocate() - Deallocate a dynamic array. private subroutine deallocate_idArgDynamicArray(this) Overloaded type bound procedure idArgDynamicArray%deallocate(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this procedure, public :: insertAt => insertAt_idArgDynamicArray idArgDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_idArgDynamicArray(this, loc, i, val) Overloaded type bound procedure idArgDynamicArray%insertAt(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i32) :: loc Insert index and value at this location. integer(kind=i32) :: i index/ integer(kind=i64) :: val Value/ procedure, public :: insertSorted => insertSorted_idArgDynamicArray idArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_idArgDynamicArray(this, i, val) Overloaded type bound procedure idArgDynamicArray%insertSorted(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i32) :: i Index. integer(kind=i64) :: val Value. procedure, public :: insertSortedUnique => insertSortedUnique_idArgDynamicArray idArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_idArgDynamicArray(this, i, val) Overloaded type bound procedure idArgDynamicArray%insertSortedUnique(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i32) :: i Index. integer(kind=i64) :: val Value. procedure, public :: isEmpty => isEmpty_idArgDynamicArray idArgDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_idArgDynamicArray(this) result(yes) Overloaded type bound procedure idArgDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_idArgDynamicArray idArgDynamicArray%isFilled() - True if the allocated memory has been filled. private function isFilled_idArgDynamicArray(this) result(yes) Overloaded type bound procedure idArgDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_idArgDynamicArray idArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_idArgDynamicArray(this, val) result(i) Overloaded type bound procedure idArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i64) :: val Value to get the argument of. Return Value integer(kind=i32) Index of the value. procedure, public :: prepend => prepend_idArgDynamicArray idArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_idArgDynamicArray(this, i, val) Overloaded type bound procedure idArgDynamicArray%prepend(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i32) :: i Prepend indices with this index. integer(kind=i64) :: val Prepend values with this value. procedure, public :: remove => remove_idArgDynamicArray idArgDynamicArray%remove() - Remove an element from the array. private subroutine remove_idArgDynamicArray(this, i) Overloaded type bound procedure idArgDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this integer(kind=i32) :: i Remove the elements at this location. procedure, public :: tighten => tighten_idArgDynamicArray idArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_idArgDynamicArray(this) Overloaded type bound procedure idArgDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( idArgDynamicArray ) :: this","loc":"type/idargdynamicarray.html","tags":""},{"title":"idDynamicArray – Fortran Program ","text":"type, public :: idDynamicArray Class that act as stacks, queues, and priority queues. See m_idDynamicArray for more information on how to use this class. Variables N values sorted fixed Constructor idDynamicArray Type-Bound Procedures append deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend reallocate remove tighten Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array integer(kind=i64), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor public interface idDynamicArray private function init_idDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface idDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( idDynamicArray ) Return type. private function init_idDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface idDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( idDynamicArray ) Return type Type-Bound Procedures procedure, public :: append => append_idDynamicArray idDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_idDynamicArray(this, val) Overloaded type bound procedure idDynamicArray%append() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i64) :: val Value to append. procedure, public :: deallocate => deallocate_idDynamicArray idDynamicArray%deallocate() - Deallocate a dynamic array. private subroutine deallocate_idDynamicArray(this) Overloaded type bound procedure idDynamicArray%deallocate() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this procedure, public :: insertAt => insertAt_idDynamicArray idDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_idDynamicArray(this, i, val) Overloaded type bound procedure rDynamicArray%insertAt() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. integer(kind=i64) :: val Insert this value. procedure, public :: insertSorted => insertSorted_idDynamicArray idDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_idDynamicArray(this, val) Overloaded type bound procedure idDynamicArray%insertSorted() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i64) :: val Insert this value. procedure, public :: insertSortedUnique => insertSortedUnique_idDynamicArray idDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_idDynamicArray(this, val) Overloaded type bound procedure idDynamicArray%insertSortedUnique() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i64) :: val Insert this value. procedure, public :: isEmpty => isEmpty_idDynamicArray idDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_idDynamicArray(this) result(yes) Overloaded type bound procedure idDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_idDynamicArray idDynamicArray%isFilled() - True if the array is filled. private function isFilled_idDynamicArray(this) result(yes) Overloaded type bound procedure idDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_idDynamicArray idDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_idDynamicArray(this, val) result(i) Overloaded type bound procedure idDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i64) :: val Get the location of this value Return Value integer(kind=i32) Location of value procedure, public :: prepend => prepend_idDynamicArray idDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_idDynamicArray(this, val) Overloaded type bound procedure idDynamicArray%prepend() Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i64) :: val Value to prepend. procedure, public :: reallocate => reallocate_idDynamicArray idDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. private subroutine reallocate_idDynamicArray(this, M) Overloaded type bound procedure idDynamicArray%reallocate(). Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i32) :: M Reallocate memory to this size. procedure, public :: remove => remove_idDynamicArray idDynamicArray%remove() - Remove an element from the array. private subroutine remove_idDynamicArray(this, i) Overloaded type bound procedure idDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i32) :: i Remove the value at this location. procedure, public :: tighten => tighten_idDynamicArray idDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_idDynamicArray(this) Overloaded type bound procedure idDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this","loc":"type/iddynamicarray.html","tags":""},{"title":"iDynamicArray – Fortran Program ","text":"type, public :: iDynamicArray Class that act as stacks, queues, and priority queues. See m_iDynamicArray for more information on how to use this class. Variables N values sorted fixed Constructor iDynamicArray Type-Bound Procedures append deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend reallocate remove tighten Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array integer(kind=i32), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor public interface iDynamicArray private function init_iDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface iDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( iDynamicArray ) Return type. private function init_iDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface iDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( iDynamicArray ) Return type Type-Bound Procedures procedure, public :: append => append_iDynamicArray iDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_iDynamicArray(this, val) Overloaded type bound procedure iDynamicArray%append() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: val Value to append. procedure, public :: deallocate => deallocate_iDynamicArray iDynamicArray%deallocate() - Deallocate a dynamic array. private subroutine deallocate_iDynamicArray(this) Overloaded type bound procedure iDynamicArray%deallocate() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this procedure, public :: insertAt => insertAt_iDynamicArray iDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_iDynamicArray(this, i, val) Overloaded type bound procedure rDynamicArray%insertAt() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. integer(kind=i32) :: val Insert this value. procedure, public :: insertSorted => insertSorted_iDynamicArray iDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_iDynamicArray(this, val) Overloaded type bound procedure iDynamicArray%insertSorted() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: val Insert this value. procedure, public :: insertSortedUnique => insertSortedUnique_iDynamicArray iDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_iDynamicArray(this, val) Overloaded type bound procedure iDynamicArray%insertSortedUnique() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: val Insert this value. procedure, public :: isEmpty => isEmpty_iDynamicArray iDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_iDynamicArray(this) result(yes) Overloaded type bound procedure iDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_iDynamicArray iDynamicArray%isFilled() - True if the array is filled. private function isFilled_iDynamicArray(this) result(yes) Overloaded type bound procedure iDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_iDynamicArray iDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_iDynamicArray(this, val) result(i) Overloaded type bound procedure iDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: val Get the location of this value Return Value integer(kind=i32) Location of value procedure, public :: prepend => prepend_iDynamicArray iDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_iDynamicArray(this, val) Overloaded type bound procedure iDynamicArray%prepend() Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: val Value to prepend. procedure, public :: reallocate => reallocate_iDynamicArray iDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. private subroutine reallocate_iDynamicArray(this, M) Overloaded type bound procedure iDynamicArray%reallocate(). Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: M Reallocate memory to this size. procedure, public :: remove => remove_iDynamicArray iDynamicArray%remove() - Remove an element from the array. private subroutine remove_iDynamicArray(this, i) Overloaded type bound procedure iDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: i Remove the value at this location. procedure, public :: tighten => tighten_iDynamicArray iDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_iDynamicArray(this) Overloaded type bound procedure iDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this","loc":"type/idynamicarray.html","tags":""},{"title":"rArgDynamicArray – Fortran Program ","text":"type, public :: rArgDynamicArray type~~rargdynamicarray~~InheritsGraph type~rargdynamicarray rArgDynamicArray iDynamicArray iDynamicArray iDynamicArray->type~rargdynamicarray i rDynamicArray rDynamicArray rDynamicArray->type~rargdynamicarray v Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Class that act as stacks, queues, and priority queues. See m_rArgDynamicArray for more information on how to use this class. Variables i v Constructor rArgDynamicArray Type-Bound Procedures append argOf deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend remove tighten Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(rDynamicArray), public :: v Values. Constructor public interface rArgDynamicArray private function init_rArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[rArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( rArgDynamicArray ) private function init_rArgDynamicArray_r1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[rArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) real(kind=r32), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( rArgDynamicArray ) Type-Bound Procedures procedure, public :: append => append_rArgDynamicArray rArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_rArgDynamicArray(this, i, val) Overloaded type bound procedure rArgDynamicArray%append(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this integer(kind=i32) :: i Index of value real(kind=r32) :: val Value to append procedure, public :: argOf => argOf_rArgDynamicArray rArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array private function argOf_rArgDynamicArray(this, val) result(i) Overloaded type bound procedure rArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this real(kind=r32) :: val Value to get the argument of. Return Value integer(kind=i32) Argument of the value. procedure, public :: deallocate => deallocate_rArgDynamicArray rArgDynamicArray%%deallocate() - Deallocate a dynamic array. private subroutine deallocate_rArgDynamicArray(this) Overloaded type bound procedure rArgDynamicArray%deallocate(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this procedure, public :: insertAt => insertAt_rArgDynamicArray rArgDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_rArgDynamicArray(this, loc, i, val) Overloaded type bound procedure rArgDynamicArray%insertAt(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this integer(kind=i32) :: loc Insert index and value at this location. integer(kind=i32) :: i index/ real(kind=r32) :: val Value/ procedure, public :: insertSorted => insertSorted_rArgDynamicArray rArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_rArgDynamicArray(this, i, val) Overloaded type bound procedure rArgDynamicArray%insertSorted(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this integer(kind=i32) :: i Index. real(kind=r32) :: val Value. procedure, public :: insertSortedUnique => insertSortedUnique_rArgDynamicArray rArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_rArgDynamicArray(this, i, val) Overloaded type bound procedure rArgDynamicArray%insertSortedUnique(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this integer(kind=i32) :: i Index. real(kind=r32) :: val Value. procedure, public :: isEmpty => isEmpty_rArgDynamicArray rArgDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_rArgDynamicArray(this) result(yes) Overloaded type bound procedure rArgDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_rArgDynamicArray rArgDynamicArray%isFilled() - True if the allocated memory has been filled. private function isFilled_rArgDynamicArray(this) result(yes) Overloaded type bound procedure rArgDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_rArgDynamicArray rArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_rArgDynamicArray(this, val) result(i) Overloaded type bound procedure rArgDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this real(kind=r32) :: val Value to get the argument of. Return Value integer(kind=i32) Index of the value. procedure, public :: prepend => prepend_rArgDynamicArray rArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_rArgDynamicArray(this, i, val) Overloaded type bound procedure rArgDynamicArray%prepend(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this integer(kind=i32) :: i Prepend indices with this index. real(kind=r32) :: val Prepend values with this value. procedure, public :: remove => remove_rArgDynamicArray rArgDynamicArray%remove() - Remove an element from the array. private subroutine remove_rArgDynamicArray(this, i) Overloaded type bound procedure rArgDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this integer(kind=i32) :: i Remove the elements at this location. procedure, public :: tighten => tighten_rArgDynamicArray rArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_rArgDynamicArray(this) Overloaded type bound procedure rArgDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( rArgDynamicArray ) :: this","loc":"type/rargdynamicarray.html","tags":""},{"title":"rDynamicArray – Fortran Program ","text":"type, public :: rDynamicArray Class that act as stacks, queues, and priority queues. See m_rDynamicArray for more information on how to use this class. Variables N values sorted fixed Constructor rDynamicArray Type-Bound Procedures append deallocate insertAt insertSorted insertSortedUnique isEmpty isFilled locationOf prepend reallocate remove tighten Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array real(kind=r32), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor public interface rDynamicArray private function init_rDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface rDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( rDynamicArray ) Return type. private function init_rDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface rDynamicArray() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( rDynamicArray ) Return type Type-Bound Procedures procedure, public :: append => append_rDynamicArray rDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. private subroutine append_rDynamicArray(this, val) Overloaded type bound procedure rDynamicArray%append() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this real(kind=r32) :: val Value to append. procedure, public :: deallocate => deallocate_rDynamicArray rDynamicArray%deallocate() - Deallocate a dynamic array. private subroutine deallocate_rDynamicArray(this) Overloaded type bound procedure rDynamicArray%deallocate() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this procedure, public :: insertAt => insertAt_rDynamicArray rDynamicArray%insertAt() - Insert a value at a given index. private subroutine insertAt_rDynamicArray(this, i, val) Overloaded type bound procedure rDynamicArray%insertAt() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. real(kind=r32) :: val Insert this value. procedure, public :: insertSorted => insertSorted_rDynamicArray rDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. private subroutine insertSorted_rDynamicArray(this, val) Overloaded type bound procedure rDynamicArray%insertSorted() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this real(kind=r32) :: val Insert this value. procedure, public :: insertSortedUnique => insertSortedUnique_rDynamicArray rDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. private subroutine insertSortedUnique_rDynamicArray(this, val) Overloaded type bound procedure rDynamicArray%insertSortedUnique() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this real(kind=r32) :: val Insert this value. procedure, public :: isEmpty => isEmpty_rDynamicArray rDynamicArray%isEmpty() - True if the array is empty. private function isEmpty_rDynamicArray(this) result(yes) Overloaded type bound procedure rDynamicArray%isEmpty() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this Return Value logical Array is empty procedure, public :: isFilled => isFilled_rDynamicArray rDynamicArray%isFilled() - True if the array is filled. private function isFilled_rDynamicArray(this) result(yes) Overloaded type bound procedure rDynamicArray%isFilled() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this Return Value logical Array is filled procedure, public :: locationOf => locationOf_rDynamicArray rDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. private function locationOf_rDynamicArray(this, val) result(i) Overloaded type bound procedure rDynamicArray%locationOf(). Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this real(kind=r32) :: val Get the location of this value Return Value integer(kind=i32) Location of value procedure, public :: prepend => prepend_rDynamicArray rDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays private subroutine prepend_rDynamicArray(this, val) Overloaded type bound procedure rDynamicArray%prepend() Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this real(kind=r32) :: val Value to prepend. procedure, public :: reallocate => reallocate_rDynamicArray rDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. private subroutine reallocate_rDynamicArray(this, M) Overloaded type bound procedure rDynamicArray%reallocate(). Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this integer(kind=i32) :: M Reallocate memory to this size. procedure, public :: remove => remove_rDynamicArray rDynamicArray%remove() - Remove an element from the array. private subroutine remove_rDynamicArray(this, i) Overloaded type bound procedure rDynamicArray%remove(). Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this integer(kind=i32) :: i Remove the value at this location. procedure, public :: tighten => tighten_rDynamicArray rDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. private subroutine tighten_rDynamicArray(this) Overloaded type bound procedure rDynamicArray%tighten(). Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this","loc":"type/rdynamicarray.html","tags":""},{"title":"KdTree – Fortran Program ","text":"type, public :: KdTree KdTree in 2, 3, or N dimensions.  See m_KdTree for more information on how to use this class. Constructor KdTree Type-Bound Procedures deallocate Constructor public interface KdTree Overloaded Initializer for a KdTree. public function init2D_KdTree(x, y) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) x-coordinates of the points real(kind=r64), intent(in) :: y (:) y-coordinates of the points Return Value type( KdTree ) KdTree Class public function init3D_KdTree(x, y, z) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) x-coordinates of the points real(kind=r64), intent(in) :: y (:) y-coordinates of the points real(kind=r64), intent(in) :: z (:) z-coordinates of the points Return Value type( KdTree ) KdTree Class public function initKD_KdTree(D) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: D (:,:) Coordinates of the points, the k columns contain the k dimensional values. Return Value type( KdTree ) KdTree Class Type-Bound Procedures procedure, public :: deallocate => deallocate_KdTree kdTree%deallocate() - deallocate the recursive pointers private interface deallocate_KdTree() Arguments None","loc":"type/kdtree.html","tags":""},{"title":"KdTreeSearch – Fortran Program ","text":"type, public :: KdTreeSearch Class to search a KdTree.  See m_KdTree for more information on how to use this class. Type-Bound Procedures nearest kNearest rangeSearch Type-Bound Procedures generic, public :: nearest => nearest2D, nearest3D, nearestKD KdTreeSearch%nearest() - Perform a nearest neighbour search private interface nearest_2D() Arguments None private interface nearest_3D() Arguments None private interface nearest_KD() Arguments None generic, public :: kNearest => kNearest2D, kNearest3D, kNearestKD KdTreeSearch%kNearest() - Perform a k nearest neighbour search or a radius search. private interface kNearest_2D() Arguments None private interface kNearest_3D() Arguments None private interface kNearest_KD() Arguments None generic, public :: rangeSearch => rangeSearch2D, rangeSearch3D, rangeSearchKD KdTreeSearch%rangeSearch() - Find all points within axis aligned lower and upper bounds private interface rangeSearch_2D() Arguments None private interface rangeSearch_3D() Arguments None private interface rangeSearch_KD() Arguments None","loc":"type/kdtreesearch.html","tags":""},{"title":"ProgressBar – Fortran Program ","text":"type, public :: ProgressBar A progress bar that displays a moving counter with percentage and optional estimated time remaining\n Print the progress Bar Initialize the Progress Bar Constructor ProgressBar Type-Bound Procedures print Constructor public interface ProgressBar private function ProgressBar_i1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) private function ProgressBar_id1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) Type-Bound Procedures generic, public :: print => print_i1_ProgressBar_, print_id1_ProgressBar_ Print the progress Bar private subroutine print_i1_ProgressBar(this, i) Interfaced with ProgressBar%print() Arguments Type Intent Optional Attributes Name class( ProgressBar ) :: this ProgressBar Class integer(kind=i32), intent(in) :: i Current iteration number private subroutine print_id1_ProgressBar(this, i) Interfaced with ProgressBar%print() Arguments Type Intent Optional Attributes Name class( ProgressBar ) :: this ProgressBar Class integer(kind=i64), intent(in) :: i Current iteration number","loc":"type/progressbar.html","tags":""},{"title":"Stopwatch – Fortran Program ","text":"type, public :: Stopwatch Class for timing sections of code, See the Stopwatch_Class module documentation for usage. Type-Bound Procedures start stop reset restart time lap lapInSeconds elapsed elapsedInSeconds date dateAndTime Type-Bound Procedures procedure, public :: start => start_Stopwatch Start the Stopwatch private subroutine start_Stopwatch(this, title, iunit) Start the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class character(len=*), optional :: title Name to label the start of the stopwatch integer(kind=i32), optional :: iunit File ID to write to procedure, public :: stop => stop_Stopwatch Stop the Stopwatch private subroutine stop_Stopwatch(this, title, iunit) Stop the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class character(len=*), optional :: title Name to label the stopped stopwatch integer(kind=i32), optional :: iunit File ID to write to procedure, public :: reset => reset_Stopwatch Reset the Stopwatch private subroutine reset_Stopwatch(this) Reset the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class procedure, public :: restart => restart_Stopwatch Restart the Stopwatch private subroutine restart_Stopwatch(this) Restart the Stopwatch Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class procedure, public :: time => time_Stopwatch Get the current or stopped time private function time_Stopwatch(this) result(res) Get the time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Time in format HH:MM:SS.MSEC procedure, public :: lap => lap_Stopwatch Lap the Stopwatch private function lap_Stopwatch(this) result(res) Get the lap time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Lap time in format HH:MM:SS.MSEC procedure, public :: lapInSeconds => lapInSeconds_Stopwatch Get the lap time in seconds private function lapInSeconds_Stopwatch(this) result(res) Get the lap time in seconds Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value real(kind=r64) Laptime in seconds procedure, public :: elapsed => elapsed_Stopwatch Get the current elapsed time private function elapsed_Stopwatch(this) result(res) Get the elapsed time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Elapsed time in format HH:MM:SS.MSEC procedure, public :: elapsedInSeconds => elapsedInSeconds_Stopwatch Get the elapsed time in seconds private function elapsedInSeconds_Stopwatch(this) result(res) Get the elapsed time in seconds Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value real(kind=r64) Elapsed time in seconds procedure, public :: date => date_Stopwatch Print the date private function date_Stopwatch(this) result(res) Get the date Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Date in format DD/MM/YYYY procedure, public :: dateAndTime => dateAndTime_Stopwatch Print the date and time private function dateAndTime_Stopwatch(this) result(res) Get the date and time Arguments Type Intent Optional Attributes Name class( Stopwatch ) :: this Stopwatch Class Return Value character(len=:),\n  allocatable Date and time in format DD/MM/YYYY HH:MM:SS.MSEC","loc":"type/stopwatch.html","tags":""},{"title":"array1D_test – Fortran Program","text":"public subroutine array1D_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test Calls proc~~array1d_test~~CallsGraph proc~array1d_test array1D_test interface~arange arange proc~array1d_test->interface~arange interface~diff diff proc~array1d_test->interface~diff proc~msg msg proc~array1d_test->proc~msg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/array1d_test.html","tags":""},{"title":"arange – Fortran Program","text":"public interface arange Create a 1D array from start to stop in given increments of 1 or optionally step Example Usage program arangeTest use variableKind , only : i32 , i64 , r32 , r64 use m_allocatable , only : allocatable use m_array1D , only : arange real ( r32 ), allocatable :: a (:) integer ( i32 ), allocatable :: b (:) real ( r64 ), allocatable :: c (:) integer ( i64 ), allocatable :: d (:) integer :: N N = 10000 call allocate ( a , N ) call allocate ( b , N ) call allocate ( c , N ) call allocate ( d , N ) call arange ( a , 1 , N ) call arange ( b , 1 , N ) call arange ( c , 1 , N ) call arange ( d , 1 , N ) call deallocate ( a ) call deallocate ( b ) call deallocate ( c ) call deallocate ( d ) end program Called By interface~~arange~~CalledByGraph interface~arange arange proc~array1d_test array1D_test proc~array1d_test->interface~arange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Subroutines arange_r1D arange_d1D arange_i1D arange_id1D Subroutines public subroutine arange_r1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: res (:) real(kind=r32), intent(in) :: start Start from here real(kind=r32), intent(in) :: stp Stop here real(kind=r32), intent(in), optional :: step Step size public subroutine arange_d1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: res (:) real(kind=r64), intent(in) :: start Start from here real(kind=r64), intent(in) :: stp Stop here real(kind=r64), intent(in), optional :: step Step size public subroutine arange_i1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: res (:) integer(kind=i32), intent(in) :: start Start from here integer(kind=i32), intent(in) :: stp Stop here integer(kind=i32), intent(in), optional :: step Step size public subroutine arange_id1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: res (:) integer(kind=i64), intent(in) :: start Start from here integer(kind=i64), intent(in) :: stp Stop here integer(kind=i64), intent(in), optional :: step Step size","loc":"interface/arange.html","tags":""},{"title":"diff – Fortran Program","text":"public interface diff Compute the difference along an array Example Usage program arangeTest use variableKind , only : i32 , i64 , r32 , r64 use m_allocatable , only : allocatable use m_array1D , only : arange , diff real ( r32 ), allocatable :: a (:) integer ( i32 ), allocatable :: b (:) real ( r64 ), allocatable :: c (:) integer ( i64 ), allocatable :: d (:) integer :: N N = 10000 call allocate ( a , N ) call allocate ( b , N ) call allocate ( c , N ) call allocate ( d , N ) call arange ( a , 1 , N ) call arange ( b , 1 , N ) call arange ( c , 1 , N ) call arange ( d , 1 , N ) call diff ( a , 1 , N ) call diff ( b , 1 , N ) call diff ( c , 1 , N ) call diff ( d , 1 , N ) call deallocate ( a ) call deallocate ( b ) call deallocate ( c ) call deallocate ( d ) end program Called By interface~~diff~~CalledByGraph interface~diff diff proc~array1d_test array1D_test proc~array1d_test->interface~diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Subroutines diff_r1D diff_d1D diff_i1D diff_id1D Subroutines public subroutine diff_r1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32) :: res (:) Difference along array public subroutine diff_d1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64) :: res (:) Difference along array public subroutine diff_i1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32) :: res (:) Difference along array public subroutine diff_id1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i64) :: res (:) Difference along array","loc":"interface/diff.html","tags":""},{"title":"isSorted – Fortran Program","text":"public interface isSorted Check that a 1D array is sorted Example Usage program arangeTest use variableKind , only : i32 , i64 , r32 , r64 use m_allocatable , only : allocatable use m_array1D , only : arange , isSorted real ( r32 ), allocatable :: a (:) integer ( i32 ), allocatable :: b (:) real ( r64 ), allocatable :: c (:) integer ( i64 ), allocatable :: d (:) integer :: N N = 10000 call allocate ( a , N ) call allocate ( b , N ) call allocate ( c , N ) call allocate ( d , N ) call arange ( a , 1 , N ) call arange ( b , 1 , N ) call arange ( c , 1 , N ) call arange ( d , 1 , N ) call diff ( a , 1 , N ) call diff ( b , 1 , N ) call diff ( c , 1 , N ) call diff ( d , 1 , N ) call deallocate ( a ) call deallocate ( b ) call deallocate ( c ) call deallocate ( d ) end program Functions isSorted_r1D isSorted_d1D isSorted_i1D isSorted_id1D isSorted_r1Di1D isSorted_d1Di1D isSorted_i1Di1D isSorted_id1Di1D Functions public function isSorted_r1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_d1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_i1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_id1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_r1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public function isSorted_d1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public function isSorted_i1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public function isSorted_id1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted","loc":"interface/issorted.html","tags":""},{"title":"repeat – Fortran Program","text":"public interface repeat Repeat each element nRepeat times Subroutines repeat_r1D repeat_d1D repeat_i1D repeat_id1D Subroutines public subroutine repeat_r1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r32), allocatable :: res (:) public subroutine repeat_d1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r64), allocatable :: res (:) public subroutine repeat_i1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i32), allocatable :: res (:) public subroutine repeat_id1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i64), allocatable :: res (:)","loc":"interface/repeat.html","tags":""},{"title":"allocate_test – Fortran Program","text":"public subroutine allocate_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/allocate_test.html","tags":""},{"title":"allocate – Fortran Program","text":"public interface allocate Allocate an allocatable array. If the array is already allocated, memory is reallocated to the given size, unless no size change will occur.\n The allocated memory is NOT initialized to any value, so be sure to do so afterwards if you call allocate. Does not overload the intrinsic allocate function. This way, calling allocate makes the user aware that checks are being made, and memory will be re-allocated. Checks for an error during allocation, and will stop the code if there is one. Example usage use variableKind use m_allocate , only : allocate real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) call allocate ( a1D , 20 ) call allocate ( a2D , [ 20 , 20 ]) call allocate ( a3D , [ 20 , 20 , 20 ]) write ( * , '(a)' ) 'Shape of a3D is [20,20,20]? ' // all ( shape ( a3D ) == [ 20 , 20 , 20 ]) Subroutines allocate_r1D allocate_r2D allocate_r3D allocate_d1D allocate_d2D allocate_d3D allocate_i1D allocate_i2D allocate_i3D allocate_id1D allocate_id2D allocate_id3D allocate_c1D allocate_c2D allocate_c3D allocate_z1D allocate_z2D allocate_z3D allocate_l1D allocate_l2D allocate_l3D Subroutines public subroutine allocate_r1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_r2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_r3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_d1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_d2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_d3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_i1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_i2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_i3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_id1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_id2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_id3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_c1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_c2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_c3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_z1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_z2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_z3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_l1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_l2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_l3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size","loc":"interface/allocate.html","tags":""},{"title":"compare_d1 – Fortran Program","text":"public function compare_d1(this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32) Called By proc~~compare_d1~~CalledByGraph proc~compare_d1 compare_d1 interface~compare compare interface~compare->proc~compare_d1 proc~partition3way_d1d partition3way_d1D proc~partition3way_d1d->interface~compare interface~partition3way partition3way interface~partition3way->proc~partition3way_d1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/compare_d1.html","tags":""},{"title":"compare – Fortran Program","text":"public interface compare Calls interface~~compare~~CallsGraph interface~compare compare proc~compare_d1 compare_d1 interface~compare->proc~compare_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~compare~~CalledByGraph interface~compare compare proc~partition3way_d1d partition3way_d1D proc~partition3way_d1d->interface~compare interface~partition3way partition3way interface~partition3way->proc~partition3way_d1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures compare_d1 Module Procedures public function compare_d1 (this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32)","loc":"interface/compare.html","tags":""},{"title":"copy_test – Fortran Program","text":"public subroutine copy_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/copy_test.html","tags":""},{"title":"copy – Fortran Program","text":"public interface copy Copies an array to new memory (no pointers), The output array size will be changed to match the copy. Example usage use variableKind , only : r64 use m_allocate , only : allocate use m_copy , only : copy real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) real ( r64 ), allocatable :: b1D (:), b2D (:,:), b3D (:,:,:) call allocate ( a1D , 20 ) call allocate ( a2D , [ 20 , 20 ]) call allocate ( a3D , [ 20 , 20 , 20 ]) a1D = 1.d0 a2D = 2.d0 a3D = 3.d0 call copy ( a1D , b1D ) call copy ( a2D , b2D ) call copy ( a3D , b3D ) write ( * , '(a)' ) 'a1D equals b1D: ' // str ( all ( a1D == b1D )) write ( * , '(a)' ) 'a2D equals b2D: ' // str ( all ( a2D == b2D )) write ( * , '(a)' ) 'a3D equals b3D: ' // str ( all ( a3D == b3D )) call deallocate ( a1D ) call deallocate ( a2D ) call deallocate ( a3D ) call deallocate ( b1D ) call deallocate ( b2D ) call deallocate ( b3D ) Subroutines copy_r1D copy_r2D copy_r3D copy_d1D copy_d2D copy_d3D copy_i1D copy_i2D copy_i3D copy_id1D copy_id2D copy_id3D copy_c1D copy_c2D copy_c3D copy_z1D copy_z2D copy_z3D copy_l1D copy_l2D copy_l3D Subroutines public subroutine copy_r1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_r2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_r3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_d1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_d2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_d3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_i1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_i2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_i3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_id1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_id2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_id3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_c1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_c2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_c3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_z1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_z2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_z3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_l1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:) Copy this array logical, intent(inout), allocatable :: that (:) Copy of this public subroutine copy_l2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:) Copy this array logical, intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_l3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:,:) Copy this array logical, intent(inout), allocatable :: that (:,:,:) Copy of this","loc":"interface/copy.html","tags":""},{"title":"deallocate – Fortran Program","text":"public interface deallocate Deallocate an allocatable array. Contains fundamental routines to deallocate allocatable arrays of different types and shapes.\n Does not overload the intrinsic deallocate function. This way, calling deallocate makes the user aware that checks are being made and errors are handled with a message. Checks for an error during allocation, and will stop the code if there is one. Example usage use variableKind use m_allocate , only : allocate use m_deallocate , only : deallocate ! Could be other intrinsic types too, integer(i32), complex(r32), etc. real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) call allocate ( a1D , 20 ) call allocate ( a2D , [ 20 , 20 ]) call allocate ( a3D , [ 20 , 20 , 20 ]) write ( * , '(a)' ) 'Shape of a3D is [20,20,20]? ' // all ( shape ( a3D ) == [ 20 , 20 , 20 ]) call deallocate ( a1D ) call deallocate ( a2D ) call deallocate ( a3D ) Subroutines deallocate_r1D deallocate_r2D deallocate_r3D deallocate_d1D deallocate_d2D deallocate_d3D deallocate_i1D deallocate_i2D deallocate_i3D deallocate_id1D deallocate_id2D deallocate_id3D deallocate_c1D deallocate_c2D deallocate_c3D deallocate_z1D deallocate_z2D deallocate_z3D deallocate_l1D deallocate_l2D deallocate_l3D Subroutines public subroutine deallocate_r1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_r2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_r3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_d1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_d2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_d3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_i1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_i2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_i3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_id1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_id2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_id3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_c1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_c2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_c3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_z1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_z2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_z3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_l1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_l2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_l3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array","loc":"interface/deallocate.html","tags":""},{"title":"debug_s – Fortran Program","text":"public subroutine debug_s(name) Arguments Type Intent Optional Attributes Name character(len=*) :: name Calls proc~~debug_s~~CallsGraph proc~debug_s debug_s interface~str str proc~debug_s->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/debug_s.html","tags":""},{"title":"debug – Fortran Program","text":"public interface debug Interface for printing primitives with a name for debug purposes\n All may be called using 'call debug(args)' Module Procedures debug_d debug_d1D debug_i debug_i1D Module Procedures private subroutine debug_D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var private subroutine debug_D1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var (:) private subroutine debug_I(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var private subroutine debug_I1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var (:)","loc":"interface/debug.html","tags":""},{"title":"mErr – Fortran Program","text":"public subroutine mErr(istat, aMsg, alloc, iunit) Checks for successful (de)allocation.  Stops the code. Use this after an allocate/deallocate statement\n allocate(x(nz,ny,nx), stat=istat); call mErr(istat,'x',1)\n deallocate(x, stat=istat); call mErr(istat,'x',2) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat results of stat=istat in (de)allocate character(len=*), intent(in) :: aMsg Message associated with the (de)allocate integer(kind=i32), intent(in) :: alloc 1 = allocate, 2 = deallocate integer(kind=i32), intent(in), optional :: iunit Optional file id to write the message to Calls proc~~merr~~CallsGraph proc~merr mErr proc~emsg eMsg proc~merr->proc~emsg proc~msg msg proc~emsg->proc~msg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/merr.html","tags":""},{"title":"msg – Fortran Program","text":"public subroutine msg(aMsg, iunit) Write a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to Called By proc~~msg~~CalledByGraph proc~msg msg proc~array1d_test array1D_test proc~array1d_test->proc~msg proc~wmsg wMsg proc~wmsg->proc~msg proc~emsg eMsg proc~emsg->proc~msg proc~merr mErr proc~merr->proc~emsg proc~ferr fErr proc~ferr->proc~emsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/msg.html","tags":""},{"title":"wMsg – Fortran Program","text":"public subroutine wMsg(aMsg, iunit) Write a Warning message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to Calls proc~~wmsg~~CallsGraph proc~wmsg wMsg proc~msg msg proc~wmsg->proc~msg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/wmsg.html","tags":""},{"title":"eMsg – Fortran Program","text":"public subroutine eMsg(aMsg, iunit) Write an Error message. Stops the code Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to Calls proc~~emsg~~CallsGraph proc~emsg eMsg proc~msg msg proc~emsg->proc~msg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~emsg~~CalledByGraph proc~emsg eMsg proc~merr mErr proc~merr->proc~emsg proc~ferr fErr proc~ferr->proc~emsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/emsg.html","tags":""},{"title":"fErr – Fortran Program","text":"public subroutine fErr(istat, fname, flg, iunit) Checks for a file error Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat Result of iostat=istat for open,read,write,close character(len=*), intent(in) :: fname Name of the file integer(kind=i32), intent(in) :: flg 1=Open, 2=Read, 3=Write, 4=Close integer(kind=i32), intent(in), optional :: iunit file id to write the error to Calls proc~~ferr~~CallsGraph proc~ferr fErr proc~emsg eMsg proc~ferr->proc~emsg proc~msg msg proc~emsg->proc~msg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/ferr.html","tags":""},{"title":"fileExists – Fortran Program","text":"public function fileExists(fName) result(yes) Checks whether the file with name fName exists on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name to check Return Value logical Exists? Called By proc~~fileexists~~CalledByGraph proc~fileexists fileExists proc~getfilesize getFileSize proc~getfilesize->proc~fileexists Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/fileexists.html","tags":""},{"title":"hasExtension – Fortran Program","text":"public function hasExtension(fName, extension) result(yes) Checks if a file 'fname' is of type 'extension' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name character(len=3), intent(in) :: extension Extension to find Return Value logical Has this extension? Calls proc~~hasextension~~CallsGraph proc~hasextension hasExtension isstring isstring proc~hasextension->isstring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/hasextension.html","tags":""},{"title":"isOpen – Fortran Program","text":"public function isOpen(fname) result(yes) Is the file open or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name Return Value logical Is the file open? Called By proc~~isopen~~CalledByGraph proc~isopen isOpen proc~checkisopen checkIsOpen proc~checkisopen->proc~isopen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/isopen.html","tags":""},{"title":"getFileSize – Fortran Program","text":"public function getFileSize(fName) result(that) Get the file size in Bytes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value integer(kind=i32) Size of the file Calls proc~~getfilesize~~CallsGraph proc~getfilesize getFileSize proc~fileexists fileExists proc~getfilesize->proc~fileexists Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/getfilesize.html","tags":""},{"title":"getNFileLines – Fortran Program","text":"public function getNFileLines(fName, nHeader) result(N) Counts the number of lines in a file after the number of specified header lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name integer(kind=i32), intent(in), optional :: nHeader Skip this number of lines at the top of the file Return Value integer(kind=i32) Number of lines in the file Calls proc~~getnfilelines~~CallsGraph proc~getnfilelines getNFileLines proc~openfile openFile proc~getnfilelines->proc~openfile proc~skipfilelines skipFileLines proc~getnfilelines->proc~skipfilelines proc~closefile closeFile proc~getnfilelines->proc~closefile emsg emsg proc~openfile->emsg ferr ferr proc~openfile->ferr proc~lowercase lowerCase proc~openfile->proc~lowercase proc~compact compact proc~openfile->proc~compact proc~closefile->ferr proc~closefile->proc~lowercase proc~closefile->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/getnfilelines.html","tags":""},{"title":"getExtension – Fortran Program","text":"public function getExtension(fName) result(that) Get the extension of a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File extension Calls proc~~getextension~~CallsGraph proc~getextension getExtension emsg emsg proc~getextension->emsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/getextension.html","tags":""},{"title":"trimExtension – Fortran Program","text":"public function trimExtension(fName) result(that) Trims the extension of a filename Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File name without the extension Calls proc~~trimextension~~CallsGraph proc~trimextension trimExtension emsg emsg proc~trimextension->emsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/trimextension.html","tags":""},{"title":"checkIsOpen – Fortran Program","text":"public subroutine checkIsOpen(fName) Checks whether a file is open with an error message if not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Calls proc~~checkisopen~~CallsGraph proc~checkisopen checkIsOpen ferr ferr proc~checkisopen->ferr proc~isopen isOpen proc~checkisopen->proc~isopen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/checkisopen.html","tags":""},{"title":"openFile – Fortran Program","text":"public subroutine openFile(fname, iunit, stat, istat) Open a file and perform necessary checks for failure\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error flag Calls proc~~openfile~~CallsGraph proc~openfile openFile emsg emsg proc~openfile->emsg ferr ferr proc~openfile->ferr proc~lowercase lowerCase proc~openfile->proc~lowercase proc~compact compact proc~openfile->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~openfile~~CalledByGraph proc~openfile openFile proc~getnfilelines getNFileLines proc~getnfilelines->proc~openfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/openfile.html","tags":""},{"title":"openBinaryFile – Fortran Program","text":"public subroutine openBinaryFile(fname, iunit, stat, istat) Open an unformatted binary file\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File Name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error Flag Calls proc~~openbinaryfile~~CallsGraph proc~openbinaryfile openBinaryFile emsg emsg proc~openbinaryfile->emsg ferr ferr proc~openbinaryfile->ferr proc~lowercase lowerCase proc~openbinaryfile->proc~lowercase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/openbinaryfile.html","tags":""},{"title":"closeFile – Fortran Program","text":"public subroutine closeFile(fname, iunit, stat, istat) Close a file and perform any necessary checks Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are closing integer(kind=i32), intent(out) :: istat Error Flag Calls proc~~closefile~~CallsGraph proc~closefile closeFile ferr ferr proc~closefile->ferr proc~lowercase lowerCase proc~closefile->proc~lowercase proc~compact compact proc~closefile->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~closefile~~CalledByGraph proc~closefile closeFile proc~getnfilelines getNFileLines proc~getnfilelines->proc~closefile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/closefile.html","tags":""},{"title":"deleteFile – Fortran Program","text":"public subroutine deleteFile(fname) Deletes a file on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name to delete","loc":"proc/deletefile.html","tags":""},{"title":"skipFileLines – Fortran Program","text":"public subroutine skipFileLines(iunit, N) Skip N lines in a file Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit Unit number to skip integer(kind=i32), intent(in) :: N Number of lines to skip Called By proc~~skipfilelines~~CalledByGraph proc~skipfilelines skipFileLines proc~getnfilelines getNFileLines proc~getnfilelines->proc~skipfilelines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/skipfilelines.html","tags":""},{"title":"fileIO_test – Fortran Program","text":"public subroutine fileIO_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/fileio_test.html","tags":""},{"title":"ind2sub – Fortran Program","text":"public function ind2sub(iG, nSub) result(iSub) Compute the indices in each dimension from the global index Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iG Index into a global vector integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32)\n  (size(nSub)) Indices in each dimension to return","loc":"proc/ind2sub.html","tags":""},{"title":"sub2ind – Fortran Program","text":"public function sub2ind(iSub, nSub) result(iG) Given component indices, get the global vector location. Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iSub (:) Indices in each dimension. The first entry in iL is the left most index integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32) Index in the global vector","loc":"proc/sub2ind.html","tags":""},{"title":"integerBin – Fortran Program","text":"public function integerBin(this, n, bound) result(i) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer(kind=i32) :: n logical :: bound Return Value integer(kind=i32) Calls proc~~integerbin~~CallsGraph proc~integerbin integerBin idnint idnint proc~integerbin->idnint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/integerbin.html","tags":""},{"title":"indexing_test – Fortran Program","text":"public subroutine indexing_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/indexing_test.html","tags":""},{"title":"partition – Fortran Program","text":"public interface partition Partitioning used for quickSort and quickSelect routines Subroutines partition_r1D partition_d1D partition_i1D partition_id1D Subroutines public subroutine partition_r1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_d1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_i1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot public subroutine partition_id1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot","loc":"interface/partition.html","tags":""},{"title":"argPartition – Fortran Program","text":"public interface argPartition Partitioning used for argQuicksort routines Subroutines argPartition_r1D argPartition_d1D argPartition_i1D argPartition_id1D Subroutines public subroutine argPartition_r1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_d1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_i1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_id1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i","loc":"interface/argpartition.html","tags":""},{"title":"partition3way_d1D – Fortran Program","text":"public subroutine partition3way_d1D(this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index Calls proc~~partition3way_d1d~~CallsGraph proc~partition3way_d1d partition3way_d1D interface~swap swap proc~partition3way_d1d->interface~swap interface~compare compare proc~partition3way_d1d->interface~compare proc~compare_d1 compare_d1 interface~compare->proc~compare_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~partition3way_d1d~~CalledByGraph proc~partition3way_d1d partition3way_d1D interface~partition3way partition3way interface~partition3way->proc~partition3way_d1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/partition3way_d1d.html","tags":""},{"title":"partition3way – Fortran Program","text":"public interface partition3way Partitioning used for quicksort routines Calls interface~~partition3way~~CallsGraph interface~partition3way partition3way proc~partition3way_d1d partition3way_d1D interface~partition3way->proc~partition3way_d1d interface~swap swap proc~partition3way_d1d->interface~swap interface~compare compare proc~partition3way_d1d->interface~compare proc~compare_d1 compare_d1 interface~compare->proc~compare_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures partition3way_d1D Module Procedures public subroutine partition3way_d1D (this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index","loc":"interface/partition3way.html","tags":""},{"title":"readline – Fortran Program","text":"public interface readline Read in multiple items from a line Example usage use variableKind use m_readline character ( len = :), allocatable :: s real ( r64 ) :: a , b , c real ( r64 ) :: a1D ( 3 ) s = '1.0 2.0 3.0' call readline ( a , b , c , 'No File Name' , 0 , s ) ! Read 3 scalars from a string write ( * , * ) 'a should equal 1.0 ' , a == 1.d0 write ( * , * ) 'b should equal 2.0 ' , b == 2.d0 write ( * , * ) 'c should equal 3.0 ' , c == 3.d0 call readline ( a1D , 'No File Name' , 0 , s ) ! Read a length 3 1D array from a string write ( * , * ) 'a1D should equal [1.0,2.0,3.0] ' , all ( a == [ 1.d0 , 2.d0 , 3.d0 ]) Module Procedures readLine_a readLine_ab readLine_abc readLine_abcd readLine_abcde readLine_av readLine_avbv readLine_avbvcv readLine_abv readLine_abvcv readLine_abcdev readLine_abcdv readLine_abcdvev readLine_abcv readLine_abcvdv readLine_abcdefv readLine_abcdefvgv Module Procedures private subroutine readLine_a(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_ab(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abc(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcd(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcde(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_av(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdvev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcvdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefv(a, b, c, d, e, f, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector real(kind=r64), intent(out) :: g (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file","loc":"interface/readline.html","tags":""},{"title":"reallocate_test – Fortran Program","text":"public subroutine reallocate_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/reallocate_test.html","tags":""},{"title":"reallocate – Fortran Program","text":"public interface reallocate Reallocate an allocatable array Example usage use variableKind use use m_reallocate real ( r64 ), allocatable :: a1D (:), a2D (:,:), a3D (:,:,:) allocate ( a1D ( 5 )) allocate ( a2D ( 5 , 5 )) allocate ( a3D ( 5 , 5 , 5 )) write ( * , '(a)' ) 'Shape of a3D is [5,5,5]? ' // all ( shape ( a3D ) == [ 5 , 5 , 5 ]) call reallocate ( a1D , 20 ) call reallocate ( a2D , [ 20 , 20 ]) call reallocate ( a3D , [ 20 , 20 , 20 ]) write ( * , '(a)' ) 'Shape of a3D is [20,20,20]? ' // all ( shape ( a3D ) == [ 20 , 20 , 20 ]) Module Procedures reallocate_r1D reallocate_r2D reallocate_r3D reallocate_d1D reallocate_d2D reallocate_d3D reallocate_i1D reallocate_i2D reallocate_i3D reallocate_id1D reallocate_id2D reallocate_id3D reallocate_c1D reallocate_c2D reallocate_c3D reallocate_z1D reallocate_z2D reallocate_z3D reallocate_l1D reallocate_l2D reallocate_l3D Module Procedures private subroutine reallocate_r1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_r2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_r3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_d1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_d2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_d3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_i1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_i2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_i3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_id1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_id2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_id3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_c1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_c2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_c3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_z1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_z2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_z3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_l1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_l2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_l3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape","loc":"interface/reallocate.html","tags":""},{"title":"hasNentries – Fortran Program","text":"public function hasNentries(this, N) result(yes) Check that a string has N entries Arguments Type Intent Optional Attributes Name character(len=*) :: this integer(kind=i32) :: N Return Value logical Calls proc~~hasnentries~~CallsGraph proc~hasnentries hasNentries proc~countentries countEntries proc~hasnentries->proc~countentries proc~compact compact proc~countentries->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/hasnentries.html","tags":""},{"title":"countEntries – Fortran Program","text":"public function countEntries(this) result(N) Count the number of entries in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Return Value integer(kind=i32) Calls proc~~countentries~~CallsGraph proc~countentries countEntries proc~compact compact proc~countentries->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~countentries~~CalledByGraph proc~countentries countEntries proc~hasnentries hasNentries proc~hasnentries->proc~countentries Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/countentries.html","tags":""},{"title":"lowerCase – Fortran Program","text":"public function lowerCase(str) result(res) Convert a string to lowercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str)) Called By proc~~lowercase~~CalledByGraph proc~lowercase lowerCase proc~openfile openFile proc~openfile->proc~lowercase proc~openbinaryfile openBinaryFile proc~openbinaryfile->proc~lowercase proc~closefile closeFile proc~closefile->proc~lowercase proc~isstring isString proc~isstring->proc~lowercase proc~getnfilelines getNFileLines proc~getnfilelines->proc~openfile proc~getnfilelines->proc~closefile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/lowercase.html","tags":""},{"title":"upperCase – Fortran Program","text":"public function upperCase(str) result(res) Convert a string to uppercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str))","loc":"proc/uppercase.html","tags":""},{"title":"isString – Fortran Program","text":"public function isString(tmp1, tmp2, exact_) result(yes) Match two string together Arguments Type Intent Optional Attributes Name character(len=*) :: tmp1 Compare this string character(len=*) :: tmp2 Compare this string logical, optional :: exact_ Optional logical, if true, the strings are not converted to lowercase before comparison Return Value logical Calls proc~~isstring~~CallsGraph proc~isstring isString proc~lowercase lowerCase proc~isstring->proc~lowercase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/isstring.html","tags":""},{"title":"appendString – Fortran Program","text":"public function appendString(this, that, delim) result(res) Append a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to append to character(len=*) :: that String to append character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Appended String","loc":"proc/appendstring.html","tags":""},{"title":"prependString – Fortran Program","text":"public function prependString(this, that, delim) result(res) Prepend a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to prepend to character(len=*) :: that String to prepend character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Prepended String","loc":"proc/prependstring.html","tags":""},{"title":"iachar1D – Fortran Program","text":"public function iachar1D(this) result(res) Use iachar on a full string Cannot overload to intrinsic iachar because of ambiguity Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this Return Value integer(kind=i32),\n  allocatable,(:) Calls proc~~iachar1d~~CallsGraph proc~iachar1d iachar1D merr merr proc~iachar1d->merr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/iachar1d.html","tags":""},{"title":"read1Integer – Fortran Program","text":"public subroutine read1Integer(buf, N, istat) Get a single integer from a line, returns an error code if there is more than one entry Arguments Type Intent Optional Attributes Name character(len=*) :: buf String integer(kind=i32) :: N Single integer integer(kind=i32) :: istat istat > 0 if more than one entry is found Calls proc~~read1integer~~CallsGraph proc~read1integer read1Integer proc~compact compact proc~read1integer->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/read1integer.html","tags":""},{"title":"read1Dble – Fortran Program","text":"public subroutine read1Dble(iunit, this, fname, vName, istat) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit real(kind=r64) :: this character(len=*) :: fname character(len=*) :: vName integer(kind=i32) :: istat Calls proc~~read1dble~~CallsGraph proc~read1dble read1Dble interface~str str proc~read1dble->interface~str proc~readline readline proc~read1dble->proc~readline ferr ferr proc~read1dble->ferr wmsg wmsg proc~read1dble->wmsg proc~compact compact proc~read1dble->proc~compact proc~readline->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/read1dble.html","tags":""},{"title":"compact – Fortran Program","text":"public subroutine compact(this) Replace tabs and spaces with a single space\n str must be a variable and not an explicit 'string'. Otherwise adjustl will fail. Arguments Type Intent Optional Attributes Name character(len=*) :: this Called By proc~~compact~~CalledByGraph proc~compact compact proc~closefile closeFile proc~closefile->proc~compact proc~read1dble read1Dble proc~read1dble->proc~compact proc~readline readline proc~read1dble->proc~readline proc~openfile openFile proc~openfile->proc~compact proc~readline->proc~compact proc~countentries countEntries proc~countentries->proc~compact proc~read1integer read1Integer proc~read1integer->proc~compact proc~getnfilelines getNFileLines proc~getnfilelines->proc~closefile proc~getnfilelines->proc~openfile proc~hasnentries hasNentries proc~hasnentries->proc~countentries Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/compact.html","tags":""},{"title":"readline – Fortran Program","text":"public subroutine readline(iUnit, line, istat) Reads a line from a file, ignoring any comments Arguments Type Intent Optional Attributes Name integer(kind=i32) :: iUnit File ID number character(len=*) :: line Character string to read the line into integer(kind=i32) :: istat Error Status Calls proc~~readline~~CallsGraph proc~readline readline proc~compact compact proc~readline->proc~compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~readline~~CalledByGraph proc~readline readline proc~read1dble read1Dble proc~read1dble->proc~readline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/readline.html","tags":""},{"title":"removeComments – Fortran Program","text":"public elemental subroutine removeComments(this) Removes the text after the ! mark in a string Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: this","loc":"proc/removecomments.html","tags":""},{"title":"replacedelim – Fortran Program","text":"public subroutine replacedelim(this, dlim, dlimr) Replace a single character length delimiter in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Replace delimiter in this character(len=*) :: dlim Find this delimiter character(len=*) :: dlimr Replace with this delimiter Calls proc~~replacedelim~~CallsGraph proc~replacedelim replacedelim emsg emsg proc~replacedelim->emsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/replacedelim.html","tags":""},{"title":"strings_test – Fortran Program","text":"public subroutine strings_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/strings_test.html","tags":""},{"title":"str – Fortran Program","text":"public interface str Interface to print a string representation of a number\n The output format options can be set using the printOptions class Example usage use variableKind use m_strings real ( r64 ) :: arr ( 20 ) integer ( i32 ) :: i integer ( i32 ) :: j ( 5 ) arr = [( dble ( i ), i = 1 , 20 )] i = 12 j = [ 0 , 1 , 2 , 3 , 4 ] write ( * , '(a)' ) str ( i ) // str ( j ) write ( * , '(a)' ) str ( j ) // str ( arr ) write ( * , '(a)' ) str ( arr ) printOptions % threshold = 0 write ( * , '(a)' ) str ( arr ) Called By interface~~str~~CalledByGraph interface~str str proc~insertat__rdynamicarray insertAt__rDynamicArray proc~insertat__rdynamicarray->interface~str proc~insertat__idynamicarray insertAt__iDynamicArray proc~insertat__idynamicarray->interface~str proc~debug_s debug_s proc~debug_s->interface~str proc~read1dble read1Dble proc~read1dble->interface~str proc~insertat__iddynamicarray insertAt__idDynamicArray proc~insertat__iddynamicarray->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures str_r1 str_r1D str_d1 str_d1D str_d2D str_i1 str_i1D str_id1 str_id1D str_s1 str_s1D str_1L Module Procedures private function str_r1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_r1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d2D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:,:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_1L(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name logical, intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable","loc":"interface/str.html","tags":""},{"title":"swap – Fortran Program","text":"public interface swap Swap the values of two variables Example usage use variableKind use m_strings , only : str use m_swap , only : swap real ( r64 ) :: a , b a = 1 0.d0 b = 10 0.d0 call swap ( a , b ) write ( * , '(a)' ) 'Values were swapped? ' // str ( a == 10 0.d0 . and . b == 1 0.d0 ) Called By interface~~swap~~CalledByGraph interface~swap swap proc~partition3way_d1d partition3way_d1D proc~partition3way_d1d->interface~swap interface~partition3way partition3way interface~partition3way->proc~partition3way_d1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures swap_i1 swap_id1 swap_r1 swap_d1 swap_c1 swap_z1 swap_l1 Module Procedures private subroutine swap_i1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this integer(kind=i32), intent(inout) :: that private subroutine swap_id1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this integer(kind=i64), intent(inout) :: that private subroutine swap_r1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this real(kind=r32), intent(inout) :: that private subroutine swap_d1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(inout) :: that private subroutine swap_c1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r32) :: this complex(kind=r32) :: that private subroutine swap_z1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r64) :: this complex(kind=r64) :: that private subroutine swap_l1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name logical :: this logical :: that","loc":"interface/swap.html","tags":""},{"title":"tester – Fortran Program","text":"public interface tester Module Procedures init_tester Module Procedures private function init_tester() result(this) Arguments None Return Value type( tester )","loc":"interface/tester.html","tags":""},{"title":"writeline – Fortran Program","text":"public interface writeline Write multiple items to a line Example usage use variableKind use m_writeline use m_fileIO , only : openFile , closeFile character ( len = :), allocatable :: fName real ( r64 ) :: a , b , c real ( r64 ) :: a1D ( 3 ) integer ( i32 ) :: iunit , istat a = 1.d0 b = 2.d0 c = 3.d0 a1D = [ 1.d0 , 2.d0 , 3.d0 ] fName = 'writeline.txt' call openFile ( fName , iunit , 'unknown' , istat ) call writeline ( a , b , c , fName , iunit ) call writeline ( a1D , fName , iunit ) call closeFile ( fName , iunit , '' , istat ) Module Procedures writeLine_a writeLine_ab writeLine_abc writeLine_abcd writeLine_abcde writeLine_av writeLine_avbv writeLine_avbvcv writeLine_abv writeLine_abvcv writeLine_abcdev writeLine_abcdevfv writeLine_abcdv writeLine_abcdvev writeLine_abcv writeLine_abcvdv writeLine_abcdefv writeLine_abcdefvgv Module Procedures private subroutine writeLine_a(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_ab(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abc(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcd(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcde(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_av(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdevfv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdvev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcvdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) real(kind=r64) :: g (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit","loc":"interface/writeline.html","tags":""},{"title":"dArgDynamicArray_test – Fortran Program","text":"public subroutine dArgDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/dargdynamicarray_test.html","tags":""},{"title":"dArgDynamicArray – Fortran Program","text":"public interface dArgDynamicArray Module Procedures init_dArgDynamicArray_i1 init_dArgDynamicArray_d1D Module Procedures private function init_dArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[dArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dArgDynamicArray ) private function init_dArgDynamicArray_d1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[dArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) Set of value indices to initialize with. real(kind=r64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dArgDynamicArray )","loc":"interface/dargdynamicarray.html","tags":""},{"title":"dDynamicArray_test – Fortran Program","text":"public subroutine dDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/ddynamicarray_test.html","tags":""},{"title":"dDynamicArray – Fortran Program","text":"public interface dDynamicArray Module Procedures init_dDynamicArray_i1 init_dDynamicArray_d1D Module Procedures private function init_dDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface dDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dDynamicArray ) Return type. private function init_dDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface dDynamicArray() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dDynamicArray ) Return type","loc":"interface/ddynamicarray.html","tags":""},{"title":"iArgDynamicArray_test – Fortran Program","text":"public subroutine iArgDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/iargdynamicarray_test.html","tags":""},{"title":"iArgDynamicArray – Fortran Program","text":"public interface iArgDynamicArray Module Procedures init_iArgDynamicArray_i1 init_iArgDynamicArray_i1D Module Procedures private function init_iArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[iArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( iArgDynamicArray ) private function init_iArgDynamicArray_i1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[iArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) integer(kind=i32), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( iArgDynamicArray )","loc":"interface/iargdynamicarray.html","tags":""},{"title":"idArgDynamicArray_test – Fortran Program","text":"public subroutine idArgDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/idargdynamicarray_test.html","tags":""},{"title":"idArgDynamicArray – Fortran Program","text":"public interface idArgDynamicArray Module Procedures init_idArgDynamicArray_i1 init_idArgDynamicArray_id1D Module Procedures private function init_idArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[idArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( idArgDynamicArray ) private function init_idArgDynamicArray_id1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[idArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) integer(kind=i64), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( idArgDynamicArray )","loc":"interface/idargdynamicarray.html","tags":""},{"title":"insertAt__idDynamicArray – Fortran Program","text":"public subroutine insertAt__idDynamicArray(this, i, val) Private insert into array without checking for sorted flag. Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. integer(kind=i64) :: val Insert this value. Calls proc~~insertat__iddynamicarray~~CallsGraph proc~insertat__iddynamicarray insertAt__idDynamicArray emsg emsg proc~insertat__iddynamicarray->emsg interface~str str proc~insertat__iddynamicarray->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/insertat__iddynamicarray.html","tags":""},{"title":"idDynamicArray_test – Fortran Program","text":"public subroutine idDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/iddynamicarray_test.html","tags":""},{"title":"idDynamicArray – Fortran Program","text":"public interface idDynamicArray Module Procedures init_idDynamicArray_i1 init_idDynamicArray_d1D Module Procedures private function init_idDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface idDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( idDynamicArray ) Return type. private function init_idDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface idDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( idDynamicArray ) Return type","loc":"interface/iddynamicarray.html","tags":""},{"title":"insertAt__iDynamicArray – Fortran Program","text":"public subroutine insertAt__iDynamicArray(this, i, val) Private insert into array without checking for sorted flag. Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. integer(kind=i32) :: val Insert this value. Calls proc~~insertat__idynamicarray~~CallsGraph proc~insertat__idynamicarray insertAt__iDynamicArray emsg emsg proc~insertat__idynamicarray->emsg interface~str str proc~insertat__idynamicarray->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/insertat__idynamicarray.html","tags":""},{"title":"iDynamicArray_test – Fortran Program","text":"public subroutine iDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/idynamicarray_test.html","tags":""},{"title":"iDynamicArray – Fortran Program","text":"public interface iDynamicArray Module Procedures init_iDynamicArray_i1 init_iDynamicArray_d1D Module Procedures private function init_iDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface iDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( iDynamicArray ) Return type. private function init_iDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface iDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( iDynamicArray ) Return type","loc":"interface/idynamicarray.html","tags":""},{"title":"rArgDynamicArray_test – Fortran Program","text":"public subroutine rArgDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/rargdynamicarray_test.html","tags":""},{"title":"rArgDynamicArray – Fortran Program","text":"public interface rArgDynamicArray Module Procedures init_rArgDynamicArray_i1 init_rArgDynamicArray_r1D Module Procedures private function init_rArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[rArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( rArgDynamicArray ) private function init_rArgDynamicArray_r1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[rArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) real(kind=r32), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( rArgDynamicArray )","loc":"interface/rargdynamicarray.html","tags":""},{"title":"insertAt__rDynamicArray – Fortran Program","text":"public subroutine insertAt__rDynamicArray(this, i, val) Private insert into array without checking for sorted flag. Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. real(kind=r32) :: val Insert this value. Calls proc~~insertat__rdynamicarray~~CallsGraph proc~insertat__rdynamicarray insertAt__rDynamicArray emsg emsg proc~insertat__rdynamicarray->emsg interface~str str proc~insertat__rdynamicarray->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/insertat__rdynamicarray.html","tags":""},{"title":"rDynamicArray_test – Fortran Program","text":"public subroutine rDynamicArray_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/rdynamicarray_test.html","tags":""},{"title":"rDynamicArray – Fortran Program","text":"public interface rDynamicArray Module Procedures init_rDynamicArray_i1 init_rDynamicArray_d1D Module Procedures private function init_rDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface rDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( rDynamicArray ) Return type. private function init_rDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface rDynamicArray() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( rDynamicArray ) Return type","loc":"interface/rdynamicarray.html","tags":""},{"title":"maths_test – Fortran Program","text":"public subroutine maths_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/maths_test.html","tags":""},{"title":"crossproduct – Fortran Program","text":"public interface crossproduct Compute the cross product between two arrays of length 2 or 3 Functions crossproduct_r1D crossproduct_d1D Functions public function crossproduct_r1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (3) 1D Array real(kind=r32), intent(in) :: b (3) 1D Array Return Value real(kind=r32)\n  (3) cross product public function crossproduct_d1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (3) 1D Array real(kind=r64), intent(in) :: b (3) 1D Array Return Value real(kind=r64)\n  (3) cross product","loc":"interface/crossproduct.html","tags":""},{"title":"cumprod – Fortran Program","text":"public interface cumprod Compute the variance of an array Functions cumprod_r1D cumprod_d1D cumprod_i1D cumprod_id1D Functions public function cumprod_r1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative product public function cumprod_d1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative product public function cumprod_i1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative product public function cumprod_id1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative product","loc":"interface/cumprod.html","tags":""},{"title":"cumsum – Fortran Program","text":"public interface cumsum Compute the variance of an array Functions cumsum_r1D cumsum_d1D cumsum_i1D cumsum_id1D Functions public function cumsum_r1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative sum public function cumsum_d1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative sum public function cumsum_i1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative sum public function cumsum_id1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative sum","loc":"interface/cumsum.html","tags":""},{"title":"fastTwoDiff – Fortran Program","text":"public interface fastTwoDiff Compute the difference two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoDiff routine Functions fastTwoDiff_r fastTwoDiff_d Functions public function fastTwoDiff_r(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoDiff_d(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error","loc":"interface/fasttwodiff.html","tags":""},{"title":"fastTwoSum – Fortran Program","text":"public interface fastTwoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoSum routine Functions fastTwoSum_r fastTwoSum_d Functions public function fastTwoSum_r(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoSum_d(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error","loc":"interface/fasttwosum.html","tags":""},{"title":"geometricMean – Fortran Program","text":"public interface geometricMean Compute the geometric mean of a vector Functions geometricMean_r1D geometricMean_d1D geometricMean_i1D geometricMean_id1D Functions public function geometricMean_r1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_d1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_i1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_id1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) Return Value real(kind=r64)","loc":"interface/geometricmean.html","tags":""},{"title":"mean – Fortran Program","text":"public interface mean Compute the mean Functions mean_r1D mean_d1D mean_i1D mean_id1D Functions public function mean_r1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_d1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_i1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_id1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean","loc":"interface/mean.html","tags":""},{"title":"median – Fortran Program","text":"public interface median Compute the median of a set of numbers Functions median_r1D median_d1D median_i1D median_id1D Functions public function median_r1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) median public function median_d1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_i1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_id1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median","loc":"interface/median.html","tags":""},{"title":"norm1 – Fortran Program","text":"public interface norm1 Compute the L1 norm of a set of numbers Functions norm1_r1D norm1_d1D norm1_i1D norm1_id1D Functions public function norm1_r1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) L1 norm public function norm1_d1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_i1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_id1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm","loc":"interface/norm1.html","tags":""},{"title":"normI – Fortran Program","text":"public interface normI Compute the Linfinity norm of a set of numbers Functions normI_r1D normI_d1D normI_i1D normI_id1D Functions public function normI_r1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) Linfinity norm public function normI_d1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) Linfinity norm public function normI_i1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32) Linfinity norm public function normI_id1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64) Linfinity norm","loc":"interface/normi.html","tags":""},{"title":"project – Fortran Program","text":"public interface project Project a vector a onto vector b Functions project_r1D project_d1D Functions public function project_r1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (:) 1D array real(kind=r32), intent(in) :: b (size(a)) 1D array Return Value real(kind=r32)\n  (size(a)) 1D array public function project_d1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (:) 1D array real(kind=r64), intent(in) :: b (size(a)) 1D array Return Value real(kind=r64)\n  (size(a)) 1D array","loc":"interface/project.html","tags":""},{"title":"trimmedmean – Fortran Program","text":"public interface trimmedmean Compute the Trimmed mean of an array,  alpha is a percent value to trim from either end Functions trimmedmean_r1D trimmedmean_d1D trimmedmean_i1D trimmedmean_id1D Functions public function trimmedmean_r1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_d1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_i1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_id1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean","loc":"interface/trimmedmean.html","tags":""},{"title":"twoDiff – Fortran Program","text":"public interface twoDiff Compute the difference between two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoDiff Functions twoDiff_r twoDiff_d Functions public function twoDiff_r(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function twoDiff_d(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error","loc":"interface/twodiff.html","tags":""},{"title":"twoSum – Fortran Program","text":"public interface twoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoSum Functions twoSum_r twoSum_d Functions public function twoSum_r(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number in sum real(kind=r32), intent(in) :: b Second number in sum Return Value real(kind=r32)\n  (2) The sum and its error public function twoSum_d(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number in sum real(kind=r64), intent(in) :: b Second number in sum Return Value real(kind=r64)\n  (2) The sum and its error","loc":"interface/twosum.html","tags":""},{"title":"std – Fortran Program","text":"public interface std Compute the standard deviation of an array Functions std_r1D std_d1D std_i1D std_id1D Functions public function std_r1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_d1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_i1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_id1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation","loc":"interface/std.html","tags":""},{"title":"variance – Fortran Program","text":"public interface variance Compute the variance of an array Functions variance_r1D variance_d1D variance_i1D variance_id1D Functions public function variance_r1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_d1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_i1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_id1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance","loc":"interface/variance.html","tags":""},{"title":"random_test – Fortran Program","text":"public subroutine random_test(test, fixedSeed) Arguments Type Intent Optional Attributes Name class( tester ) :: test logical :: fixedSeed","loc":"proc/random_test.html","tags":""},{"title":"setRNG – Fortran Program","text":"public interface setRNG Sets the random number with or without a seed Module Procedures setRNG_Wseed setRNG_WOseed Module Procedures private subroutine setRNG_Wseed(seed) Interfaced to setRNG()\n Sets the seed of the random number generator with a specified seed Arguments Type Intent Optional Attributes Name integer :: seed (:) private subroutine setRNG_WOseed(display) Interfaced to setRNG()\n 'Randomly' sets the seed of the random number generator Arguments Type Intent Optional Attributes Name logical :: display","loc":"interface/setrng.html","tags":""},{"title":"rngChisq – Fortran Program","text":"public interface rngChisq Pull from a Chi Ssquared distribution Example program Chisq_test use variableKind , only : r64 use m_allocate , only : allocate use m_random , only : rngChiSq implicit none real ( r64 ), allocatable :: a call allocate ( a , 10000 ) call rngChiSq ( a , ) end program Subroutines rngChisq_d1 rngChisq_d1D Subroutines public subroutine rngChisq_d1(this, ndf, first) Interfaced with rngChisq Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer, intent(in) :: ndf logical, intent(in) :: first public subroutine rngChisq_d1D(this, ndf, first) Interfaced with rngChisq Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer, intent(in) :: ndf logical, intent(in) :: first","loc":"interface/rngchisq.html","tags":""},{"title":"rngExponential – Fortran Program","text":"public interface rngExponential Subroutines rngExponential_d1 rngExponential_d1D Subroutines public subroutine rngExponential_d1(this) Interfaced with rngExponential Arguments Type Intent Optional Attributes Name real(kind=r64) :: this Random number public subroutine rngExponential_d1D(this) Interfaced with rngExponential Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Random numbers","loc":"interface/rngexponential.html","tags":""},{"title":"rngGamma – Fortran Program","text":"public interface rngGamma Subroutines rngGamma_d1D rngGamma_d1 Subroutines public subroutine rngGamma_d1D(this, s, first) Interfaced with rngGamma Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), intent(in) :: s logical, intent(in) :: first public subroutine rngGamma_d1(this, s, first) Interfaced with rngGamma Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64), intent(in) :: s logical, intent(in) :: first","loc":"interface/rnggamma.html","tags":""},{"title":"rngInteger – Fortran Program","text":"public interface rngInteger Generate size(this) random integers starting from imin Subroutines rngInteger_i1 rngInteger_i1D rngInteger_i2D rngInteger_i3D rngInteger_i1D_i1 Subroutines public subroutine rngInteger_i1(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i1D(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i2D(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:,:) integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i3D(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:,:,:) integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i1D_i1(this, imin) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: imin","loc":"interface/rnginteger.html","tags":""},{"title":"rngNormal – Fortran Program","text":"public interface rngNormal Subroutines rngNormal_d1 rngNormal_d1D rngNormal_d2D rngNormal_d3D Subroutines public subroutine rngNormal_d1(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public subroutine rngNormal_d1D(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public subroutine rngNormal_d2D(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:) real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public subroutine rngNormal_d3D(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:,:) real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std","loc":"interface/rngnormal.html","tags":""},{"title":"shuffle – Fortran Program","text":"public interface shuffle Perform Knuth shuffling on an array Subroutines shuffle_r1D shuffle_d1D shuffle_i1D shuffle_id1D Subroutines public subroutine shuffle_r1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) 1D array public subroutine shuffle_d1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array public subroutine shuffle_i1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) 1D array public subroutine shuffle_id1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) 1D array","loc":"interface/shuffle.html","tags":""},{"title":"rngUniform – Fortran Program","text":"public interface rngUniform Subroutines rngUniform_d1 rngUniform_d1D rngUniform_d2D rngUniform_d3D Subroutines public subroutine rngUniform_d1(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public subroutine rngUniform_d1D(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public subroutine rngUniform_d2D(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:) real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public subroutine rngUniform_d3D(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:,:) real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax","loc":"interface/rnguniform.html","tags":""},{"title":"rngWeibull – Fortran Program","text":"public interface rngWeibull Subroutines rngWeibull_d1 rngWeibull_d1D Subroutines public subroutine rngWeibull_d1(this, den) Interfaced with rngWeibull Arguments Type Intent Optional Attributes Name real(kind=r64) :: this Random number real(kind=r64), intent(in) :: den Weibull probability density public subroutine rngWeibull_d1D(this, den) Interfaced with rngWeibull Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Random numbers real(kind=r64), intent(in) :: den Weibull probability density","loc":"interface/rngweibull.html","tags":""},{"title":"binarySearch – Fortran Program","text":"public interface binarySearch Perform a binary search.  See m_searching for more information on how to use this interface Functions binarySearch_i1D binarySearch_id1D binarySearch_r1D binarySearch_d1D Functions public recursive function binarySearch_i1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public recursive function binarySearch_id1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public recursive function binarySearch_r1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public recursive function binarySearch_d1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present","loc":"interface/binarysearch.html","tags":""},{"title":"intervalSearch – Fortran Program","text":"public interface intervalSearch Perform an interval search on an array\n Returns a length 3 integer(i32) array where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted!See m_searching for more information on how to use this interface Functions intervalSearch_i1D intervalSearch_id1D intervalSearch_r1D intervalSearch_d1D Functions public recursive function intervalSearch_i1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public recursive function intervalSearch_id1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public recursive function intervalSearch_r1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public recursive function intervalSearch_d1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval","loc":"interface/intervalsearch.html","tags":""},{"title":"simpleSearch – Fortran Program","text":"public interface simpleSearch Carry out a brute force search on an array for a given number. Returns -1 if the value is not found. Functions simpleSearch_i1D simpleSearch_id1D simpleSearch_r1D simpleSearch_d1D Functions public function simpleSearch_i1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Search this vector integer(kind=i32) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this public function simpleSearch_id1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Search this vector integer(kind=i64) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this public function simpleSearch_r1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Search this vector real(kind=r32) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this public function simpleSearch_d1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Search this vector real(kind=r64) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this","loc":"interface/simplesearch.html","tags":""},{"title":"medianOf3 – Fortran Program","text":"public interface medianOf3 Sort three numbers in an array and return the location of the median Module Procedures medianOf3_r1D medianOf3_d1D medianOf3_i1D medianOf3_id1D Module Procedures private subroutine medianOf3_r1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_d1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_i1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_id1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right","loc":"interface/medianof3.html","tags":""},{"title":"argMedianOf3 – Fortran Program","text":"public interface argMedianOf3 Sort the indices of three numbers into an array and return the location of the median Module Procedures argMedianOf3_r1D argMedianOf3_d1D argMedianOf3_i1D argMedianOf3_id1D Module Procedures private subroutine argMedianOf3_r1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_d1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_i1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_id1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right","loc":"interface/argmedianof3.html","tags":""},{"title":"select_test – Fortran Program","text":"public subroutine select_test(test, N) Arguments Type Intent Optional Attributes Name class( tester ) :: test integer(kind=i32) :: N","loc":"proc/select_test.html","tags":""},{"title":"select – Fortran Program","text":"public interface select Use an in-place quick select on an array of numbers Example usage program selectTest use variableKind use m_strings , only : str use m_allocate , only : allocate use m_random , only : rngInteger , rngNormal use m_select , only : select real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ) :: k real ( r64 ) :: dv integer ( i32 ) :: iv write ( * , '(a)' ) 'Select the kth smallest element from a 10000 length array of random double precision numbers' call allocate ( d1D , 10000 ) call rngNormal ( d1D ) k = ( 1 + size ( d1D )) / 2 dv = select ( d1D , k ) write ( * , '(a)' ) 'kth element? ' // str ( dv ) write ( * , '(a)' ) 'Select the kth smallest element from a 10000 length array of random integers'' call allocate(i1D, 10000) call rngInteger(i1D) iv = select(i1D, k) write(*,' ( a ) ') ' kth element ? ' // str ( iv ) end program Subroutines quickSelect_i1D quickSelect_id1D quickSelect_r1D quickSelect_d1D Subroutines public subroutine quickSelect_i1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res public subroutine quickSelect_id1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i64) :: res public subroutine quickSelect_r1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r32) :: res public subroutine quickSelect_d1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r64) :: res","loc":"interface/select.html","tags":""},{"title":"argSelect – Fortran Program","text":"public interface argSelect Use an indirect introspection sort on an array of numbers Example usage program argSortTest use variableKind use m_strings , only : str use m_random , only : rngInteger , rngNormal use m_arrays , only : isSorted use m_Sort , only : argSort real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ), allocatable :: indx (:) integer ( i32 ) :: i , k , N N = 10000 call allocate ( indx , N ) call arange ( indx , 1 , N ) call allocate ( d1D , N ) call rngNormal ( d1D ) k = ( size ( d1D ) + 1 ) / 2 call argSelect ( d1D , indx , k ) write ( * , '(a)' ) 'Double array is indirectly sorted? ' // str ( isSorted ( d1D ( indx ))) call arange ( indx , 1 , N ) call allocate ( i1D , N ) call rngInteger ( i1D ) call argSelectt ( i1D , indx , k ) write ( * , '(a)' ) 'Integer array is indirectly sorted? ' // str ( isSorted ( i1D ( indx ))) end program Subroutines argQuickSelect_i1D argQuickSelect_id1D argQuickSelect_r1D argQuickSelect_d1D Subroutines public subroutine argQuickSelect_i1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_id1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_r1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_d1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right","loc":"interface/argselect.html","tags":""},{"title":"sorting_test – Fortran Program","text":"public subroutine sorting_test(test, N) Arguments Type Intent Optional Attributes Name class( tester ) :: test integer(kind=i32) :: N","loc":"proc/sorting_test.html","tags":""},{"title":"sort – Fortran Program","text":"public interface sort Use an in-place introspection sort on an array of numbers Example usage program sortTest use variableKind , only : i32 , r64 use m_strings , only : str use m_allocate , only : allocate use m_random , only : rngInteger , rngNormal use m_arrays , only : arange , isSorted use m_sort , only : sort real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ) :: N N = 10000 write ( * , '(a)' ) 'In-place sort a 10000 length array of random double precision numbers' call allocate ( d1D , N ) call rngNormal ( d1D ) call sort ( d1D ) write ( * , '(a)' ) 'Double array is sorted? ' // str ( isSorted ( d1D )) write ( * , '(a)' ) 'In-place sort a 10000 length array of random integers'' call allocate(i1D,N) call rngInteger(i1D) call sort(i1D) write(*,' ( a ) ') ' Integer array is sorted ? ' // str ( isSorted ( i1D )) end program Subroutines sort_i1D sort_id1D sort_r1D sort_d1D Subroutines public subroutine sort_i1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) logical, optional :: stable public subroutine sort_id1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) logical, optional :: stable public subroutine sort_r1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) logical, optional :: stable public subroutine sort_d1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) logical, optional :: stable","loc":"interface/sort.html","tags":""},{"title":"argSort – Fortran Program","text":"public interface argSort Use an indirect introspection sort on an array of numbers Example usage program argSortTest use variableKind use m_strings , only : str use m_random , only : rngInteger , rngNormal use m_arrays , only : arange , isSorted use m_Sort , only : argSort real ( r64 ), allocatable :: d1D (:) integer ( i32 ), allocatable :: i1D (:) integer ( i32 ), allocatable :: indx (:) integer ( i32 ) :: i , N N = 10000 call allocate ( indx , N ) call arange ( indx , 1 , N ) call allocate ( d1D , N ) call rngNormal ( d1D ) call argSort ( d1D , indx ) write ( * , '(a)' ) 'Double array is indirectly sorted? ' // str ( isSorted ( d1D ( indx ))) call arange ( indx , 1 , N ) call allocate ( i1D , N ) call rngInteger ( i1D ) call argSort ( i1D , indx ) write ( * , '(a)' ) 'Integer array is indirectly sorted? ' // str ( isSorted ( i1D ( indx ))) end program Subroutines argSort_i1D argSort_id1D argSort_r1D argSort_d1D Subroutines public subroutine argSort_i1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_id1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_r1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_d1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort?","loc":"interface/argsort.html","tags":""},{"title":"insertionsort – Fortran Program","text":"public interface insertionsort Perform an in-place insertion sort on an array Subroutines insertionsort_r1D insertionsort_d1D insertionsort_i1D insertionsort_id1D Subroutines public subroutine insertionsort_r1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_d1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_i1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_id1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index","loc":"interface/insertionsort.html","tags":""},{"title":"argInsertionsort – Fortran Program","text":"public interface argInsertionsort Perform an indirect insertion sort on an array Subroutines argInsertionsort_r1D argInsertionsort_d1D argInsertionsort_i1D argInsertionsort_id1D Subroutines public subroutine argInsertionsort_r1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_d1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_i1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_id1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index","loc":"interface/arginsertionsort.html","tags":""},{"title":"KdTree – Fortran Program","text":"public interface KdTree Overloaded Initializer for a KdTree. Can be used to create a 2D, 3D, or ND, KdTree class. See m_KdTree for more information on how to use this class Functions init2D_KdTree init3D_KdTree initKD_KdTree Functions public function init2D_KdTree(x, y) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) x-coordinates of the points real(kind=r64), intent(in) :: y (:) y-coordinates of the points Return Value type( KdTree ) KdTree Class public function init3D_KdTree(x, y, z) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) x-coordinates of the points real(kind=r64), intent(in) :: y (:) y-coordinates of the points real(kind=r64), intent(in) :: z (:) z-coordinates of the points Return Value type( KdTree ) KdTree Class public function initKD_KdTree(D) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: D (:,:) Coordinates of the points, the k columns contain the k dimensional values. Return Value type( KdTree ) KdTree Class","loc":"interface/kdtree.html","tags":""},{"title":"timeinseconds – Fortran Program","text":"public function timeinseconds(values) result(res) Convert hours minutes seconds etc. to seconds Arguments Type Intent Optional Attributes Name integer(kind=i32) :: values (8) values containing amounts of days hours etc. Return Value real(kind=r64) time in seconds","loc":"proc/timeinseconds.html","tags":""},{"title":"daysinMonth – Fortran Program","text":"public function daysinMonth(month, year) result(days) Get the number of days in a month. Accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: month How many days in this month integer(kind=i32), optional :: year Check if a leap year? Return Value integer(kind=i32) Number of days Calls proc~~daysinmonth~~CallsGraph proc~daysinmonth daysinMonth proc~isleapyear isLeapYear proc~daysinmonth->proc~isleapyear Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/daysinmonth.html","tags":""},{"title":"daysinYear – Fortran Program","text":"public function daysinYear(year) result(days) Get the number of days in a year, accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year How many days in this year Return Value integer(kind=i32) Number of days Calls proc~~daysinyear~~CallsGraph proc~daysinyear daysinYear proc~isleapyear isLeapYear proc~daysinyear->proc~isleapyear Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/daysinyear.html","tags":""},{"title":"isLeapYear – Fortran Program","text":"public function isLeapYear(year) result(yes) Determine whether the year is a leap year Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year Year to check Return Value logical is a leap year Called By proc~~isleapyear~~CalledByGraph proc~isleapyear isLeapYear proc~daysinmonth daysinMonth proc~daysinmonth->proc~isleapyear proc~daysinyear daysinYear proc~daysinyear->proc~isleapyear Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","loc":"proc/isleapyear.html","tags":""},{"title":"absTimetoHMS – Fortran Program","text":"public function absTimetoHMS(t) result(res) Convert an absolute time to HH:MM:SS.MSEC Arguments Type Intent Optional Attributes Name real(kind=r64) :: t Time in seconds Return Value character(len=22) Resulting string contains the time","loc":"proc/abstimetohms.html","tags":""},{"title":"time_test – Fortran Program","text":"public subroutine time_test(test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"proc/time_test.html","tags":""},{"title":"ProgressBar – Fortran Program","text":"public interface ProgressBar Module Procedures ProgressBar_i1 ProgressBar_id1 Module Procedures private function ProgressBar_i1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) private function ProgressBar_id1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar )","loc":"interface/progressbar.html","tags":""},{"title":"m_array1D – Fortran Program","text":"Uses: variableKind m_errors m_allocate m_deallocate m_unitTester module~~m_array1d~~UsesGraph module~m_array1d m_array1D module~m_allocate m_allocate module~m_allocate->module~m_array1d module~variablekind variableKind module~variablekind->module~m_array1d module~variablekind->module~m_allocate module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_errors->module~m_array1d module~m_errors->module~m_allocate module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_unittester->module~m_array1d module~m_unittester->module~m_allocate module~m_deallocate->module~m_array1d iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. 1D array routines See arange , diff , isSorted , repeat for more information. Used By module~~m_array1d~~UsedByGraph module~m_array1d m_array1D module~m_maths m_maths module~m_array1d->module~m_maths module~m_sort m_sort module~m_array1d->module~m_sort module~m_select m_select module~m_array1d->module~m_select module~m_kdtree m_KdTree module~m_array1d->module~m_kdtree module~m_random m_random module~m_array1d->module~m_random module~m_maths->module~m_kdtree module~m_sort->module~m_maths module~m_sort->module~m_select module~m_idynamicarray m_iDynamicArray module~m_sort->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_sort->module~m_rdynamicarray module~m_iddynamicarray m_idDynamicArray module~m_sort->module~m_iddynamicarray module~m_ddynamicarray m_dDynamicArray module~m_sort->module~m_ddynamicarray module~m_select->module~m_maths module~m_select->module~m_kdtree module~m_random->module~m_sort module~m_random->module~m_select module~m_random->module~m_kdtree module~m_idynamicarray->module~m_kdtree module~m_dargdynamicarray m_dArgDynamicArray module~m_idynamicarray->module~m_dargdynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_idynamicarray->module~m_idargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_idynamicarray->module~m_iargdynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_idynamicarray->module~m_rargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_iddynamicarray->module~m_idargdynamicarray module~m_ddynamicarray->module~m_dargdynamicarray module~m_dargdynamicarray->module~m_kdtree var panmodulem_array1dUsedByGraph = svgPanZoom('#modulem_array1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces arange diff isSorted repeat Subroutines array1D_test Interfaces public interface arange Create a 1D array from start to stop in given increments of 1 or optionally step public subroutine arange_r1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: res (:) real(kind=r32), intent(in) :: start Start from here real(kind=r32), intent(in) :: stp Stop here real(kind=r32), intent(in), optional :: step Step size public subroutine arange_d1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: res (:) real(kind=r64), intent(in) :: start Start from here real(kind=r64), intent(in) :: stp Stop here real(kind=r64), intent(in), optional :: step Step size public subroutine arange_i1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: res (:) integer(kind=i32), intent(in) :: start Start from here integer(kind=i32), intent(in) :: stp Stop here integer(kind=i32), intent(in), optional :: step Step size public subroutine arange_id1D(res, start, stp, step) Interfaced with arange Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: res (:) integer(kind=i64), intent(in) :: start Start from here integer(kind=i64), intent(in) :: stp Stop here integer(kind=i64), intent(in), optional :: step Step size public interface diff Compute the difference along an array public subroutine diff_r1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32) :: res (:) Difference along array public subroutine diff_d1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64) :: res (:) Difference along array public subroutine diff_i1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32) :: res (:) Difference along array public subroutine diff_id1D(this, res) Interfaced with diff Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i64) :: res (:) Difference along array public interface isSorted Check that a 1D array is sorted public function isSorted_r1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_d1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_i1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_id1D(this) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value logical isSorted public function isSorted_r1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public function isSorted_d1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public function isSorted_i1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public function isSorted_id1Di1D(this, indx) result(yes) Interfaced with isSorted Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i32), intent(in) :: indx (:) Index into 1D array Return Value logical isSorted public interface repeat Repeat each element nRepeat times public subroutine repeat_r1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r32), allocatable :: res (:) public subroutine repeat_d1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated real(kind=r64), allocatable :: res (:) public subroutine repeat_i1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i32), allocatable :: res (:) public subroutine repeat_id1D(this, nRepeats, res) Interfaced with repeat Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: nRepeats Number of times each element should be repeated integer(kind=i64), allocatable :: res (:) Subroutines public subroutine array1D_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_array1d.html","tags":""},{"title":"m_allocate – Fortran Program","text":"Uses: variableKind m_unitTester m_errors module~~m_allocate~~UsesGraph module~m_allocate m_allocate module~variablekind variableKind module~variablekind->module~m_allocate module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_errors->module~m_allocate module~m_errors->module~m_unittester module~m_unittester->module~m_allocate iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains fundamental interface to allocate allocatable arrays of different types and shapes See allocate for more information. Used By module~~m_allocate~~UsedByGraph module~m_allocate m_allocate module~m_strings m_strings module~m_allocate->module~m_strings module~m_reallocate m_reallocate module~m_allocate->module~m_reallocate module~m_kdtree m_KdTree module~m_allocate->module~m_kdtree module~m_idynamicarray m_iDynamicArray module~m_allocate->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_allocate->module~m_rdynamicarray module~m_array1d m_array1D module~m_allocate->module~m_array1d module~m_maths m_maths module~m_allocate->module~m_maths module~m_random m_random module~m_allocate->module~m_random module~m_sort m_sort module~m_allocate->module~m_sort module~m_select m_select module~m_allocate->module~m_select module~m_iddynamicarray m_idDynamicArray module~m_allocate->module~m_iddynamicarray module~m_ddynamicarray m_dDynamicArray module~m_allocate->module~m_ddynamicarray module~m_copy m_copy module~m_allocate->module~m_copy module~m_strings->module~m_kdtree module~m_strings->module~m_idynamicarray module~m_strings->module~m_rdynamicarray module~m_strings->module~m_random module~m_strings->module~m_iddynamicarray module~m_strings->module~m_ddynamicarray module~m_fileio m_fileIO module~m_strings->module~m_fileio module~m_writeline m_writeline module~m_strings->module~m_writeline module~m_readline m_readline module~m_strings->module~m_readline module~m_debugging m_debugging module~m_strings->module~m_debugging module~m_idargdynamicarray m_idArgDynamicArray module~m_strings->module~m_idargdynamicarray module~stopwatch_class Stopwatch_Class module~m_strings->module~stopwatch_class module~m_rargdynamicarray m_rArgDynamicArray module~m_strings->module~m_rargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_strings->module~m_dargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_strings->module~m_iargdynamicarray module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_rdynamicarray module~m_reallocate->module~m_iddynamicarray module~m_reallocate->module~m_ddynamicarray module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_array1d->module~m_kdtree module~m_array1d->module~m_maths module~m_array1d->module~m_random module~m_array1d->module~m_sort module~m_array1d->module~m_select module~m_maths->module~m_kdtree module~m_random->module~m_kdtree module~m_random->module~m_sort module~m_random->module~m_select module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_sort->module~m_maths module~m_sort->module~m_select module~m_sort->module~m_iddynamicarray module~m_sort->module~m_ddynamicarray module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_iddynamicarray->module~m_idargdynamicarray module~m_ddynamicarray->module~m_dargdynamicarray module~m_writeline->module~m_fileio module~m_readline->module~m_fileio module~progressbar_class ProgressBar_Class module~stopwatch_class->module~progressbar_class module~m_dargdynamicarray->module~m_kdtree var panmodulem_allocateUsedByGraph = svgPanZoom('#modulem_allocateUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces allocate Subroutines allocate_test Interfaces public interface allocate Allocate an allocatable array. If the array is already allocated, memory is reallocated to the given size, unless no size change will occur.\n The allocated memory is NOT initialized to any value, so be sure to do so afterwards if you call allocate. public subroutine allocate_r1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_r2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_r3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_d1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_d2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_d3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_i1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_i2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_i3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_id1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_id2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_id3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_c1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_c2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_c3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_z1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_z2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_z3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size public subroutine allocate_l1D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n Allocation size public subroutine allocate_l2D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 1D array integer(kind=i32), intent(in) :: n (2) Allocation size public subroutine allocate_l3D(this, n) Interfaced with allocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 1D array integer(kind=i32), intent(in) :: n (3) Allocation size Subroutines public subroutine allocate_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_allocate.html","tags":""},{"title":"m_compare – Fortran Program","text":"Uses: variableKind module~~m_compare~~UsesGraph module~m_compare m_compare module~variablekind variableKind module~variablekind->module~m_compare iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~m_compare~~UsedByGraph module~m_compare m_compare module~m_partition3way m_partition3way module~m_compare->module~m_partition3way Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces compare Functions compare_d1 Interfaces public interface compare public function compare_d1 (this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32) Functions public function compare_d1 (this, that) result(res) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64) :: that Return Value integer(kind=i32)","loc":"module/m_compare.html","tags":""},{"title":"m_copy – Fortran Program","text":"Uses: variableKind m_errors m_allocate m_unitTester module~~m_copy~~UsesGraph module~m_copy m_copy module~m_allocate m_allocate module~m_allocate->module~m_copy module~variablekind variableKind module~variablekind->module~m_copy module~variablekind->module~m_allocate module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_errors->module~m_copy module~m_errors->module~m_allocate module~m_errors->module~m_unittester module~m_unittester->module~m_copy module~m_unittester->module~m_allocate iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains fundamental routines to copy arrays to new memory locations while maintaining both copies See copy for more information. Interfaces copy Subroutines copy_test Interfaces public interface copy Copies an array to new memory (no pointers), The output array size will be changed to match the copy. public subroutine copy_r1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_r2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_r3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_d1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_d2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_d3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array real(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_i1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_i2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_i3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_id1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_id2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_id3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in), allocatable :: this (:,:,:) Copy this array integer(kind=i64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_c1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_c2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_c3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r32), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_z1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:) Copy of this public subroutine copy_z2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_z3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in), allocatable :: this (:,:,:) Copy this array complex(kind=r64), intent(inout), allocatable :: that (:,:,:) Copy of this public subroutine copy_l1D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:) Copy this array logical, intent(inout), allocatable :: that (:) Copy of this public subroutine copy_l2D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:) Copy this array logical, intent(inout), allocatable :: that (:,:) Copy of this public subroutine copy_l3D(this, that) Interfaced with copy Arguments Type Intent Optional Attributes Name logical, intent(in), allocatable :: this (:,:,:) Copy this array logical, intent(inout), allocatable :: that (:,:,:) Copy of this Subroutines public subroutine copy_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_copy.html","tags":""},{"title":"m_deallocate – Fortran Program","text":"Uses: variableKind m_errors module~~m_deallocate~~UsesGraph module~m_deallocate m_deallocate module~variablekind variableKind module~variablekind->module~m_deallocate module~m_errors m_errors module~variablekind->module~m_errors module~m_errors->module~m_deallocate iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains fundamental interface to deallocate allocatable arrays of different types and shapes. See deallocate for more information. Used By module~~m_deallocate~~UsedByGraph module~m_deallocate m_deallocate module~m_strings m_strings module~m_deallocate->module~m_strings module~m_kdtree m_KdTree module~m_deallocate->module~m_kdtree module~m_idynamicarray m_iDynamicArray module~m_deallocate->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_deallocate->module~m_rdynamicarray module~m_array1d m_array1D module~m_deallocate->module~m_array1d module~m_maths m_maths module~m_deallocate->module~m_maths module~m_random m_random module~m_deallocate->module~m_random module~m_select m_select module~m_deallocate->module~m_select module~m_iddynamicarray m_idDynamicArray module~m_deallocate->module~m_iddynamicarray module~m_ddynamicarray m_dDynamicArray module~m_deallocate->module~m_ddynamicarray module~m_strings->module~m_kdtree module~m_strings->module~m_idynamicarray module~m_strings->module~m_rdynamicarray module~m_strings->module~m_random module~m_strings->module~m_iddynamicarray module~m_strings->module~m_ddynamicarray module~m_fileio m_fileIO module~m_strings->module~m_fileio module~m_writeline m_writeline module~m_strings->module~m_writeline module~m_readline m_readline module~m_strings->module~m_readline module~m_debugging m_debugging module~m_strings->module~m_debugging module~m_idargdynamicarray m_idArgDynamicArray module~m_strings->module~m_idargdynamicarray module~stopwatch_class Stopwatch_Class module~m_strings->module~stopwatch_class module~m_rargdynamicarray m_rArgDynamicArray module~m_strings->module~m_rargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_strings->module~m_dargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_strings->module~m_iargdynamicarray module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_array1d->module~m_kdtree module~m_array1d->module~m_maths module~m_array1d->module~m_random module~m_array1d->module~m_select module~m_sort m_sort module~m_array1d->module~m_sort module~m_maths->module~m_kdtree module~m_random->module~m_kdtree module~m_random->module~m_select module~m_random->module~m_sort module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_iddynamicarray->module~m_idargdynamicarray module~m_ddynamicarray->module~m_dargdynamicarray module~m_writeline->module~m_fileio module~m_readline->module~m_fileio module~progressbar_class ProgressBar_Class module~stopwatch_class->module~progressbar_class module~m_dargdynamicarray->module~m_kdtree module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_sort->module~m_maths module~m_sort->module~m_select module~m_sort->module~m_iddynamicarray module~m_sort->module~m_ddynamicarray var panmodulem_deallocateUsedByGraph = svgPanZoom('#modulem_deallocateUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces deallocate Interfaces public interface deallocate Deallocate an allocatable array. public subroutine deallocate_r1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_r2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_r3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_d1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_d2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_d3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_i1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_i2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_i3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_id1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_id2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_id3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_c1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_c2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_c3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_z1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_z2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_z3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array public subroutine deallocate_l1D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array public subroutine deallocate_l2D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array public subroutine deallocate_l3D(this) Interfaced with deallocate Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array","loc":"module/m_deallocate.html","tags":""},{"title":"m_debugging – Fortran Program","text":"Uses: variableKind m_strings module~~m_debugging~~UsesGraph module~m_debugging m_debugging module~variablekind variableKind module~variablekind->module~m_debugging module~m_strings m_strings module~variablekind->module~m_strings module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_allocate m_allocate module~variablekind->module~m_allocate module~m_errors m_errors module~variablekind->module~m_errors module~m_strings->module~m_debugging iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors module~m_parameters->module~m_strings module~m_unittester->module~m_strings module~m_unittester->module~m_allocate module~m_deallocate->module~m_strings module~m_allocate->module~m_strings module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate var panmodulem_debuggingUsesGraph = svgPanZoom('#modulem_debuggingUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains routines for debugging Variables verbose debugLevel Interfaces debug Subroutines debug_s Variables Type Visibility Attributes Name Initial logical, public :: verbose = .false. Verbose option for debugging codes integer, public :: debugLevel Integer level for debug messages Interfaces public interface debug Interface for printing primitives with a name for debug purposes\n All may be called using 'call debug(args)' private subroutine debug_D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var private subroutine debug_D1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name real(kind=r64) :: var (:) private subroutine debug_I(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var private subroutine debug_I1D(name, var) Arguments Type Intent Optional Attributes Name character(len=*) :: name integer(kind=i32) :: var (:) Subroutines public subroutine debug_s (name) Arguments Type Intent Optional Attributes Name character(len=*) :: name","loc":"module/m_debugging.html","tags":""},{"title":"m_errors – Fortran Program","text":"Uses: iso_fortran_env variableKind module~~m_errors~~UsesGraph module~m_errors m_errors module~variablekind variableKind module~variablekind->module~m_errors iso_fortran_env iso_fortran_env iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module contains error handling procedures Used By module~~m_errors~~UsedByGraph module~m_errors m_errors module~m_kdtree m_KdTree module~m_errors->module~m_kdtree module~m_unittester m_unitTester module~m_errors->module~m_unittester module~m_maths m_maths module~m_errors->module~m_maths module~m_array1d m_array1D module~m_errors->module~m_array1d module~m_time m_time module~m_errors->module~m_time module~m_allocate m_allocate module~m_errors->module~m_allocate module~m_rargdynamicarray m_rArgDynamicArray module~m_errors->module~m_rargdynamicarray module~m_iddynamicarray m_idDynamicArray module~m_errors->module~m_iddynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_errors->module~m_iargdynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_errors->module~m_idargdynamicarray module~m_reallocate m_reallocate module~m_errors->module~m_reallocate module~m_fileio m_fileIO module~m_errors->module~m_fileio module~m_readline m_readline module~m_errors->module~m_readline module~m_select m_select module~m_errors->module~m_select module~m_dargdynamicarray m_dArgDynamicArray module~m_errors->module~m_dargdynamicarray module~m_ddynamicarray m_dDynamicArray module~m_errors->module~m_ddynamicarray module~m_copy m_copy module~m_errors->module~m_copy module~m_strings m_strings module~m_errors->module~m_strings module~m_idynamicarray m_iDynamicArray module~m_errors->module~m_idynamicarray module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_rdynamicarray m_rDynamicArray module~m_errors->module~m_rdynamicarray module~m_indexing m_indexing module~m_errors->module~m_indexing module~m_writeline m_writeline module~m_errors->module~m_writeline module~m_random m_random module~m_errors->module~m_random module~m_sort m_sort module~m_errors->module~m_sort module~m_unittester->module~m_maths module~m_unittester->module~m_array1d module~m_unittester->module~m_time module~m_unittester->module~m_allocate module~m_unittester->module~m_rargdynamicarray module~m_unittester->module~m_iddynamicarray module~m_unittester->module~m_iargdynamicarray module~m_unittester->module~m_idargdynamicarray module~m_unittester->module~m_reallocate module~m_unittester->module~m_fileio module~m_unittester->module~m_select module~m_unittester->module~m_dargdynamicarray module~m_unittester->module~m_ddynamicarray module~m_unittester->module~m_copy module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_rdynamicarray module~m_unittester->module~m_indexing module~m_unittester->module~m_random module~m_unittester->module~m_sort module~m_maths->module~m_kdtree module~m_array1d->module~m_kdtree module~m_array1d->module~m_maths module~m_array1d->module~m_select module~m_array1d->module~m_random module~m_array1d->module~m_sort module~stopwatch_class Stopwatch_Class module~m_time->module~stopwatch_class module~progressbar_class ProgressBar_Class module~m_time->module~progressbar_class module~m_allocate->module~m_kdtree module~m_allocate->module~m_maths module~m_allocate->module~m_array1d module~m_allocate->module~m_iddynamicarray module~m_allocate->module~m_reallocate module~m_allocate->module~m_select module~m_allocate->module~m_ddynamicarray module~m_allocate->module~m_copy module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_rdynamicarray module~m_allocate->module~m_random module~m_allocate->module~m_sort module~m_iddynamicarray->module~m_idargdynamicarray module~m_reallocate->module~m_iddynamicarray module~m_reallocate->module~m_ddynamicarray module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_rdynamicarray module~m_readline->module~m_fileio module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_dargdynamicarray->module~m_kdtree module~m_ddynamicarray->module~m_dargdynamicarray module~m_strings->module~m_kdtree module~m_strings->module~m_rargdynamicarray module~m_strings->module~m_iddynamicarray module~m_strings->module~m_iargdynamicarray module~m_strings->module~m_idargdynamicarray module~m_strings->module~m_fileio module~m_strings->module~m_readline module~m_strings->module~m_dargdynamicarray module~m_strings->module~m_ddynamicarray module~m_strings->module~m_idynamicarray module~m_strings->module~m_rdynamicarray module~m_strings->module~m_writeline module~m_strings->module~m_random module~m_strings->module~stopwatch_class module~m_debugging m_debugging module~m_strings->module~m_debugging module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_deallocate->module~m_kdtree module~m_deallocate->module~m_maths module~m_deallocate->module~m_array1d module~m_deallocate->module~m_iddynamicarray module~m_deallocate->module~m_select module~m_deallocate->module~m_ddynamicarray module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_rdynamicarray module~m_deallocate->module~m_random module~m_rdynamicarray->module~m_rargdynamicarray module~m_writeline->module~m_fileio module~m_random->module~m_kdtree module~m_random->module~m_select module~m_random->module~m_sort module~m_sort->module~m_maths module~m_sort->module~m_iddynamicarray module~m_sort->module~m_select module~m_sort->module~m_ddynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~stopwatch_class->module~progressbar_class var panmodulem_errorsUsedByGraph = svgPanZoom('#modulem_errorsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Subroutines mErr msg wMsg eMsg fErr Subroutines public subroutine mErr (istat, aMsg, alloc, iunit) Checks for successful (de)allocation.  Stops the code. Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat results of stat=istat in (de)allocate character(len=*), intent(in) :: aMsg Message associated with the (de)allocate integer(kind=i32), intent(in) :: alloc 1 = allocate, 2 = deallocate integer(kind=i32), intent(in), optional :: iunit Optional file id to write the message to public subroutine msg (aMsg, iunit) Write a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to public subroutine wMsg (aMsg, iunit) Write a Warning message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to public subroutine eMsg (aMsg, iunit) Write an Error message. Stops the code Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aMsg Message to write integer(kind=i32), intent(in), optional :: iunit file id to write the message to public subroutine fErr (istat, fname, flg, iunit) Checks for a file error Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: istat Result of iostat=istat for open,read,write,close character(len=*), intent(in) :: fname Name of the file integer(kind=i32), intent(in) :: flg 1=Open, 2=Read, 3=Write, 4=Close integer(kind=i32), intent(in), optional :: iunit file id to write the error to","loc":"module/m_errors.html","tags":""},{"title":"m_fileIO – Fortran Program","text":"Uses: variableKind m_strings m_errors m_readline m_writeline m_unitTester module~~m_fileio~~UsesGraph module~m_fileio m_fileIO module~m_strings m_strings module~m_strings->module~m_fileio module~m_writeline m_writeline module~m_strings->module~m_writeline module~m_readline m_readline module~m_strings->module~m_readline module~m_unittester m_unitTester module~m_unittester->module~m_fileio module~m_unittester->module~m_strings module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_writeline->module~m_fileio module~m_readline->module~m_fileio module~m_errors m_errors module~m_errors->module~m_fileio module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_writeline module~m_errors->module~m_readline module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~variablekind variableKind module~variablekind->module~m_fileio module~variablekind->module~m_strings module~variablekind->module~m_unittester module~variablekind->module~m_writeline module~variablekind->module~m_readline module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_allocate->module~m_strings iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_writeline iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind var panmodulem_fileioUsesGraph = svgPanZoom('#modulem_fileioUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains functions and subroutines that inquire and operate on files\n including reading and writing multiple entries to a file Functions fileExists hasExtension isOpen getFileSize getNFileLines getExtension trimExtension Subroutines checkIsOpen openFile openBinaryFile closeFile deleteFile skipFileLines fileIO_test Functions public function fileExists (fName) result(yes) Checks whether the file with name fName exists on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name to check Return Value logical Exists? public function hasExtension (fName, extension) result(yes) Checks if a file 'fname' is of type 'extension' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name character(len=3), intent(in) :: extension Extension to find Return Value logical Has this extension? public function isOpen (fname) result(yes) Is the file open or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name Return Value logical Is the file open? public function getFileSize (fName) result(that) Get the file size in Bytes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value integer(kind=i32) Size of the file public function getNFileLines (fName, nHeader) result(N) Counts the number of lines in a file after the number of specified header lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name integer(kind=i32), intent(in), optional :: nHeader Skip this number of lines at the top of the file Return Value integer(kind=i32) Number of lines in the file public function getExtension (fName) result(that) Get the extension of a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File extension public function trimExtension (fName) result(that) Trims the extension of a filename Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name Return Value character(len=:),\n  allocatable File name without the extension Subroutines public subroutine checkIsOpen (fName) Checks whether a file is open with an error message if not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fName File name public subroutine openFile (fname, iunit, stat, istat) Open a file and perform necessary checks for failure\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error flag public subroutine openBinaryFile (fname, iunit, stat, istat) Open an unformatted binary file\n stat should be 'new','old','unknown','append' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File Name integer(kind=i32), intent(out) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are opening integer(kind=i32), intent(out) :: istat Error Flag public subroutine closeFile (fname, iunit, stat, istat) Close a file and perform any necessary checks Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit Unit number returned character(len=*), intent(in) :: stat Status of the file you are closing integer(kind=i32), intent(out) :: istat Error Flag public subroutine deleteFile (fname) Deletes a file on disk Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname File name to delete public subroutine skipFileLines (iunit, N) Skip N lines in a file Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit Unit number to skip integer(kind=i32), intent(in) :: N Number of lines to skip public subroutine fileIO_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_fileio.html","tags":""},{"title":"formatting – Fortran Program","text":"Uses: variableKind module~~formatting~~UsesGraph module~formatting formatting module~variablekind variableKind module~variablekind->module~formatting iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains routines that handle string formatting","loc":"module/formatting.html","tags":""},{"title":"m_indexing – Fortran Program","text":"Uses: variableKind m_errors m_unitTester module~~m_indexing~~UsesGraph module~m_indexing m_indexing module~variablekind variableKind module~variablekind->module~m_indexing module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_errors->module~m_indexing module~m_errors->module~m_unittester module~m_unittester->module~m_indexing iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains routines to obtain packed and unpacked indices into arrays Functions ind2sub sub2ind integerBin Subroutines indexing_test Functions public function ind2sub (iG, nSub) result(iSub) Compute the indices in each dimension from the global index Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iG Index into a global vector integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32)\n  (size(nSub)) Indices in each dimension to return public function sub2ind (iSub, nSub) result(iG) Given component indices, get the global vector location. Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iSub (:) Indices in each dimension. The first entry in iL is the left most index integer(kind=i32), intent(in) :: nSub (:) Size in each dimension Return Value integer(kind=i32) Index in the global vector public function integerBin (this, n, bound) result(i) Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer(kind=i32) :: n logical :: bound Return Value integer(kind=i32) Subroutines public subroutine indexing_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_indexing.html","tags":""},{"title":"m_parameters – Fortran Program","text":"Uses: variableKind module~~m_parameters~~UsesGraph module~m_parameters m_parameters module~variablekind variableKind module~variablekind->module~m_parameters iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module contains user defined parameters for consistent use Used By module~~m_parameters~~UsedByGraph module~m_parameters m_parameters module~m_strings m_strings module~m_parameters->module~m_strings module~m_kdtree m_KdTree module~m_strings->module~m_kdtree module~m_idynamicarray m_iDynamicArray module~m_strings->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_strings->module~m_rdynamicarray module~m_random m_random module~m_strings->module~m_random module~m_fileio m_fileIO module~m_strings->module~m_fileio module~m_writeline m_writeline module~m_strings->module~m_writeline module~m_readline m_readline module~m_strings->module~m_readline module~m_debugging m_debugging module~m_strings->module~m_debugging module~m_idargdynamicarray m_idArgDynamicArray module~m_strings->module~m_idargdynamicarray module~stopwatch_class Stopwatch_Class module~m_strings->module~stopwatch_class module~m_iddynamicarray m_idDynamicArray module~m_strings->module~m_iddynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_strings->module~m_rargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_strings->module~m_dargdynamicarray module~m_ddynamicarray m_dDynamicArray module~m_strings->module~m_ddynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_strings->module~m_iargdynamicarray module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_random->module~m_kdtree module~m_sort m_sort module~m_random->module~m_sort module~m_select m_select module~m_random->module~m_select module~m_writeline->module~m_fileio module~m_readline->module~m_fileio module~progressbar_class ProgressBar_Class module~stopwatch_class->module~progressbar_class module~m_iddynamicarray->module~m_idargdynamicarray module~m_dargdynamicarray->module~m_kdtree module~m_ddynamicarray->module~m_dargdynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_sort->module~m_iddynamicarray module~m_sort->module~m_ddynamicarray module~m_sort->module~m_select module~m_maths m_maths module~m_sort->module~m_maths module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_maths->module~m_kdtree var panmodulem_parametersUsedByGraph = svgPanZoom('#modulem_parametersUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables inf NaN pi Variables Type Visibility Attributes Name Initial real(kind=r64), public, parameter :: inf = huge(0.d0) real(kind=r64), public, parameter :: NaN = transfer((/Z'00000000', Z'7FF80000'/), 1.0_r64) real(kind=r64), public, parameter :: pi = dacos(-1.d0)","loc":"module/m_parameters.html","tags":""},{"title":"m_partition – Fortran Program","text":"Uses: variableKind module~~m_partition~~UsesGraph module~m_partition m_partition module~variablekind variableKind module~variablekind->module~m_partition iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains Hoare's style partitioning algorithm used for quicksorting and quickselect routines. See partition and argPartition for more information. Interfaces partition argPartition Interfaces public interface partition Partitioning used for quickSort and quickSelect routines public subroutine partition_r1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_d1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(in) :: left Left index integer(kind=i32), intent(in) :: right Right index integer(kind=i32), intent(inout) :: iPivot Pivoting index public subroutine partition_i1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot public subroutine partition_id1D(this, left, right, iPivot) Interfaced with partition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: iPivot public interface argPartition Partitioning used for argQuicksort routines public subroutine argPartition_r1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_d1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_i1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i public subroutine argPartition_id1D(this, idx, left, right, i) Interfaced with argPartition Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) integer(kind=i32), intent(inout) :: idx (:) integer(kind=i32), intent(in) :: left integer(kind=i32), intent(in) :: right integer(kind=i32), intent(inout) :: i","loc":"module/m_partition.html","tags":""},{"title":"m_partition3way – Fortran Program","text":"Uses: variableKind m_swap m_compare module~~m_partition3way~~UsesGraph module~m_partition3way m_partition3way module~m_compare m_compare module~m_compare->module~m_partition3way module~variablekind variableKind module~variablekind->module~m_partition3way module~variablekind->module~m_compare module~m_swap m_swap module~variablekind->module~m_swap module~m_swap->module~m_partition3way iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains Hoare's style partitioning algorithms used for quicksorting routines\n  n=(right+left)/2\n  call swap(idx(left),idx(n)) Interfaces partition3way Subroutines partition3way_d1D Interfaces public interface partition3way Partitioning used for quicksort routines public subroutine partition3way_d1D (this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index Subroutines public subroutine partition3way_d1D (this, left, right, iPivot1, iPivot2) Interfaced with partition() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array integer(kind=i32), intent(inout) :: left Left index integer(kind=i32), intent(inout) :: right Right index integer(kind=i32), intent(inout) :: iPivot1 Pivoting index integer(kind=i32), intent(inout) :: iPivot2 Pivoting index","loc":"module/m_partition3way.html","tags":""},{"title":"m_readline – Fortran Program","text":"Uses: variableKind m_errors m_strings module~~m_readline~~UsesGraph module~m_readline m_readline module~variablekind variableKind module~variablekind->module~m_readline module~m_errors m_errors module~variablekind->module~m_errors module~m_strings m_strings module~variablekind->module~m_strings module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_allocate m_allocate module~variablekind->module~m_allocate module~m_errors->module~m_readline module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_strings->module~m_readline iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester module~m_parameters->module~m_strings module~m_unittester->module~m_strings module~m_unittester->module~m_allocate module~m_deallocate->module~m_strings module~m_allocate->module~m_strings var panmodulem_readlineUsesGraph = svgPanZoom('#modulem_readlineUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains core routines to read different combinations of scalars and 1D arrays from a file Used By module~~m_readline~~UsedByGraph module~m_readline m_readline module~m_fileio m_fileIO module~m_readline->module~m_fileio Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces readline Interfaces public interface readline Read in multiple items from a line private subroutine readLine_a(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_ab(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abc(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcd(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcde(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_av(a, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_avbvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a (:) Vector real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abv(a, b, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abvcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b (:) Vector real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdvev(a, b, c, d, e, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d (:) Vector real(kind=r64), intent(out) :: e (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcv(a, b, c, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcvdv(a, b, c, d, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c (:) Vector real(kind=r64), intent(out) :: d (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefv(a, b, c, d, e, f, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file private subroutine readLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit, buf) Interfaced with readLine() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out) :: a Number real(kind=r64), intent(out) :: b Number real(kind=r64), intent(out) :: c Number real(kind=r64), intent(out) :: d Number real(kind=r64), intent(out) :: e Number real(kind=r64), intent(out) :: f (:) Vector real(kind=r64), intent(out) :: g (:) Vector character(len=*), intent(in) :: fname File name integer(kind=i32), intent(in) :: iunit File id number to read from character(len=*), intent(in), optional :: buf Character string to read from instead of the line in the file","loc":"module/m_readline.html","tags":""},{"title":"m_reallocate – Fortran Program","text":"Uses: variableKind m_allocate m_errors m_unitTester module~~m_reallocate~~UsesGraph module~m_reallocate m_reallocate module~m_allocate m_allocate module~m_allocate->module~m_reallocate module~variablekind variableKind module~variablekind->module~m_reallocate module~variablekind->module~m_allocate module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_errors->module~m_reallocate module~m_errors->module~m_allocate module~m_errors->module~m_unittester module~m_unittester->module~m_reallocate module~m_unittester->module~m_allocate iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains routines to re-allocate allocatable arrays Copies the original values after reallocation. If you don't need to copy the values, use 'call allocate()' instead Used By module~~m_reallocate~~UsedByGraph module~m_reallocate m_reallocate module~m_rdynamicarray m_rDynamicArray module~m_reallocate->module~m_rdynamicarray module~m_iddynamicarray m_idDynamicArray module~m_reallocate->module~m_iddynamicarray module~m_ddynamicarray m_dDynamicArray module~m_reallocate->module~m_ddynamicarray module~m_idynamicarray m_iDynamicArray module~m_reallocate->module~m_idynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_rdynamicarray->module~m_rargdynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_iddynamicarray->module~m_idargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_ddynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_kdtree m_KdTree module~m_idynamicarray->module~m_kdtree module~m_iargdynamicarray m_iArgDynamicArray module~m_idynamicarray->module~m_iargdynamicarray module~m_dargdynamicarray->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces reallocate Subroutines reallocate_test Interfaces public interface reallocate Reallocate an allocatable array private subroutine reallocate_r1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_r2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_r3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_d1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_d2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_d3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_i1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_i2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_i3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_id1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_id2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_id3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_c1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_c2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_c3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_z1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_z2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_z3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape private subroutine reallocate_l1D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:) 1D array integer(kind=i32), intent(in) :: n New allocation size private subroutine reallocate_l2D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:) 2D array integer(kind=i32), intent(in) :: n (2) New allocation shape private subroutine reallocate_l3D(this, n) Interfaced with reallocate() Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: this (:,:,:) 3D array integer(kind=i32), intent(in) :: n (3) New allocation shape Subroutines public subroutine reallocate_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_reallocate.html","tags":""},{"title":"m_strings – Fortran Program","text":"Uses: iso_fortran_env variableKind m_allocate m_deallocate m_errors m_parameters m_unitTester module~~m_strings~~UsesGraph module~m_strings m_strings module~m_parameters m_parameters module~m_parameters->module~m_strings module~m_unittester m_unitTester module~m_unittester->module~m_strings module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_deallocate m_deallocate module~m_deallocate->module~m_strings module~m_allocate->module~m_strings module~m_errors m_errors module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors module~variablekind variableKind iso_fortran_env->module~variablekind module~variablekind->module~m_strings module~variablekind->module~m_parameters module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_errors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module provides string handling capabilities\n Replace a substring with another in a string Used By module~~m_strings~~UsedByGraph module~m_strings m_strings module~m_kdtree m_KdTree module~m_strings->module~m_kdtree module~m_idynamicarray m_iDynamicArray module~m_strings->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_strings->module~m_rdynamicarray module~m_random m_random module~m_strings->module~m_random module~m_fileio m_fileIO module~m_strings->module~m_fileio module~m_writeline m_writeline module~m_strings->module~m_writeline module~m_readline m_readline module~m_strings->module~m_readline module~m_debugging m_debugging module~m_strings->module~m_debugging module~m_idargdynamicarray m_idArgDynamicArray module~m_strings->module~m_idargdynamicarray module~stopwatch_class Stopwatch_Class module~m_strings->module~stopwatch_class module~m_iddynamicarray m_idDynamicArray module~m_strings->module~m_iddynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_strings->module~m_rargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_strings->module~m_dargdynamicarray module~m_ddynamicarray m_dDynamicArray module~m_strings->module~m_ddynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_strings->module~m_iargdynamicarray module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_random->module~m_kdtree module~m_sort m_sort module~m_random->module~m_sort module~m_select m_select module~m_random->module~m_select module~m_writeline->module~m_fileio module~m_readline->module~m_fileio module~progressbar_class ProgressBar_Class module~stopwatch_class->module~progressbar_class module~m_iddynamicarray->module~m_idargdynamicarray module~m_dargdynamicarray->module~m_kdtree module~m_ddynamicarray->module~m_dargdynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_sort->module~m_iddynamicarray module~m_sort->module~m_ddynamicarray module~m_sort->module~m_select module~m_maths m_maths module~m_sort->module~m_maths module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_maths->module~m_kdtree var panmodulem_stringsUsedByGraph = svgPanZoom('#modulem_stringsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables printOptions Interfaces str Derived Types c_printOptions Functions hasNentries countEntries lowerCase upperCase isString appendString prependString iachar1D Subroutines read1Integer read1Dble compact readline removeComments replacedelim strings_test Variables Type Visibility Attributes Name Initial type( c_printOptions ), public :: printOptions Interfaces public interface str Interface to print a string representation of a number\n The output format options can be set using the printOptions class private function str_r1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_r1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_d2D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:,:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_i1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_id1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_s1D(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this (:) character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable private function str_1L(this, delim_) result(res) Interfaced with str() Arguments Type Intent Optional Attributes Name logical, intent(in) :: this character(len=*), intent(in), optional :: delim_ Return Value character(len=:),\n  allocatable Derived Types type, public :: c_printOptions Print options similar to numpy's print_options Components Type Visibility Attributes Name Initial integer(kind=i32), public :: precision = 3 Force this precision on the written number integer(kind=i32), public :: threshold = 10 Omit the middle entries if the size is greater than threshold integer(kind=i32), public :: edgeitems = 3 Only write the first and last threshold elements from rows and/or columns character(len=32), public :: nanstr = 'nan' Print NAN as this character(len=32), public :: infstr = 'inf' Print infinity as this Functions public function hasNentries (this, N) result(yes) Check that a string has N entries Arguments Type Intent Optional Attributes Name character(len=*) :: this integer(kind=i32) :: N Return Value logical public function countEntries (this) result(N) Count the number of entries in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Return Value integer(kind=i32) public function lowerCase (str) result(res) Convert a string to lowercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str)) public function upperCase (str) result(res) Convert a string to uppercase Arguments Type Intent Optional Attributes Name character(len=*) :: str Return Value character(len=len_trim(str)) public function isString (tmp1, tmp2, exact_) result(yes) Match two string together Arguments Type Intent Optional Attributes Name character(len=*) :: tmp1 Compare this string character(len=*) :: tmp2 Compare this string logical, optional :: exact_ Optional logical, if true, the strings are not converted to lowercase before comparison Return Value logical public function appendString (this, that, delim) result(res) Append a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to append to character(len=*) :: that String to append character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Appended String public function prependString (this, that, delim) result(res) Prepend a string Arguments Type Intent Optional Attributes Name character(len=*) :: this String to prepend to character(len=*) :: that String to prepend character(len=*), optional :: delim Optional delimiter to separate the append Return Value character(len=:),\n  allocatable Prepended String public function iachar1D (this) result(res) Use iachar on a full string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: this Return Value integer(kind=i32),\n  allocatable, (:) Subroutines public subroutine read1Integer (buf, N, istat) Get a single integer from a line, returns an error code if there is more than one entry Arguments Type Intent Optional Attributes Name character(len=*) :: buf String integer(kind=i32) :: N Single integer integer(kind=i32) :: istat istat > 0 if more than one entry is found public subroutine read1Dble (iunit, this, fname, vName, istat) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: iunit real(kind=r64) :: this character(len=*) :: fname character(len=*) :: vName integer(kind=i32) :: istat public subroutine compact (this) Replace tabs and spaces with a single space\n str must be a variable and not an explicit 'string'. Otherwise adjustl will fail. Arguments Type Intent Optional Attributes Name character(len=*) :: this public subroutine readline (iUnit, line, istat) Reads a line from a file, ignoring any comments Arguments Type Intent Optional Attributes Name integer(kind=i32) :: iUnit File ID number character(len=*) :: line Character string to read the line into integer(kind=i32) :: istat Error Status public elemental subroutine removeComments (this) Removes the text after the ! mark in a string Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: this public subroutine replacedelim (this, dlim, dlimr) Replace a single character length delimiter in a string Arguments Type Intent Optional Attributes Name character(len=*) :: this Replace delimiter in this character(len=*) :: dlim Find this delimiter character(len=*) :: dlimr Replace with this delimiter public subroutine strings_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_strings.html","tags":""},{"title":"m_swap – Fortran Program","text":"Uses: variableKind module~~m_swap~~UsesGraph module~m_swap m_swap module~variablekind variableKind module~variablekind->module~m_swap iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Handles a simple swapping of two elements Used By module~~m_swap~~UsedByGraph module~m_swap m_swap module~m_partition3way m_partition3way module~m_swap->module~m_partition3way module~m_medianof3 m_medianOf3 module~m_swap->module~m_medianof3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces swap Interfaces public interface swap Swap the values of two variables private subroutine swap_i1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this integer(kind=i32), intent(inout) :: that private subroutine swap_id1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this integer(kind=i64), intent(inout) :: that private subroutine swap_r1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this real(kind=r32), intent(inout) :: that private subroutine swap_d1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(inout) :: that private subroutine swap_c1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r32) :: this complex(kind=r32) :: that private subroutine swap_z1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name complex(kind=r64) :: this complex(kind=r64) :: that private subroutine swap_l1(this, that) Interfaced with swap() Arguments Type Intent Optional Attributes Name logical :: this logical :: that","loc":"module/m_swap.html","tags":""},{"title":"m_unitTester – Fortran Program","text":"Uses: iso_fortran_env variableKind m_errors module~~m_unittester~~UsesGraph module~m_unittester m_unitTester module~variablekind variableKind module~variablekind->module~m_unittester module~m_errors m_errors module~variablekind->module~m_errors module~m_errors->module~m_unittester iso_fortran_env iso_fortran_env iso_fortran_env->module~m_unittester iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~m_unittester~~UsedByGraph module~m_unittester m_unitTester module~m_strings m_strings module~m_unittester->module~m_strings module~m_reallocate m_reallocate module~m_unittester->module~m_reallocate module~m_idynamicarray m_iDynamicArray module~m_unittester->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_unittester->module~m_rdynamicarray module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_maths m_maths module~m_unittester->module~m_maths module~m_time m_time module~m_unittester->module~m_time module~m_random m_random module~m_unittester->module~m_random module~m_indexing m_indexing module~m_unittester->module~m_indexing module~m_fileio m_fileIO module~m_unittester->module~m_fileio module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_idargdynamicarray m_idArgDynamicArray module~m_unittester->module~m_idargdynamicarray module~m_select m_select module~m_unittester->module~m_select module~m_iddynamicarray m_idDynamicArray module~m_unittester->module~m_iddynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_unittester->module~m_rargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_unittester->module~m_dargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_unittester->module~m_iargdynamicarray module~m_ddynamicarray m_dDynamicArray module~m_unittester->module~m_ddynamicarray module~m_copy m_copy module~m_unittester->module~m_copy module~m_strings->module~m_idynamicarray module~m_strings->module~m_rdynamicarray module~m_strings->module~m_random module~m_strings->module~m_fileio module~m_strings->module~m_idargdynamicarray module~m_strings->module~m_iddynamicarray module~m_strings->module~m_rargdynamicarray module~m_strings->module~m_dargdynamicarray module~m_strings->module~m_iargdynamicarray module~m_strings->module~m_ddynamicarray module~m_kdtree m_KdTree module~m_strings->module~m_kdtree module~m_writeline m_writeline module~m_strings->module~m_writeline module~m_readline m_readline module~m_strings->module~m_readline module~m_debugging m_debugging module~m_strings->module~m_debugging module~stopwatch_class Stopwatch_Class module~m_strings->module~stopwatch_class module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_rdynamicarray module~m_reallocate->module~m_iddynamicarray module~m_reallocate->module~m_ddynamicarray module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_idynamicarray->module~m_kdtree module~m_rdynamicarray->module~m_rargdynamicarray module~m_array1d->module~m_maths module~m_array1d->module~m_random module~m_array1d->module~m_sort module~m_array1d->module~m_select module~m_array1d->module~m_kdtree module~m_maths->module~m_kdtree module~m_time->module~stopwatch_class module~progressbar_class ProgressBar_Class module~m_time->module~progressbar_class module~m_random->module~m_sort module~m_random->module~m_select module~m_random->module~m_kdtree module~m_allocate->module~m_strings module~m_allocate->module~m_reallocate module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_rdynamicarray module~m_allocate->module~m_array1d module~m_allocate->module~m_maths module~m_allocate->module~m_random module~m_allocate->module~m_sort module~m_allocate->module~m_select module~m_allocate->module~m_iddynamicarray module~m_allocate->module~m_ddynamicarray module~m_allocate->module~m_copy module~m_allocate->module~m_kdtree module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_sort->module~m_maths module~m_sort->module~m_select module~m_sort->module~m_iddynamicarray module~m_sort->module~m_ddynamicarray module~m_select->module~m_maths module~m_select->module~m_kdtree module~m_iddynamicarray->module~m_idargdynamicarray module~m_dargdynamicarray->module~m_kdtree module~m_ddynamicarray->module~m_dargdynamicarray module~m_writeline->module~m_fileio module~m_readline->module~m_fileio module~stopwatch_class->module~progressbar_class var panmodulem_unittesterUsedByGraph = svgPanZoom('#modulem_unittesterUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces tester Derived Types tester Interfaces public interface tester private function init_tester() result(this) Arguments None Return Value type( tester ) Derived Types type, public :: tester Constructor private  function init_tester () Type-Bound Procedures procedure, public :: test => test_tester procedure, public :: summary => summary_tester","loc":"module/m_unittester.html","tags":""},{"title":"variableKind – Fortran Program","text":"Uses: iso_fortran_env iso_fortran_env module~~variablekind~~UsesGraph module~variablekind variableKind iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Defines variable kinds Used By module~~variablekind~~UsedByGraph module~variablekind variableKind module~m_kdtree m_KdTree module~variablekind->module~m_kdtree module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_maths m_maths module~variablekind->module~m_maths module~m_array1d m_array1D module~variablekind->module~m_array1d module~m_time m_time module~variablekind->module~m_time module~progressbar_class ProgressBar_Class module~variablekind->module~progressbar_class module~m_allocate m_allocate module~variablekind->module~m_allocate module~stopwatch_class Stopwatch_Class module~variablekind->module~stopwatch_class module~m_rargdynamicarray m_rArgDynamicArray module~variablekind->module~m_rargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~variablekind->module~m_iargdynamicarray module~m_iddynamicarray m_idDynamicArray module~variablekind->module~m_iddynamicarray module~m_swap m_swap module~variablekind->module~m_swap module~m_idargdynamicarray m_idArgDynamicArray module~variablekind->module~m_idargdynamicarray module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_searching m_searching module~variablekind->module~m_searching module~m_reallocate m_reallocate module~variablekind->module~m_reallocate module~m_fileio m_fileIO module~variablekind->module~m_fileio module~m_readline m_readline module~variablekind->module~m_readline module~m_errors m_errors module~variablekind->module~m_errors module~formatting formatting module~variablekind->module~formatting module~m_select m_select module~variablekind->module~m_select module~m_dargdynamicarray m_dArgDynamicArray module~variablekind->module~m_dargdynamicarray module~m_ddynamicarray m_dDynamicArray module~variablekind->module~m_ddynamicarray module~m_copy m_copy module~variablekind->module~m_copy module~m_partition m_partition module~variablekind->module~m_partition module~m_strings m_strings module~variablekind->module~m_strings module~m_idynamicarray m_iDynamicArray module~variablekind->module~m_idynamicarray module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_rdynamicarray m_rDynamicArray module~variablekind->module~m_rdynamicarray module~m_partition3way m_partition3way module~variablekind->module~m_partition3way module~m_indexing m_indexing module~variablekind->module~m_indexing module~m_writeline m_writeline module~variablekind->module~m_writeline module~m_debugging m_debugging module~variablekind->module~m_debugging module~m_random m_random module~variablekind->module~m_random module~m_sort m_sort module~variablekind->module~m_sort module~m_compare m_compare module~variablekind->module~m_compare module~m_medianof3 m_medianOf3 module~variablekind->module~m_medianof3 module~m_unittester->module~m_maths module~m_unittester->module~m_array1d module~m_unittester->module~m_time module~m_unittester->module~m_allocate module~m_unittester->module~m_rargdynamicarray module~m_unittester->module~m_iargdynamicarray module~m_unittester->module~m_iddynamicarray module~m_unittester->module~m_idargdynamicarray module~m_unittester->module~m_reallocate module~m_unittester->module~m_fileio module~m_unittester->module~m_select module~m_unittester->module~m_dargdynamicarray module~m_unittester->module~m_ddynamicarray module~m_unittester->module~m_copy module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_rdynamicarray module~m_unittester->module~m_indexing module~m_unittester->module~m_random module~m_unittester->module~m_sort module~m_maths->module~m_kdtree module~m_array1d->module~m_kdtree module~m_array1d->module~m_maths module~m_array1d->module~m_select module~m_array1d->module~m_random module~m_array1d->module~m_sort module~m_time->module~progressbar_class module~m_time->module~stopwatch_class module~m_allocate->module~m_kdtree module~m_allocate->module~m_maths module~m_allocate->module~m_array1d module~m_allocate->module~m_iddynamicarray module~m_allocate->module~m_reallocate module~m_allocate->module~m_select module~m_allocate->module~m_ddynamicarray module~m_allocate->module~m_copy module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_rdynamicarray module~m_allocate->module~m_random module~m_allocate->module~m_sort module~stopwatch_class->module~progressbar_class module~m_iddynamicarray->module~m_idargdynamicarray module~m_swap->module~m_partition3way module~m_swap->module~m_medianof3 module~m_parameters->module~m_strings module~m_searching->module~m_rargdynamicarray module~m_searching->module~m_iargdynamicarray module~m_searching->module~m_iddynamicarray module~m_searching->module~m_idargdynamicarray module~m_searching->module~m_dargdynamicarray module~m_searching->module~m_ddynamicarray module~m_searching->module~m_idynamicarray module~m_searching->module~m_rdynamicarray module~m_reallocate->module~m_iddynamicarray module~m_reallocate->module~m_ddynamicarray module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_rdynamicarray module~m_readline->module~m_fileio module~m_errors->module~m_kdtree module~m_errors->module~m_unittester module~m_errors->module~m_maths module~m_errors->module~m_array1d module~m_errors->module~m_time module~m_errors->module~m_allocate module~m_errors->module~m_rargdynamicarray module~m_errors->module~m_iargdynamicarray module~m_errors->module~m_iddynamicarray module~m_errors->module~m_idargdynamicarray module~m_errors->module~m_reallocate module~m_errors->module~m_fileio module~m_errors->module~m_readline module~m_errors->module~m_select module~m_errors->module~m_dargdynamicarray module~m_errors->module~m_ddynamicarray module~m_errors->module~m_copy module~m_errors->module~m_strings module~m_errors->module~m_idynamicarray module~m_errors->module~m_deallocate module~m_errors->module~m_rdynamicarray module~m_errors->module~m_indexing module~m_errors->module~m_writeline module~m_errors->module~m_random module~m_errors->module~m_sort module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_dargdynamicarray->module~m_kdtree module~m_ddynamicarray->module~m_dargdynamicarray module~m_strings->module~m_kdtree module~m_strings->module~stopwatch_class module~m_strings->module~m_rargdynamicarray module~m_strings->module~m_iargdynamicarray module~m_strings->module~m_iddynamicarray module~m_strings->module~m_idargdynamicarray module~m_strings->module~m_fileio module~m_strings->module~m_readline module~m_strings->module~m_dargdynamicarray module~m_strings->module~m_ddynamicarray module~m_strings->module~m_idynamicarray module~m_strings->module~m_rdynamicarray module~m_strings->module~m_writeline module~m_strings->module~m_debugging module~m_strings->module~m_random module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_idynamicarray->module~m_idargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_deallocate->module~m_kdtree module~m_deallocate->module~m_maths module~m_deallocate->module~m_array1d module~m_deallocate->module~m_iddynamicarray module~m_deallocate->module~m_select module~m_deallocate->module~m_ddynamicarray module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_rdynamicarray module~m_deallocate->module~m_random module~m_rdynamicarray->module~m_rargdynamicarray module~m_writeline->module~m_fileio module~m_random->module~m_kdtree module~m_random->module~m_select module~m_random->module~m_sort module~m_sort->module~m_maths module~m_sort->module~m_iddynamicarray module~m_sort->module~m_select module~m_sort->module~m_ddynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_compare->module~m_partition3way var panmodulevariablekindUsedByGraph = svgPanZoom('#modulevariablekindUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables cLen Variables Type Visibility Attributes Name Initial integer(kind=i32), public, parameter :: cLen = 1024 Default character length for temporaries","loc":"module/variablekind.html","tags":""},{"title":"m_writeline – Fortran Program","text":"Uses: iso_fortran_env variableKind m_errors m_strings module~~m_writeline~~UsesGraph module~m_writeline m_writeline module~m_strings m_strings module~m_strings->module~m_writeline module~variablekind variableKind module~variablekind->module~m_writeline module~variablekind->module~m_strings module~m_errors m_errors module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_allocate m_allocate module~variablekind->module~m_allocate module~m_errors->module~m_writeline module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate iso_fortran_env iso_fortran_env iso_fortran_env->module~m_writeline iso_fortran_env->module~m_strings iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester module~m_parameters->module~m_strings module~m_unittester->module~m_strings module~m_unittester->module~m_allocate module~m_deallocate->module~m_strings module~m_allocate->module~m_strings var panmodulem_writelineUsesGraph = svgPanZoom('#modulem_writelineUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains core routines to write different combinations of scalars and 1D arrays to a file Used By module~~m_writeline~~UsedByGraph module~m_writeline m_writeline module~m_fileio m_fileIO module~m_writeline->module~m_fileio Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces writeline Interfaces public interface writeline Write multiple items to a line private subroutine writeLine_a(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_ab(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abc(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcd(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcde(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_av(a, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_avbvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a (:) real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abv(a, b, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abvcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b (:) real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdevfv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e (:) real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdvev(a, b, c, d, e, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d (:) real(kind=r64) :: e (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcv(a, b, c, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcvdv(a, b, c, d, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c (:) real(kind=r64) :: d (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefv(a, b, c, d, e, f, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit private subroutine writeLine_abcdefvgv(a, b, c, d, e, f, g, fname, iunit) Interfaced with writeLine() Arguments Type Intent Optional Attributes Name real(kind=r64) :: a real(kind=r64) :: b real(kind=r64) :: c real(kind=r64) :: d real(kind=r64) :: e real(kind=r64) :: f (:) real(kind=r64) :: g (:) character(len=*), optional :: fname integer(kind=i32), optional :: iunit","loc":"module/m_writeline.html","tags":""},{"title":"m_dArgDynamicArray – Fortran Program","text":"Uses: variableKind iso_fortran_env m_errors m_iDynamicArray m_dDynamicArray m_searching m_strings m_unitTester module~~m_dargdynamicarray~~UsesGraph module~m_dargdynamicarray m_dArgDynamicArray module~m_searching m_searching module~m_searching->module~m_dargdynamicarray module~m_idynamicarray m_iDynamicArray module~m_searching->module~m_idynamicarray module~m_ddynamicarray m_dDynamicArray module~m_searching->module~m_ddynamicarray module~m_strings m_strings module~m_strings->module~m_dargdynamicarray module~m_strings->module~m_idynamicarray module~m_strings->module~m_ddynamicarray module~m_random m_random module~m_strings->module~m_random module~m_unittester m_unitTester module~m_unittester->module~m_dargdynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_ddynamicarray module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_reallocate m_reallocate module~m_unittester->module~m_reallocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_idynamicarray->module~m_dargdynamicarray module~m_errors m_errors module~m_errors->module~m_dargdynamicarray module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_idynamicarray module~m_errors->module~m_ddynamicarray module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_reallocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random iso_fortran_env iso_fortran_env iso_fortran_env->module~m_dargdynamicarray iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors module~variablekind variableKind iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~variablekind->module~m_dargdynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_unittester module~variablekind->module~m_idynamicarray module~variablekind->module~m_errors module~variablekind->module~m_ddynamicarray module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_reallocate module~variablekind->module~m_sort module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_ddynamicarray->module~m_dargdynamicarray module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_ddynamicarray module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_ddynamicarray module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_ddynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_ddynamicarray module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_dargdynamicarrayUsesGraph = svgPanZoom('#modulem_dargdynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues like m_dDynamicArray but with an added\n integer index so that 'lists' of both a key and value can be maintained.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated.\n The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given \n like k nearest neighbours, or k smallest. Example usage program dynamicArray_test use variableKind , only : i32 use m_dArgDynamicArray , only : dArgDynamicArray implicit none type ( dArgDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = dArgDynamicArray ( 10 ) call da % insertAt ( 1 , 10 , 1 0.d0 ) call da % insertAt ( 1 , 20 , 2 0.d0 ) call da % prepend ( 30 , 3 0.d0 ) call da % append ( 40 , 4 0.d0 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % v % values ( 2 ) = 5 0.d0 call da % deallocate () call da2 % deallocate () da = dArgDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 1 , 2 0.d0 ) call da % insertSorted ( 2 , 3 0.d0 ) call da % insertSorted ( 3 , 1 0.d0 ) ia = da % locationOf ( 2 0.d0 ) ia = da % argOf ( 2 0.d0 ) call da % insertSortedUnique ( 4 , 1 0.d0 ) call da % insertSortedUnique ( 4 , 1 5.d0 ) call da % deallocate () da = dArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 1 , 2 0.d0 ) call da % insertSorted ( 2 , 3 0.d0 ) call da % insertSorted ( 3 , 1 0.d0 ) ia = da % locationOf ( 2 0.d0 ) ia = da % argOf ( 2 0.d0 ) call da % insertSortedUnique ( 4 , 1 0.d0 ) call da % insertSortedUnique ( 4 , 1 5.d0 ) call da % deallocate () end program Used By module~~m_dargdynamicarray~~UsedByGraph module~m_dargdynamicarray m_dArgDynamicArray module~m_kdtree m_KdTree module~m_dargdynamicarray->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces dArgDynamicArray Derived Types dArgDynamicArray Subroutines dArgDynamicArray_test Interfaces public interface dArgDynamicArray private function init_dArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[dArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dArgDynamicArray ) private function init_dArgDynamicArray_d1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[dArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) Set of value indices to initialize with. real(kind=r64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dArgDynamicArray ) Derived Types type, public :: dArgDynamicArray Class that act as stacks, queues, and priority queues. See m_dArgDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(dDynamicArray), public :: v Values. Constructor private  function init_dArgDynamicArray_i1 (M, sorted, fixed) Overloaded by interface [[dArgDynamicArray(type)]] private  function init_dArgDynamicArray_d1D (i, values, M, sorted, fixed) Overloaded by interface [[dArgDynamicArray(type)]] Type-Bound Procedures procedure, public :: append => append_dArgDynamicArray dArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: argOf => argOf_dArgDynamicArray dArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure, public :: deallocate => deallocate_dArgDynamicArray dArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_dArgDynamicArray dArgDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_dArgDynamicArray dArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_dArgDynamicArray dArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_dArgDynamicArray dArgDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_dArgDynamicArray dArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure, public :: locationOf => locationOf_dArgDynamicArray dArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_dArgDynamicArray dArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: print => print_dArgDynamicArray dArgDynamicArray%print() - Print to the screen procedure, public :: remove => remove_dArgDynamicArray dArgDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_dArgDynamicArray dArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine dArgDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_dargdynamicarray.html","tags":""},{"title":"m_dDynamicArray – Fortran Program","text":"Uses: variableKind m_allocate m_searching m_deallocate m_errors m_reallocate m_sort m_strings m_unitTester module~~m_ddynamicarray~~UsesGraph module~m_ddynamicarray m_dDynamicArray module~m_searching m_searching module~m_searching->module~m_ddynamicarray module~m_strings m_strings module~m_strings->module~m_ddynamicarray module~m_random m_random module~m_strings->module~m_random module~m_reallocate m_reallocate module~m_reallocate->module~m_ddynamicarray module~m_unittester m_unitTester module~m_unittester->module~m_ddynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_reallocate module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_deallocate m_deallocate module~m_deallocate->module~m_ddynamicarray module~m_deallocate->module~m_strings module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_ddynamicarray module~m_allocate->module~m_strings module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_sort->module~m_ddynamicarray module~m_errors m_errors module~m_errors->module~m_ddynamicarray module~m_errors->module~m_strings module~m_errors->module~m_reallocate module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~variablekind variableKind module~variablekind->module~m_ddynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_reallocate module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_sort module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_ddynamicarrayUsesGraph = svgPanZoom('#modulem_ddynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated.\n The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given \n like k nearest neighbours, or k smallest. program dynamicArray_test use variableKind , only : i32 use m_dDynamicArray , only : dDynamicArray implicit none type ( dDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = dDynamicArray ( 10 ) call da % insertAt ( 1 , 1 0.d0 ) call da % insertAt ( 1 , 2 0.d0 ) call da % prepend ( 3 0.d0 ) call da % append ( 4 0.d0 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % values ( 2 ) = 5 0.d0 call da % deallocate () call da2 % deallocate () da = dDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 2 0.d0 ) call da % insertSorted ( 3 0.d0 ) call da % insertSorted ( 1 0.d0 ) ia = da % locationOf ( 2 0.d0 ) call da % insertSortedUnique ( 1 0.d0 ) call da % insertSortedUnique ( 1 5.d0 ) call da % deallocate () da = dDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 2 0.d0 ) call da % insertSorted ( 3 0.d0 ) call da % insertSorted ( 1 0.d0 ) ia = da % locationOf ( 2 0.d0 ) call da % insertSortedUnique ( 1 0.d0 ) call da % insertSortedUnique ( 1 5.d0 ) call da % deallocate () end program Used By module~~m_ddynamicarray~~UsedByGraph module~m_ddynamicarray m_dDynamicArray module~m_dargdynamicarray m_dArgDynamicArray module~m_ddynamicarray->module~m_dargdynamicarray module~m_kdtree m_KdTree module~m_dargdynamicarray->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces dDynamicArray Derived Types dDynamicArray Subroutines dDynamicArray_test Interfaces public interface dDynamicArray private function init_dDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface dDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dDynamicArray ) Return type. private function init_dDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface dDynamicArray() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( dDynamicArray ) Return type Derived Types type, public :: dDynamicArray Class that act as stacks, queues, and priority queues. See m_dDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array real(kind=r64), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor private  function init_dDynamicArray_i1 (M, sorted, fixed) Overloaded by interface dDynamicArray() private  function init_dDynamicArray_d1D (values, M, sorted, fixed) Overloaded by interface dDynamicArray() Type-Bound Procedures procedure, public :: append => append_dDynamicArray dDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: deallocate => deallocate_dDynamicArray dDynamicArray%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_dDynamicArray dDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_dDynamicArray dDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_dDynamicArray dDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_dDynamicArray dDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_dDynamicArray dDynamicArray%isFilled() - True if the array is filled. procedure, public :: locationOf => locationOf_dDynamicArray dDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_dDynamicArray dDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: reallocate => reallocate_dDynamicArray dDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure, public :: remove => remove_dDynamicArray dDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_dDynamicArray dDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine dDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_ddynamicarray.html","tags":""},{"title":"m_iArgDynamicArray – Fortran Program","text":"Uses: variableKind m_errors m_iDynamicArray m_searching m_strings m_unitTester module~~m_iargdynamicarray~~UsesGraph module~m_iargdynamicarray m_iArgDynamicArray module~m_searching m_searching module~m_searching->module~m_iargdynamicarray module~m_idynamicarray m_iDynamicArray module~m_searching->module~m_idynamicarray module~m_strings m_strings module~m_strings->module~m_iargdynamicarray module~m_strings->module~m_idynamicarray module~m_random m_random module~m_strings->module~m_random module~m_unittester m_unitTester module~m_unittester->module~m_iargdynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_reallocate m_reallocate module~m_unittester->module~m_reallocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_idynamicarray->module~m_iargdynamicarray module~m_errors m_errors module~m_errors->module~m_iargdynamicarray module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_idynamicarray module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_reallocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~variablekind variableKind module~variablekind->module~m_iargdynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_unittester module~variablekind->module~m_idynamicarray module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_reallocate module~variablekind->module~m_sort module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_reallocate->module~m_idynamicarray module~m_sort->module~m_idynamicarray module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_iargdynamicarrayUsesGraph = svgPanZoom('#modulem_iargdynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues like m_iDynamicArray but with an added\n integer index so that 'lists' of both a key and value can be maintained.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated.\n The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given \n like k nearest neighbours, or k smallest. Example usage program dynamicArray_test use variableKind , only : i32 use m_iArgDynamicArray , only : iArgDynamicArray implicit none type ( iArgDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = iArgDynamicArray ( 10 ) call da % insertAt ( 1 , 10 , 10 ) call da % insertAt ( 1 , 20 , 20 ) call da % prepend ( 30 , 30 ) call da % append ( 40 , 40 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % v % values ( 2 ) = 50 call da % deallocate () call da2 % deallocate () da = iArgDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 1 , 20 ) call da % insertSorted ( 2 , 30 ) call da % insertSorted ( 3 , 10 ) ia = da % locationOf ( 20 ) ia = da % argOf ( 20 ) call da % insertSortedUnique ( 4 , 10 ) call da % insertSortedUnique ( 4 , 15 ) call da % deallocate () da = iArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 1 , 20 ) call da % insertSorted ( 2 , 30 ) call da % insertSorted ( 3 , 10 ) ia = da % locationOf ( 20 ) ia = da % argOf ( 20 ) call da % insertSortedUnique ( 4 , 10 ) call da % insertSortedUnique ( 4 , 15 ) call da % deallocate () end program Interfaces iArgDynamicArray Derived Types iArgDynamicArray Subroutines iArgDynamicArray_test Interfaces public interface iArgDynamicArray private function init_iArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[iArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( iArgDynamicArray ) private function init_iArgDynamicArray_i1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[iArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) integer(kind=i32), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( iArgDynamicArray ) Derived Types type, public :: iArgDynamicArray Class that act as stacks, queues, and priority queues. See m_iArgDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(iDynamicArray), public :: v Values. Constructor private  function init_iArgDynamicArray_i1 (M, sorted, fixed) Overloaded by interface [[iArgDynamicArray(type)]] private  function init_iArgDynamicArray_i1D (i, values, M, sorted, fixed) Overloaded by interface [[iArgDynamicArray(type)]] Type-Bound Procedures procedure, public :: append => append_iArgDynamicArray iArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: argOf => argOf_iArgDynamicArray iArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure, public :: deallocate => deallocate_iArgDynamicArray iArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_iArgDynamicArray iArgDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_iArgDynamicArray iArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_iArgDynamicArray iArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_iArgDynamicArray iArgDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_iArgDynamicArray iArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure, public :: locationOf => locationOf_iArgDynamicArray iArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_iArgDynamicArray iArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: remove => remove_iArgDynamicArray iArgDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_iArgDynamicArray iArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine iArgDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_iargdynamicarray.html","tags":""},{"title":"m_idArgDynamicArray – Fortran Program","text":"Uses: variableKind m_errors m_iDynamicArray m_idDynamicArray m_searching m_strings m_unitTester module~~m_idargdynamicarray~~UsesGraph module~m_idargdynamicarray m_idArgDynamicArray module~m_searching m_searching module~m_searching->module~m_idargdynamicarray module~m_idynamicarray m_iDynamicArray module~m_searching->module~m_idynamicarray module~m_iddynamicarray m_idDynamicArray module~m_searching->module~m_iddynamicarray module~m_strings m_strings module~m_strings->module~m_idargdynamicarray module~m_strings->module~m_idynamicarray module~m_strings->module~m_iddynamicarray module~m_random m_random module~m_strings->module~m_random module~m_unittester m_unitTester module~m_unittester->module~m_idargdynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_iddynamicarray module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_reallocate m_reallocate module~m_unittester->module~m_reallocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_idynamicarray->module~m_idargdynamicarray module~m_errors m_errors module~m_errors->module~m_idargdynamicarray module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_idynamicarray module~m_errors->module~m_iddynamicarray module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_reallocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~m_iddynamicarray->module~m_idargdynamicarray module~variablekind variableKind module~variablekind->module~m_idargdynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_unittester module~variablekind->module~m_idynamicarray module~variablekind->module~m_errors module~variablekind->module~m_iddynamicarray module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_reallocate module~variablekind->module~m_sort module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_iddynamicarray module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_iddynamicarray module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_iddynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_iddynamicarray module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_idargdynamicarrayUsesGraph = svgPanZoom('#modulem_idargdynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues like m_idDynamicArray but with an added\n integer index so that 'lists' of both a key and value can be maintained.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated.\n The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given \n like k nearest neighbours, or k smallest. Example usage program dynamicArray_test use variableKind , only : i32 use m_iArgDynamicArray , only : iArgDynamicArray implicit none type ( idArgDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = idArgDynamicArray ( 10 ) call da % insertAt ( 1 , 10 , 10_i64 ) call da % insertAt ( 1 , 20 , 20_i64 ) call da % prepend ( 30 , 30_i64 ) call da % append ( 40 , 40_i64 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % v % values ( 2 ) = 50_i64 call da % deallocate () call da2 % deallocate () da = idArgDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 1 , 20_i64 ) call da % insertSorted ( 2 , 30_i64 ) call da % insertSorted ( 3 , 10_i64 ) ia = da % locationOf ( 20_i64 ) ia = da % argOf ( 20_i64 ) call da % insertSortedUnique ( 4 , 10_i64 ) call da % insertSortedUnique ( 4 , 15_i64 ) call da % deallocate () da = idArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 1 , 20_i64 ) call da % insertSorted ( 2 , 30_i64 ) call da % insertSorted ( 3 , 10_i64 ) ia = da % locationOf ( 20_i64 ) ia = da % argOf ( 20_i64 ) call da % insertSortedUnique ( 4 , 10_i64 ) call da % insertSortedUnique ( 4 , 15_i64 ) call da % deallocate () end program Interfaces idArgDynamicArray Derived Types idArgDynamicArray Subroutines idArgDynamicArray_test Interfaces public interface idArgDynamicArray private function init_idArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[idArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( idArgDynamicArray ) private function init_idArgDynamicArray_id1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[idArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) integer(kind=i64), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( idArgDynamicArray ) Derived Types type, public :: idArgDynamicArray Class that act as stacks, queues, and priority queues. See m_idArgDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(idDynamicArray), public :: v Values. Constructor private  function init_idArgDynamicArray_i1 (M, sorted, fixed) Overloaded by interface [[idArgDynamicArray(type)]] private  function init_idArgDynamicArray_id1D (i, values, M, sorted, fixed) Overloaded by interface [[idArgDynamicArray(type)]] Type-Bound Procedures procedure, public :: append => append_idArgDynamicArray idArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: argOf => argOf_idArgDynamicArray idArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure, public :: deallocate => deallocate_idArgDynamicArray idArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_idArgDynamicArray idArgDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_idArgDynamicArray idArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_idArgDynamicArray idArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_idArgDynamicArray idArgDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_idArgDynamicArray idArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure, public :: locationOf => locationOf_idArgDynamicArray idArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_idArgDynamicArray idArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: remove => remove_idArgDynamicArray idArgDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_idArgDynamicArray idArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine idArgDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_idargdynamicarray.html","tags":""},{"title":"m_idDynamicArray – Fortran Program","text":"Uses: variableKind m_allocate m_searching m_deallocate m_errors m_reallocate m_sort m_strings m_unitTester module~~m_iddynamicarray~~UsesGraph module~m_iddynamicarray m_idDynamicArray module~m_searching m_searching module~m_searching->module~m_iddynamicarray module~m_strings m_strings module~m_strings->module~m_iddynamicarray module~m_random m_random module~m_strings->module~m_random module~m_reallocate m_reallocate module~m_reallocate->module~m_iddynamicarray module~m_unittester m_unitTester module~m_unittester->module~m_iddynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_reallocate module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_deallocate m_deallocate module~m_deallocate->module~m_iddynamicarray module~m_deallocate->module~m_strings module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_iddynamicarray module~m_allocate->module~m_strings module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_sort->module~m_iddynamicarray module~m_errors m_errors module~m_errors->module~m_iddynamicarray module~m_errors->module~m_strings module~m_errors->module~m_reallocate module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~variablekind variableKind module~variablekind->module~m_iddynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_reallocate module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_sort module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_iddynamicarrayUsesGraph = svgPanZoom('#modulem_iddynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. program dynamicArray_test use variableKind , only : i32 use m_dynamicArray , only : idDynamicArray implicit none type ( idDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = idDynamicArray ( 10 ) call da % insertAt ( 1 , 10_i64 ) call da % insertAt ( 1 , 20_i64 ) call da % prepend ( 30_i64 ) call da % append ( 40_i64 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % values ( 2 ) = 50_i64 call da % deallocate () call da2 % deallocate () da = idDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 20_i64 ) call da % insertSorted ( 30_i64 ) call da % insertSorted ( 10_i64 ) ia = da % locationOf ( 20_i64 ) call da % insertSortedUnique ( 10_i64 ) call da % insertSortedUnique ( 15_i64 ) call da % deallocate () da = idDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 20_i64 ) call da % insertSorted ( 30_i64 ) call da % insertSorted ( 10_i64 ) ia = da % locationOf ( 20_i64 ) call da % insertSortedUnique ( 10_i64 ) call da % insertSortedUnique ( 15_i64 ) call da % deallocate () end program Used By module~~m_iddynamicarray~~UsedByGraph module~m_iddynamicarray m_idDynamicArray module~m_idargdynamicarray m_idArgDynamicArray module~m_iddynamicarray->module~m_idargdynamicarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces idDynamicArray Derived Types idDynamicArray Subroutines insertAt__idDynamicArray idDynamicArray_test Interfaces public interface idDynamicArray private function init_idDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface idDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( idDynamicArray ) Return type. private function init_idDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface idDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( idDynamicArray ) Return type Derived Types type, public :: idDynamicArray Class that act as stacks, queues, and priority queues. See m_idDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array integer(kind=i64), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor private  function init_idDynamicArray_i1 (M, sorted, fixed) Overloaded by interface idDynamicArray() private  function init_idDynamicArray_d1D (values, M, sorted, fixed) Overloaded by interface idDynamicArray() Type-Bound Procedures procedure, public :: append => append_idDynamicArray idDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: deallocate => deallocate_idDynamicArray idDynamicArray%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_idDynamicArray idDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_idDynamicArray idDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_idDynamicArray idDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_idDynamicArray idDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_idDynamicArray idDynamicArray%isFilled() - True if the array is filled. procedure, public :: locationOf => locationOf_idDynamicArray idDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_idDynamicArray idDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: reallocate => reallocate_idDynamicArray idDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure, public :: remove => remove_idDynamicArray idDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_idDynamicArray idDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine insertAt__idDynamicArray (this, i, val) Private insert into array without checking for sorted flag. Arguments Type Intent Optional Attributes Name class( idDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. integer(kind=i64) :: val Insert this value. public subroutine idDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_iddynamicarray.html","tags":""},{"title":"m_iDynamicArray – Fortran Program","text":"Uses: variableKind m_allocate m_searching m_deallocate m_errors m_reallocate m_sort m_strings m_unitTester module~~m_idynamicarray~~UsesGraph module~m_idynamicarray m_iDynamicArray module~m_searching m_searching module~m_searching->module~m_idynamicarray module~m_strings m_strings module~m_strings->module~m_idynamicarray module~m_random m_random module~m_strings->module~m_random module~m_reallocate m_reallocate module~m_reallocate->module~m_idynamicarray module~m_unittester m_unitTester module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_reallocate module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_deallocate m_deallocate module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_strings module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_strings module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_sort->module~m_idynamicarray module~m_errors m_errors module~m_errors->module~m_idynamicarray module~m_errors->module~m_strings module~m_errors->module~m_reallocate module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~variablekind variableKind module~variablekind->module~m_idynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_reallocate module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_sort module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_idynamicarrayUsesGraph = svgPanZoom('#modulem_idynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. program dynamicArray_test use variableKind , only : i32 use m_iDynamicArray , only : iDynamicArray implicit none type ( iDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = iDynamicArray ( 10 ) call da % insertAt ( 1 , 10 ) call da % insertAt ( 1 , 20 ) call da % prepend ( 30 ) call da % append ( 40 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % values ( 2 ) = 50 call da % deallocate () call da2 % deallocate () da = iDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 20 ) call da % insertSorted ( 30 ) call da % insertSorted ( 10 ) ia = da % locationOf ( 20 ) call da % insertSortedUnique ( 10 ) call da % insertSortedUnique ( 15 ) call da % deallocate () da = iDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 20 ) call da % insertSorted ( 30 ) call da % insertSorted ( 10 ) ia = da % locationOf ( 20 ) call da % insertSortedUnique ( 10 ) call da % insertSortedUnique ( 15 ) call da % deallocate () end program Used By module~~m_idynamicarray~~UsedByGraph module~m_idynamicarray m_iDynamicArray module~m_dargdynamicarray m_dArgDynamicArray module~m_idynamicarray->module~m_dargdynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_idynamicarray->module~m_idargdynamicarray module~m_kdtree m_KdTree module~m_idynamicarray->module~m_kdtree module~m_iargdynamicarray m_iArgDynamicArray module~m_idynamicarray->module~m_iargdynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_idynamicarray->module~m_rargdynamicarray module~m_dargdynamicarray->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces iDynamicArray Derived Types iDynamicArray Subroutines insertAt__iDynamicArray iDynamicArray_test Interfaces public interface iDynamicArray private function init_iDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface iDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( iDynamicArray ) Return type. private function init_iDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface iDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( iDynamicArray ) Return type Derived Types type, public :: iDynamicArray Class that act as stacks, queues, and priority queues. See m_iDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array integer(kind=i32), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor private  function init_iDynamicArray_i1 (M, sorted, fixed) Overloaded by interface iDynamicArray() private  function init_iDynamicArray_d1D (values, M, sorted, fixed) Overloaded by interface iDynamicArray() Type-Bound Procedures procedure, public :: append => append_iDynamicArray iDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: deallocate => deallocate_iDynamicArray iDynamicArray%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_iDynamicArray iDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_iDynamicArray iDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_iDynamicArray iDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_iDynamicArray iDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_iDynamicArray iDynamicArray%isFilled() - True if the array is filled. procedure, public :: locationOf => locationOf_iDynamicArray iDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_iDynamicArray iDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: reallocate => reallocate_iDynamicArray iDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure, public :: remove => remove_iDynamicArray iDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_iDynamicArray iDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine insertAt__iDynamicArray (this, i, val) Private insert into array without checking for sorted flag. Arguments Type Intent Optional Attributes Name class( iDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. integer(kind=i32) :: val Insert this value. public subroutine iDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_idynamicarray.html","tags":""},{"title":"m_rArgDynamicArray – Fortran Program","text":"Uses: variableKind m_errors m_iDynamicArray m_rDynamicArray m_searching m_strings m_unitTester module~~m_rargdynamicarray~~UsesGraph module~m_rargdynamicarray m_rArgDynamicArray module~m_searching m_searching module~m_searching->module~m_rargdynamicarray module~m_idynamicarray m_iDynamicArray module~m_searching->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_searching->module~m_rdynamicarray module~m_strings m_strings module~m_strings->module~m_rargdynamicarray module~m_strings->module~m_idynamicarray module~m_strings->module~m_rdynamicarray module~m_random m_random module~m_strings->module~m_random module~m_unittester m_unitTester module~m_unittester->module~m_rargdynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_rdynamicarray module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_reallocate m_reallocate module~m_unittester->module~m_reallocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_idynamicarray->module~m_rargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_errors m_errors module~m_errors->module~m_rargdynamicarray module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_idynamicarray module~m_errors->module~m_rdynamicarray module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_reallocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~variablekind variableKind module~variablekind->module~m_rargdynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_unittester module~variablekind->module~m_idynamicarray module~variablekind->module~m_rdynamicarray module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_reallocate module~variablekind->module~m_sort module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_deallocate->module~m_rdynamicarray module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_rdynamicarray module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_rdynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_rdynamicarray module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_rargdynamicarrayUsesGraph = svgPanZoom('#modulem_rargdynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues like m_rDynamicArray but with an added\n integer index so that 'lists' of both a key and value can be maintained.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated.\n The array can be specified as fixed, so that no reallocation occurs.  This is useful for heaps of given \n like k nearest neighbours, or k smallest. Example usage program dynamicArray_test use variableKind , only : i32 use m_iArgDynamicArray , only : iArgDynamicArray implicit none type ( rArgDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = rArgDynamicArray ( 10 ) call da % insertAt ( 1 , 10 , 1 0.0 ) call da % insertAt ( 1 , 20 , 2 0.0 ) call da % prepend ( 30 , 3 0.0 ) call da % append ( 40 , 4 0.0 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % v % values ( 2 ) = 5 0.0 call da % deallocate () call da2 % deallocate () da = rArgDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 1 , 2 0.0 ) call da % insertSorted ( 2 , 3 0.0 ) call da % insertSorted ( 3 , 1 0.0 ) ia = da % locationOf ( 2 0.0 ) ia = da % argOf ( 2 0.0 ) call da % insertSortedUnique ( 4 , 1 0.0 ) call da % insertSortedUnique ( 4 , 1 5.0 ) call da % deallocate () da = rArgDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 1 , 2 0.0 ) call da % insertSorted ( 2 , 3 0.0 ) call da % insertSorted ( 3 , 1 0.0 ) ia = da % locationOf ( 2 0.0 ) ia = da % argOf ( 2 0.0 ) call da % insertSortedUnique ( 4 , 1 0.0 ) call da % insertSortedUnique ( 4 , 1 5.0 ) call da % deallocate () end program Interfaces rArgDynamicArray Derived Types rArgDynamicArray Subroutines rArgDynamicArray_test Interfaces public interface rArgDynamicArray private function init_rArgDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface [[rArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( rArgDynamicArray ) private function init_rArgDynamicArray_r1D(i, values, M, sorted, fixed) result(this) Overloaded by interface [[rArgDynamicArray(type)]] Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i (:) real(kind=r32), intent(in) :: values (:) integer(kind=i32), intent(in), optional :: M logical, intent(in), optional :: sorted logical, intent(in), optional :: fixed Return Value type( rArgDynamicArray ) Derived Types type, public :: rArgDynamicArray Class that act as stacks, queues, and priority queues. See m_rArgDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial type(iDynamicArray), public :: i Argument of the values. type(rDynamicArray), public :: v Values. Constructor private  function init_rArgDynamicArray_i1 (M, sorted, fixed) Overloaded by interface [[rArgDynamicArray(type)]] private  function init_rArgDynamicArray_r1D (i, values, M, sorted, fixed) Overloaded by interface [[rArgDynamicArray(type)]] Type-Bound Procedures procedure, public :: append => append_rArgDynamicArray rArgDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: argOf => argOf_rArgDynamicArray rArgDynamicArray%argOf() - Get the argument of a value in a sorted dynamic array procedure, public :: deallocate => deallocate_rArgDynamicArray rArgDynamicArray%%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_rArgDynamicArray rArgDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_rArgDynamicArray rArgDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_rArgDynamicArray rArgDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_rArgDynamicArray rArgDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_rArgDynamicArray rArgDynamicArray%isFilled() - True if the allocated memory has been filled. procedure, public :: locationOf => locationOf_rArgDynamicArray rArgDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_rArgDynamicArray rArgDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: remove => remove_rArgDynamicArray rArgDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_rArgDynamicArray rArgDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine rArgDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_rargdynamicarray.html","tags":""},{"title":"m_rDynamicArray – Fortran Program","text":"Uses: variableKind m_allocate m_searching m_deallocate m_errors m_reallocate m_sort m_strings m_unitTester module~~m_rdynamicarray~~UsesGraph module~m_rdynamicarray m_rDynamicArray module~m_searching m_searching module~m_searching->module~m_rdynamicarray module~m_strings m_strings module~m_strings->module~m_rdynamicarray module~m_random m_random module~m_strings->module~m_random module~m_reallocate m_reallocate module~m_reallocate->module~m_rdynamicarray module~m_unittester m_unitTester module~m_unittester->module~m_rdynamicarray module~m_unittester->module~m_strings module~m_unittester->module~m_reallocate module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_unittester->module~m_random module~m_deallocate m_deallocate module~m_deallocate->module~m_rdynamicarray module~m_deallocate->module~m_strings module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_allocate->module~m_rdynamicarray module~m_allocate->module~m_strings module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_sort->module~m_rdynamicarray module~m_errors m_errors module~m_errors->module~m_rdynamicarray module~m_errors->module~m_strings module~m_errors->module~m_reallocate module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_errors->module~m_sort module~m_errors->module~m_array1d module~m_errors->module~m_random module~variablekind variableKind module~variablekind->module~m_rdynamicarray module~variablekind->module~m_searching module~variablekind->module~m_strings module~variablekind->module~m_reallocate module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_allocate module~variablekind->module~m_sort module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_array1d module~variablekind->module~m_random module~m_parameters->module~m_strings iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort var panmodulem_rdynamicarrayUsesGraph = svgPanZoom('#modulem_rdynamicarrayUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Class that act as stacks, queues, and priority queues.\n These classes use dynamically allocated contiguous blocks of memory to store a list of numbers.\n The queues can be sorted to become priority queues and use binary searches to quickly insert new numbers.\n If the allocated memory is filled, the available space is doubled.\n Memory is only reallocated to a smaller size, if the utilization is a quarter of that allocated. program dynamicArray_test use variableKind , only : i32 use m_rDynamicArray , only : rDynamicArray implicit none type ( rDynamicArray ) :: da , da2 integer ( i32 ) :: ia da = rDynamicArray ( 10 ) call da % insertAt ( 1 , 1 0.0 ) call da % insertAt ( 1 , 2 0.0 ) call da % prepend ( 3 0.0 ) call da % append ( 4 0.0 ) call da % remove ( 2 ) call da % tighten () da2 = da da2 % values ( 2 ) = 5 0.0 call da % deallocate () call da2 % deallocate () da = rDynamicArray ( 3 , sorted = . true .) call da % insertSorted ( 2 0.0 ) call da % insertSorted ( 3 0.0 ) call da % insertSorted ( 1 0.0 ) ia = da % locationOf ( 2 0.0 ) call da % insertSortedUnique ( 1 0.0 ) call da % insertSortedUnique ( 1 5.0 ) call da % deallocate () da = rDynamicArray ( 3 , sorted = . true ., fixed = . true .) call da % insertSorted ( 2 0.0 ) call da % insertSorted ( 3 0.0 ) call da % insertSorted ( 1 0.0 ) ia = da % locationOf ( 2 0.0 ) call da % insertSortedUnique ( 1 0.0 ) call da % insertSortedUnique ( 1 5.0 ) call da % deallocate () end program Used By module~~m_rdynamicarray~~UsedByGraph module~m_rdynamicarray m_rDynamicArray module~m_rargdynamicarray m_rArgDynamicArray module~m_rdynamicarray->module~m_rargdynamicarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces rDynamicArray Derived Types rDynamicArray Subroutines insertAt__rDynamicArray rDynamicArray_test Interfaces public interface rDynamicArray private function init_rDynamicArray_i1(M, sorted, fixed) result(this) Overloaded by interface rDynamicArray() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( rDynamicArray ) Return type. private function init_rDynamicArray_d1D(values, M, sorted, fixed) result(this) Overloaded by interface rDynamicArray() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: values (:) Set of values to initialize with. integer(kind=i32), intent(in), optional :: M Amount of memory to allocate. logical, intent(in), optional :: sorted Maintain a sorted array. logical, intent(in), optional :: fixed Maintain a fixed size array. Return Value type( rDynamicArray ) Return type Derived Types type, public :: rDynamicArray Class that act as stacks, queues, and priority queues. See m_rDynamicArray for more information on how to use this class. Components Type Visibility Attributes Name Initial integer(kind=i32), public :: N Current size of the array real(kind=r32), public, allocatable :: values (:) Memory for values, can be larger than N logical, public :: sorted = .false. Keep track of whether the array is sorted for potential speed increases logical, public :: fixed = .false. Don't allow the memory to change after initial instantiation. Constructor private  function init_rDynamicArray_i1 (M, sorted, fixed) Overloaded by interface rDynamicArray() private  function init_rDynamicArray_d1D (values, M, sorted, fixed) Overloaded by interface rDynamicArray() Type-Bound Procedures procedure, public :: append => append_rDynamicArray rDynamicArray%append() - Append a value to the end of the dynamic array.  Will change a sorted dynamic array to unsorted. procedure, public :: deallocate => deallocate_rDynamicArray rDynamicArray%deallocate() - Deallocate a dynamic array. procedure, public :: insertAt => insertAt_rDynamicArray rDynamicArray%insertAt() - Insert a value at a given index. procedure, public :: insertSorted => insertSorted_rDynamicArray rDynamicArray%insertSorted() - Insert a value into a sorted dynamic array. procedure, public :: insertSortedUnique => insertSortedUnique_rDynamicArray rDynamicArray%insertSortedUnique() - Inserts only unique numbers into a dynamic array. procedure, public :: isEmpty => isEmpty_rDynamicArray rDynamicArray%isEmpty() - True if the array is empty. procedure, public :: isFilled => isFilled_rDynamicArray rDynamicArray%isFilled() - True if the array is filled. procedure, public :: locationOf => locationOf_rDynamicArray rDynamicArray%locationOf() - Get the location of a value in a sorted dynamic array. procedure, public :: prepend => prepend_rDynamicArray rDynamicArray%prepend() - Prepend a value to the start of the dynamic array. Only for unsorted dynamic arrays procedure, public :: reallocate => reallocate_rDynamicArray rDynamicArray%reallocate() - Create new contiguous memory to match the needs of the expanding or shrinking array. procedure, public :: remove => remove_rDynamicArray rDynamicArray%remove() - Remove an element from the array. procedure, public :: tighten => tighten_rDynamicArray rDynamicArray%tighten() - Removes excess buffer memory and trims it to the current length. Subroutines public subroutine insertAt__rDynamicArray (this, i, val) Private insert into array without checking for sorted flag. Arguments Type Intent Optional Attributes Name class( rDynamicArray ) :: this integer(kind=i32) :: i Insert value at this location. real(kind=r32) :: val Insert this value. public subroutine rDynamicArray_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_rdynamicarray.html","tags":""},{"title":"m_maths – Fortran Program","text":"Uses: variableKind m_allocate m_deallocate m_errors m_sort m_select m_array1D m_unitTester module~~m_maths~~UsesGraph module~m_maths m_maths module~m_unittester m_unitTester module~m_unittester->module~m_maths module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_select m_select module~m_unittester->module~m_select module~m_random m_random module~m_unittester->module~m_random module~m_strings m_strings module~m_unittester->module~m_strings module~m_deallocate m_deallocate module~m_deallocate->module~m_maths module~m_deallocate->module~m_array1d module~m_deallocate->module~m_select module~m_deallocate->module~m_random module~m_deallocate->module~m_strings module~m_array1d->module~m_maths module~m_array1d->module~m_sort module~m_array1d->module~m_select module~m_array1d->module~m_random module~m_allocate->module~m_maths module~m_allocate->module~m_array1d module~m_allocate->module~m_sort module~m_allocate->module~m_select module~m_allocate->module~m_random module~m_allocate->module~m_strings module~m_sort->module~m_maths module~m_sort->module~m_select module~m_errors m_errors module~m_errors->module~m_maths module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_array1d module~m_errors->module~m_allocate module~m_errors->module~m_sort module~m_errors->module~m_select module~m_errors->module~m_random module~m_errors->module~m_strings module~m_select->module~m_maths module~variablekind variableKind module~variablekind->module~m_maths module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_array1d module~variablekind->module~m_allocate module~variablekind->module~m_sort module~variablekind->module~m_errors module~variablekind->module~m_select module~variablekind->module~m_random module~variablekind->module~m_strings module~m_parameters m_parameters module~variablekind->module~m_parameters iso_fortran_env iso_fortran_env iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_random iso_fortran_env->module~m_strings module~m_random->module~m_sort module~m_random->module~m_select module~m_strings->module~m_random module~m_parameters->module~m_strings var panmodulem_mathsUsesGraph = svgPanZoom('#modulem_mathsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Math routines Used By module~~m_maths~~UsedByGraph module~m_maths m_maths module~m_kdtree m_KdTree module~m_maths->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces crossproduct cumprod cumsum fastTwoDiff fastTwoSum geometricMean mean median norm1 normI project trimmedmean twoDiff twoSum std variance Subroutines maths_test Interfaces public interface crossproduct Compute the cross product between two arrays of length 2 or 3 public function crossproduct_r1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (3) 1D Array real(kind=r32), intent(in) :: b (3) 1D Array Return Value real(kind=r32)\n  (3) cross product public function crossproduct_d1D(a, b) result(res) Interfaced with crossproduct() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (3) 1D Array real(kind=r64), intent(in) :: b (3) 1D Array Return Value real(kind=r64)\n  (3) cross product public interface cumprod Compute the variance of an array public function cumprod_r1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative product public function cumprod_d1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative product public function cumprod_i1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative product public function cumprod_id1D(this) result(res) Interfaced with cumprod() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative product public interface cumsum Compute the variance of an array public function cumsum_r1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32)\n  (size(this)) Cumulative sum public function cumsum_d1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64)\n  (size(this)) Cumulative sum public function cumsum_i1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32)\n  (size(this)) Cumulative sum public function cumsum_id1D(this) result(res) Interfaced with cumsum() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64)\n  (size(this)) Cumulative sum public interface fastTwoDiff Compute the difference two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoDiff routine public function fastTwoDiff_r(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoDiff_d(a, b) result(res) Interfaced with fastTwoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error public interface fastTwoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n This should only be used if you know that the magnitude of a is greater than or equal to b, otherwise, you should use the slower twoSum routine public function fastTwoSum_r(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function fastTwoSum_d(a, b) result(res) Interfaced with fastTwoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error public interface geometricMean Compute the geometric mean of a vector public function geometricMean_r1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_d1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_i1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) Return Value real(kind=r64) public function geometricMean_id1D(this) result(res) Interfaced with geometricMean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) Return Value real(kind=r64) public interface mean Compute the mean public function mean_r1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_d1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_i1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public function mean_id1D(this) result(res) Interfaced with mean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) mean public interface median Compute the median of a set of numbers public function median_r1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) median public function median_d1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_i1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public function median_id1D(this) result(res) Interfaced with median() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) median public interface norm1 Compute the L1 norm of a set of numbers public function norm1_r1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) L1 norm public function norm1_d1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_i1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public function norm1_id1D(this) result(res) Interfaced with norm1() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) L1 norm public interface normI Compute the Linfinity norm of a set of numbers public function normI_r1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r32) Linfinity norm public function normI_d1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) Linfinity norm public function normI_i1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value integer(kind=i32) Linfinity norm public function normI_id1D(this) result(res) Interfaced with normI() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value integer(kind=i64) Linfinity norm public interface project Project a vector a onto vector b public function project_r1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a (:) 1D array real(kind=r32), intent(in) :: b (size(a)) 1D array Return Value real(kind=r32)\n  (size(a)) 1D array public function project_d1D(a, b) result(c) Interfaced with project() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a (:) 1D array real(kind=r64), intent(in) :: b (size(a)) 1D array Return Value real(kind=r64)\n  (size(a)) 1D array public interface trimmedmean Compute the Trimmed mean of an array,  alpha is a percent value to trim from either end public function trimmedmean_r1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array real(kind=r32), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_d1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_i1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public function trimmedmean_id1D(this, alpha) result(res) Interfaced with trimmedmean() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array real(kind=r64), intent(in) :: alpha Percentage to trim off each end Return Value real(kind=r64) trimmedmean public interface twoDiff Compute the difference between two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoDiff public function twoDiff_r(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number real(kind=r32), intent(in) :: b Second number Return Value real(kind=r32)\n  (2) Result and its error public function twoDiff_d(a, b) result(res) Interfaced with twoDiff() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number real(kind=r64), intent(in) :: b Second number Return Value real(kind=r64)\n  (2) Result and its error public interface twoSum Compute the sum of two numbers and compute the numerical round-off error. See Shewchuk 1997 Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\n If you know that the magnitude of a is greater than or equal to b, use fastTwoSum public function twoSum_r(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: a First number in sum real(kind=r32), intent(in) :: b Second number in sum Return Value real(kind=r32)\n  (2) The sum and its error public function twoSum_d(a, b) result(res) Interfaced with twoSum() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: a First number in sum real(kind=r64), intent(in) :: b Second number in sum Return Value real(kind=r64)\n  (2) The sum and its error public interface std Compute the standard deviation of an array public function std_r1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_d1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_i1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public function std_id1D(this) result(res) Interfaced with std() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) standard deviation public interface variance Compute the variance of an array public function variance_r1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_d1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_i1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance public function variance_id1D(this) result(res) Interfaced with variance() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array Return Value real(kind=r64) variance Subroutines public subroutine maths_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_maths.html","tags":""},{"title":"m_random – Fortran Program","text":"Uses: variableKind m_allocate m_deallocate m_errors m_strings iso_fortran_env m_array1D m_unitTester module~~m_random~~UsesGraph module~m_random m_random module~m_strings m_strings module~m_strings->module~m_random module~m_unittester m_unitTester module~m_unittester->module~m_random module~m_unittester->module~m_strings module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_deallocate m_deallocate module~m_deallocate->module~m_random module~m_deallocate->module~m_strings module~m_deallocate->module~m_array1d module~m_array1d->module~m_random module~m_allocate->module~m_random module~m_allocate->module~m_strings module~m_allocate->module~m_array1d module~m_errors m_errors module~m_errors->module~m_random module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_array1d module~m_errors->module~m_allocate iso_fortran_env iso_fortran_env iso_fortran_env->module~m_random iso_fortran_env->module~m_strings iso_fortran_env->module~m_unittester iso_fortran_env->module~m_errors module~variablekind variableKind iso_fortran_env->module~variablekind module~variablekind->module~m_random module~variablekind->module~m_strings module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_array1d module~variablekind->module~m_allocate module~variablekind->module~m_errors module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_parameters->module~m_strings var panmodulem_randomUsesGraph = svgPanZoom('#modulem_randomUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Routines for random number generation.  The original code is provided via Netlib at http://www.netlib.org/random/random.f90 Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM VARIATE IN [0,1]\n FROM A BETA DISTRIBUTION WITH DENSITY\n PROPORTIONAL TO BETA (AA-1) * (1-BETA) (BB-1).\n USING CHENG'S LOG LOGISTIC METHOD. AA = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL)\n BB = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL)\n\n\n\n\n\n Local variables Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM VARIATE FROM A\n T DISTRIBUTION USING KINDERMAN AND MONAHAN'S RATIO METHOD. M = DEGREES OF FREEDOM OF DISTRIBUTION\n       (1 <= 1NTEGER)\n\n\n\n\n Local variables Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 N.B. An extra argument, ier, has been added to Dagpunar's routine SUBROUTINE GENERATES AN N VARIATE RANDOM NORMAL\n VECTOR USING A CHOLESKY DECOMPOSITION. ARGUMENTS:\n        N = NUMBER OF VARIATES IN VECTOR\n           (INPUT,INTEGER >= 1)\n     H(J) = J'TH ELEMENT OF VECTOR OF MEANS\n           (INPUT,REAL)\n     X(J) = J'TH ELEMENT OF DELIVERED VECTOR\n           (OUTPUT,REAL) D(J*(J-1)/2+I) = (I,J)'TH ELEMENT OF VARIANCE MATRIX (J> = I)\n        (INPUT,REAL)\nF((J-1)*(2*N-J)/2+I) = (I,J)'TH ELEMENT OF LOWER TRIANGULAR\n       DECOMPOSITION OF VARIANCE MATRIX (J <= I)\n        (OUTPUT,REAL)\n\nFIRST = .TRUE. IF THIS IS THE FIRST CALL OF THE ROUTINE\nOR IF THE DISTRIBUTION HAS CHANGED SINCE THE LAST CALL OF THE ROUTINE.\nOTHERWISE SET TO .FALSE.\n        (INPUT,LOGICAL)\n\nier = 1 if the input covariance matrix is not +ve definite\n    = 0 otherwise\n\n\n\n\n\n\n\n\n Local variables Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY] FROM\n A REPARAMETERISED GENERALISED INVERSE GAUSSIAN (GIG) DISTRIBUTION\n WITH DENSITY PROPORTIONAL TO  GIG (H-1) * EXP(-0.5 B (GIG+1/GIG))\n USING A RATIO METHOD. H = PARAMETER OF DISTRIBUTION (0 <= REAL)\n B = PARAMETER OF DISTRIBUTION (0 < REAL)\n\n\n\n\n\n Local variables Translated to Fortran 90 by Alan Miller from:\n                       RANLIB\n\n Library of Fortran Routines for Random Number Generation\n\n                Compiled and Written by:\n\n                     Barry W. Brown\n                      James Lovato\n\n         Department of Biomathematics, Box 237\n         The University of Texas, M.D. Anderson Cancer Center\n         1515 Holcombe Boulevard\n         Houston, TX      77030 This work was supported by grant CA-16672 from the National Cancer Institute. GENerate POIsson random deviate\n\n                        Function Generates a single random deviate from a Poisson distribution with mean mu. Arguments\n\n mu --> The mean of the Poisson distribution from which\n        a random deviate is to be generated.\n                          REAL mu\n\n                          Method\n\n For details see:\n\n           Ahrens, J.H. and Dieter, U.\n           Computer Generation of Poisson Deviates\n           From Modified Normal Distributions.\n           ACM Trans. Math. Software, 8, 2\n           (June 1982),163-179\n\n TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT\n COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL\n\n SEPARATION OF CASES A AND B\n\n .. Scalar Arguments ..\n\n\n\n ..\n .. Local Scalars ..\n\n\n\n\n\n\n ..\n .. Local Arrays ..\n\n ..\n .. Data statements ..\n\n\n\n\n\n\n\n ..\n .. Executable Statements ..\n\n C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED)\n\n\n\n\n\n         THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL\n         PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484)\n         IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 .\n\n\n\n\n\n\n STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE\n\n\n\n\n\n STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH\n\n\n\n STEP S. SQUEEZE ACCEPTANCE - SAMPLE U\n\n\n\n\n\n\n\n STEP P. PREPARATIONS FOR STEPS Q AND H.\n         (RECALCULATIONS OF PARAMETERS IF NECESSARY)\n         .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7.\n         THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE\n         APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK.\n         C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN)\n\n\n\n\n STEP Q. QUOTIENT ACCEPTANCE (RARE CASE)\n\n\n\n STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL\n         DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT'\n         (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.)\n\n\n\n\n\n\n\n\n\n\n         'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN)\n\n\n\n\n STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION)\n\n\n\n\n STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY.\n         CASE ival < 10 USES FACTORIALS FROM TABLE FACT\n\n\n\n\n\n\n         CASE ival >= 10 USES POLYNOMIAL APPROXIMATION\n         A0-A7 FOR ACCURACY WHEN ADVISABLE\n         .8333333E-1=1./12.  .3989423=(2*PI)**(-.5) C A S E  B.    mu < 10\n START NEW TABLE AND CALCULATE P0 IF NECESSARY\n\n\n\n\n\n\n\n\n\n\n STEP U. UNIFORM SAMPLE FOR INVERSION METHOD\n\n\n\n\n\n\n STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE\n         PP-TABLE OF CUMULATIVE POISSON PROBABILITIES\n         (0.458=PP(9) FOR MU=10)\n\n\n\n\n\n\n\n\n\n STEP C. CREATION OF NEW POISSON PROBABILITIES P\n         AND THEIR CUMULATIVES Q=PP(K) FUNCTION GENERATES A RANDOM BINOMIAL VARIATE USING C.D.Kemp's method.\n This algorithm is suitable when many random variates are required\n with the SAME parameter values for n & p. P = BERNOULLI SUCCESS PROBABILITY\n       (0 <= REAL <= 1)\nN = NUMBER OF BERNOULLI TRIALS\n       (1 <= INTEGER)\nFIRST = .TRUE. for the first call using the current parameter values\n      = .FALSE. if the values of (n,p) are unchanged from last call Reference: Kemp, C.D. (1986). `A modal method for generating binomial\n            variables', Commun. Statist. - Theor. Meth. 15(3), 805-813. Local variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n This point should not be reached, but just in case:\n\n\n\n\n\n\n\n\n\n Calculate a binomial probability\n\n\n\n\n\n Local variable Logarithm to base e of the gamma function. Accurate to about 1.e-14.\n Programmer: Alan Miller Latest revision of Fortran 77 version - 28 February 1988 Local variables\n\n\n\n\n\n\n\n   lngamma is not defined if x = 0 or a negative integer.\n\n\n\n\n\n\n   If x < 0, use the reflection formula:\n           gamma(x) * gamma(1-x) = pi * cosec(pi.x)\n\n\n\n\n\n\n\n\n   Increase the argument, if necessary, to make it > 10. Use a polynomial approximation to Stirling's formula.\n  N.B. The real Stirling's formula is used here, not the simpler, but less\n       accurate formula given by De Moivre in a letter to Stirling, which\n       is the one usually quoted. Translated to Fortran 90 by Alan Miller from:\n                          RANLIB\n\n Library of Fortran Routines for Random Number Generation\n\n                  Compiled and Written by:\n\n                       Barry W. Brown\n                        James Lovato\n\n           Department of Biomathematics, Box 237\n           The University of Texas, M.D. Anderson Cancer Center\n           1515 Holcombe Boulevard\n           Houston, TX      77030 This work was supported by grant CA-16672 from the National Cancer Institute. GENerate BINomial random deviate\n\n                          Function\n\n Generates a single random deviate from a binomial\n distribution whose number of trials is N and whose\n probability of an event in each trial is P.\n\n                          Arguments\n\n N  --> The number of trials in the binomial distribution\n        from which a random deviate is to be generated.\n                          INTEGER N\n\n P  --> The probability of an event in each trial of the\n        binomial distribution from which a random deviate\n        is to be generated.\n                          REAL P\n\n FIRST --> Set FIRST = .TRUE. for the first call to perform initialization\n           the set FIRST = .FALSE. for further calls using the same pair\n           of parameter values (N, P).\n                          LOGICAL FIRST\n\n random_binomial2 <-- A random deviate yielding the number of events\n            from N independent trials, each of which has\n            a probability of event P.\n                          INTEGER random_binomial\n\n                          Method\n\n This is algorithm BTPE from:\n\n     Kachitvichyanukul, V. and Schmeiser, B. W.\n     Binomial Random Variate Generation.\n     Communications of the ACM, 31, 2 (February, 1988) 216. * DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY ..\n .. Scalar Arguments ..\n\n\n\n\n ..\n .. Local Scalars ..\n\n\n\n\n\n\n\n ..\n .. Executable Statements .. * SETUP, PERFORM ONLY WHEN PARAMETERS CHANGE * GENERATE VARIATE, Binomial mean at least 30. TRIANGULAR REGION\n\n\n\n\n\n\n PARALLELOGRAM REGION\n\n\n\n\n\n\n\n\n LEFT TAIL\n\n\n\n\n\n\n\n RIGHT TAIL * DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST EXPLICIT EVALUATION\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n SQUEEZING USING UPPER AND LOWER BOUNDS ON LOG(F(X))\n\n\n\n\n\n\n\n STIRLING'S (actually de Moivre's) FORMULA TO MACHINE ACCURACY FOR\n THE FINAL ACCEPTANCE/REJECTION TEST\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n INVERSE CDF LOGIC FOR MEAN LESS THAN 30 Adapted from Fortran 77 code from the book:\n     Dagpunar, J. 'Principles of random variate generation'\n     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 FUNCTION GENERATES A RANDOM NEGATIVE BINOMIAL VARIATE USING UNSTORED\n INVERSION AND/OR THE REPRODUCTIVE PROPERTY. SK = NUMBER OF FAILURES REQUIRED (Dagpunar's words!)\n   = the `power' parameter of the negative binomial\n       (0 < REAL)\nP = BERNOULLI SUCCESS PROBABILITY\n       (0 < REAL < 1) THE PARAMETER H IS SET SO THAT UNSTORED INVERSION ONLY IS USED WHEN P <= H,\n OTHERWISE A COMBINATION OF UNSTORED INVERSION AND\n THE REPRODUCTIVE PROPERTY IS USED. Local variables THE PARAMETER ULN = -LOG(MACHINE'S SMALLEST REAL NUMBER). Algorithm VMD from:\n Dagpunar, J.S. (1990) `Sampling from the von Mises distribution via a\n comparison of random numbers', J. of Appl. Statist., 17, 165-168.\n\n Fortran 90 code by Alan Miller\n CSIRO Division of Mathematical & Information Sciences\n\n Arguments:\n k (real)        parameter of the von Mises distribution.\n first (logical) set to .TRUE. the first time that the function\n                 is called, or the first time with a new value\n                 for k.   When first = .TRUE., the function sets\n                 up starting values and may be very much slower.\n\n\n\n\n\n Local variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Set up array p of probabilities.\n\n\n\n\n\n\n\n\n\n Numerical integration of e&#94;[k.cos(x)] from theta(j-1) to theta(j)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Gaussian integration of exp(k.cosx) from a to b.\n\n\n\n\n\n Local variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Generate a random deviate from the standard Cauchy distribution\n\n\n\n Local variables Used By module~~m_random~~UsedByGraph module~m_random m_random module~m_sort m_sort module~m_random->module~m_sort module~m_kdtree m_KdTree module~m_random->module~m_kdtree module~m_select m_select module~m_random->module~m_select module~m_sort->module~m_select module~m_idynamicarray m_iDynamicArray module~m_sort->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_sort->module~m_rdynamicarray module~m_maths m_maths module~m_sort->module~m_maths module~m_iddynamicarray m_idDynamicArray module~m_sort->module~m_iddynamicarray module~m_ddynamicarray m_dDynamicArray module~m_sort->module~m_ddynamicarray module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_idynamicarray->module~m_kdtree module~m_dargdynamicarray m_dArgDynamicArray module~m_idynamicarray->module~m_dargdynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_idynamicarray->module~m_idargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_idynamicarray->module~m_iargdynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_idynamicarray->module~m_rargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_maths->module~m_kdtree module~m_iddynamicarray->module~m_idargdynamicarray module~m_ddynamicarray->module~m_dargdynamicarray module~m_dargdynamicarray->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables isInitialized Interfaces setRNG rngChisq rngExponential rngGamma rngInteger rngNormal shuffle rngUniform rngWeibull Subroutines random_test Variables Type Visibility Attributes Name Initial logical, protected :: isInitialized = .false. Interfaces public interface setRNG Sets the random number with or without a seed private subroutine setRNG_Wseed(seed) Interfaced to setRNG()\n Sets the seed of the random number generator with a specified seed Arguments Type Intent Optional Attributes Name integer :: seed (:) private subroutine setRNG_WOseed(display) Interfaced to setRNG()\n 'Randomly' sets the seed of the random number generator Arguments Type Intent Optional Attributes Name logical :: display public interface rngChisq Pull from a Chi Ssquared distribution public subroutine rngChisq_d1(this, ndf, first) Interfaced with rngChisq Arguments Type Intent Optional Attributes Name real(kind=r64) :: this integer, intent(in) :: ndf logical, intent(in) :: first public subroutine rngChisq_d1D(this, ndf, first) Interfaced with rngChisq Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer, intent(in) :: ndf logical, intent(in) :: first public interface rngExponential public subroutine rngExponential_d1(this) Interfaced with rngExponential Arguments Type Intent Optional Attributes Name real(kind=r64) :: this Random number public subroutine rngExponential_d1D(this) Interfaced with rngExponential Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Random numbers public interface rngGamma public subroutine rngGamma_d1D(this, s, first) Interfaced with rngGamma Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) real(kind=r64), intent(in) :: s logical, intent(in) :: first public subroutine rngGamma_d1(this, s, first) Interfaced with rngGamma Arguments Type Intent Optional Attributes Name real(kind=r64) :: this real(kind=r64), intent(in) :: s logical, intent(in) :: first public interface rngInteger Generate size(this) random integers starting from imin public subroutine rngInteger_i1(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i1D(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i2D(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:,:) integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i3D(this, imin, imax) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:,:,:) integer(kind=i32), intent(in) :: imin integer(kind=i32), intent(in) :: imax public subroutine rngInteger_i1D_i1(this, imin) Interfaced with rngInteger Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) integer(kind=i32), intent(in) :: imin public interface rngNormal public subroutine rngNormal_d1(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public subroutine rngNormal_d1D(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public subroutine rngNormal_d2D(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:) real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public subroutine rngNormal_d3D(this, mean, std) Interfaced with rngNormal Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:,:) real(kind=r64), intent(in), optional :: mean real(kind=r64), intent(in), optional :: std public interface shuffle Perform Knuth shuffling on an array public subroutine shuffle_r1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) 1D array public subroutine shuffle_d1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) 1D array public subroutine shuffle_i1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) 1D array public subroutine shuffle_id1D(this) Interfaced with shuffle Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) 1D array public interface rngUniform public subroutine rngUniform_d1(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public subroutine rngUniform_d1D(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public subroutine rngUniform_d2D(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:) real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public subroutine rngUniform_d3D(this, rmin, rmax) Interfaced with rngUniform Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:,:,:) real(kind=r64), intent(in), optional :: rmin real(kind=r64), intent(in), optional :: rmax public interface rngWeibull public subroutine rngWeibull_d1(this, den) Interfaced with rngWeibull Arguments Type Intent Optional Attributes Name real(kind=r64) :: this Random number real(kind=r64), intent(in) :: den Weibull probability density public subroutine rngWeibull_d1D(this, den) Interfaced with rngWeibull Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Random numbers real(kind=r64), intent(in) :: den Weibull probability density Subroutines public subroutine random_test (test, fixedSeed) Arguments Type Intent Optional Attributes Name class( tester ) :: test logical :: fixedSeed","loc":"module/m_random.html","tags":""},{"title":"m_searching – Fortran Program","text":"Uses: variableKind module~~m_searching~~UsesGraph module~m_searching m_searching module~variablekind variableKind module~variablekind->module~m_searching iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains routines to perform a simple binary search on a vector Example usage program binarySearch_test use variableKind , only : i32 , r64 use m_BinarySearch , only : binarySearch implicit none real ( r64 ) :: arr ( 20 ) integer ( i32 ) :: i integer ( i32 ) :: j arr = [( dble ( i ), i = 1 , 20 )] j = binarySearch ( arr , 1 0.d0 , 1 , 20 ) write ( * , * ) 'Location of 10.0 in arr is 10? ' , j == 10 end program Perform a binary search but also return the neighbouring interval if the actual value is not found.\n This is useful if you need to find a number that is not contained in the array and you want the interval Example usage use variableKind use m_BinarySearch , only : intervalSearch real ( r64 ) :: arr ( 20 ) integer ( i32 ) :: i integer ( i32 ) :: j ( 3 ) arr = [( dble ( i ), i = 1 , 20 )] j = intervalSearch ( arr , 1 0.5d0 , 1 , 20 ) write ( * , * ) 'Location of 10.5 in arr is -1? ' , j ( 1 ) == - 1 write ( * , * ) 'The interval containing 10.5 is [10,11]? ' , j ( 2 : 3 ) == [ 10 , 11 ] Used By module~~m_searching~~UsedByGraph module~m_searching m_searching module~m_idynamicarray m_iDynamicArray module~m_searching->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_searching->module~m_rdynamicarray module~m_iddynamicarray m_idDynamicArray module~m_searching->module~m_iddynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_searching->module~m_rargdynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_searching->module~m_dargdynamicarray module~m_iargdynamicarray m_iArgDynamicArray module~m_searching->module~m_iargdynamicarray module~m_ddynamicarray m_dDynamicArray module~m_searching->module~m_ddynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_searching->module~m_idargdynamicarray module~m_idynamicarray->module~m_rargdynamicarray module~m_idynamicarray->module~m_dargdynamicarray module~m_idynamicarray->module~m_iargdynamicarray module~m_idynamicarray->module~m_idargdynamicarray module~m_kdtree m_KdTree module~m_idynamicarray->module~m_kdtree module~m_rdynamicarray->module~m_rargdynamicarray module~m_iddynamicarray->module~m_idargdynamicarray module~m_dargdynamicarray->module~m_kdtree module~m_ddynamicarray->module~m_dargdynamicarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces binarySearch intervalSearch simpleSearch Interfaces public interface binarySearch Perform a binary search.  See m_searching for more information on how to use this interface public recursive function binarySearch_i1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public recursive function binarySearch_id1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public recursive function binarySearch_r1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public recursive function binarySearch_d1D(this, v, imin, imax) result(iout) Search for the value i in an integer vector\n Assumes this is sorted! Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32) Location of i in this. Returns -1 if not present public interface intervalSearch Perform an interval search on an array\n Returns a length 3 integer(i32) array where the last two entries are the left and right neighbours\n The first entry of iout is -1 if the value is not present in the vector\n Assumes this is sorted!See m_searching for more information on how to use this interface public recursive function intervalSearch_i1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Vector to search within integer(kind=i32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public recursive function intervalSearch_id1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Vector to search within integer(kind=i64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public recursive function intervalSearch_r1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Vector to search within real(kind=r32) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public recursive function intervalSearch_d1D(this, v, imin, imax) result(iout) interfaced with intervalSearch Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Vector to search within real(kind=r64) :: v Number to find in the vector integer(kind=i32) :: imin Left integer integer(kind=i32) :: imax Right integer Return Value integer(kind=i32)\n  (3) Location of i in this. iout(1) = -1 if not present with iout(2-3) as the interval public interface simpleSearch Carry out a brute force search on an array for a given number. Returns -1 if the value is not found. public function simpleSearch_i1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) Search this vector integer(kind=i32) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this public function simpleSearch_id1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) Search this vector integer(kind=i64) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this public function simpleSearch_r1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) Search this vector real(kind=r32) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this public function simpleSearch_d1D(this, val) result(iout) Interfaced with simpleSearch Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) Search this vector real(kind=r64) :: val Number to find in the vector Return Value integer(kind=i32) Location of i in this","loc":"module/m_searching.html","tags":""},{"title":"m_medianOf3 – Fortran Program","text":"Uses: variableKind m_swap module~~m_medianof3~~UsesGraph module~m_medianof3 m_medianOf3 module~variablekind variableKind module~variablekind->module~m_medianof3 module~m_swap m_swap module~variablekind->module~m_swap module~m_swap->module~m_medianof3 iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Given three numbers, find their median and sort at the same time Interfaces medianOf3 argMedianOf3 Interfaces public interface medianOf3 Sort three numbers in an array and return the location of the median private subroutine medianOf3_r1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_d1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_i1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine medianOf3_id1D(this, left, mid, right) Interfaced with medianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right public interface argMedianOf3 Sort the indices of three numbers into an array and return the location of the median private subroutine argMedianOf3_r1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_d1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_i1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right private subroutine argMedianOf3_id1D(this, i, left, mid, right) Interfaced with argMedianOf3() Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) integer(kind=i32) :: i (:) integer(kind=i32) :: left integer(kind=i32) :: mid integer(kind=i32) :: right","loc":"module/m_medianof3.html","tags":""},{"title":"m_select – Fortran Program","text":"Uses: variableKind m_errors m_allocate m_array1D m_deallocate m_random m_sort m_unitTester module~~m_select~~UsesGraph module~m_select m_select module~m_unittester m_unitTester module~m_unittester->module~m_select module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_random m_random module~m_unittester->module~m_random module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_sort m_sort module~m_unittester->module~m_sort module~m_strings m_strings module~m_unittester->module~m_strings module~m_deallocate m_deallocate module~m_deallocate->module~m_select module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_deallocate->module~m_strings module~m_array1d->module~m_select module~m_array1d->module~m_random module~m_array1d->module~m_sort module~m_random->module~m_select module~m_random->module~m_sort module~m_allocate->module~m_select module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_allocate->module~m_sort module~m_allocate->module~m_strings module~m_sort->module~m_select module~m_errors m_errors module~m_errors->module~m_select module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_array1d module~m_errors->module~m_random module~m_errors->module~m_allocate module~m_errors->module~m_sort module~m_errors->module~m_strings module~variablekind variableKind module~variablekind->module~m_select module~variablekind->module~m_unittester module~variablekind->module~m_deallocate module~variablekind->module~m_array1d module~variablekind->module~m_random module~variablekind->module~m_allocate module~variablekind->module~m_sort module~variablekind->module~m_errors module~variablekind->module~m_strings module~m_parameters m_parameters module~variablekind->module~m_parameters iso_fortran_env iso_fortran_env iso_fortran_env->module~m_unittester iso_fortran_env->module~m_random iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_strings module~m_strings->module~m_random module~m_parameters->module~m_strings var panmodulem_selectUsesGraph = svgPanZoom('#modulem_selectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Perform a quickselect on an array. Quick select finds the kth smallest number in an array. It also puts values lower than the kth on the left, and those higher on the right\n This makes it perfect for finding the median. Used By module~~m_select~~UsedByGraph module~m_select m_select module~m_maths m_maths module~m_select->module~m_maths module~m_kdtree m_KdTree module~m_select->module~m_kdtree module~m_maths->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces select argSelect Subroutines select_test Interfaces public interface select Use an in-place quick select on an array of numbers public subroutine quickSelect_i1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res public subroutine quickSelect_id1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i64) :: res public subroutine quickSelect_r1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r32) :: res public subroutine quickSelect_d1D(this, k, res) Interfaced with select() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: this (:) Array to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element real(kind=r64) :: res public interface argSelect Use an indirect introspection sort on an array of numbers public subroutine argQuickSelect_i1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_id1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_r1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right public subroutine argQuickSelect_d1D(this, indx, k, res, left, right) Interfaced with argSelect() Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: this (:) 1D array integer(kind=i32), intent(inout) :: indx (:) Index to choose kth smallest from integer(kind=i32), intent(in) :: k kth smallest element integer(kind=i32) :: res Index of the kth smallest element integer(kind=i32), intent(in), optional :: left Select over the region left:right integer(kind=i32), intent(in), optional :: right Select over the region left:right Subroutines public subroutine select_test (test, N) Arguments Type Intent Optional Attributes Name class( tester ) :: test integer(kind=i32) :: N","loc":"module/m_select.html","tags":""},{"title":"m_sort – Fortran Program","text":"Uses: variableKind m_errors m_allocate m_array1D m_random m_unitTester module~~m_sort~~UsesGraph module~m_sort m_sort module~m_unittester m_unitTester module~m_unittester->module~m_sort module~m_array1d m_array1D module~m_unittester->module~m_array1d module~m_random m_random module~m_unittester->module~m_random module~m_allocate m_allocate module~m_unittester->module~m_allocate module~m_strings m_strings module~m_unittester->module~m_strings module~m_array1d->module~m_sort module~m_array1d->module~m_random module~m_random->module~m_sort module~m_allocate->module~m_sort module~m_allocate->module~m_array1d module~m_allocate->module~m_random module~m_allocate->module~m_strings module~m_errors m_errors module~m_errors->module~m_sort module~m_errors->module~m_unittester module~m_errors->module~m_array1d module~m_errors->module~m_random module~m_errors->module~m_allocate module~m_deallocate m_deallocate module~m_errors->module~m_deallocate module~m_errors->module~m_strings module~variablekind variableKind module~variablekind->module~m_sort module~variablekind->module~m_unittester module~variablekind->module~m_array1d module~variablekind->module~m_random module~variablekind->module~m_allocate module~variablekind->module~m_errors module~variablekind->module~m_deallocate module~variablekind->module~m_strings module~m_parameters m_parameters module~variablekind->module~m_parameters iso_fortran_env iso_fortran_env iso_fortran_env->module~m_unittester iso_fortran_env->module~m_random iso_fortran_env->module~m_errors iso_fortran_env->module~variablekind iso_fortran_env->module~m_strings module~m_deallocate->module~m_array1d module~m_deallocate->module~m_random module~m_deallocate->module~m_strings module~m_strings->module~m_random module~m_parameters->module~m_strings var panmodulem_sortUsesGraph = svgPanZoom('#modulem_sortUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module containing in-place and indirect routines to sort an array of numbers. Uses an introspective sort on a set of number. See this http://www.geeksforgeeks.org/know-your-sorting-algorithm-set-2-introsort-cs-sorting-weapon/ for more information To begin, a quicksort with a median of three pivot is used until the size of the array is less than 16.  At this point, an insertion sort is used to reduce cache overhead and tail recursion.\n Unfortunately, a quicksort is not ideal for sorted/almost sorted arrays or arrays with duplicate values.  Therefore if the number of iterations exceededs a threshold, a heapsort is used instead.\n This provides a robust sorting algorithm that is still very fast for almost sorted arrays. In this implementation, the quicksort and heapsort are unstable sorts. A stable merge sort is therefore provided as an alternative but it has an order(N) memory overhead. Often, the numbers wish to be maintained in their given order, so with an O(N) memory overhead we can sort an integer array instead by calling argsort() See sort and argSort for more information. Used By module~~m_sort~~UsedByGraph module~m_sort m_sort module~m_idynamicarray m_iDynamicArray module~m_sort->module~m_idynamicarray module~m_rdynamicarray m_rDynamicArray module~m_sort->module~m_rdynamicarray module~m_maths m_maths module~m_sort->module~m_maths module~m_select m_select module~m_sort->module~m_select module~m_iddynamicarray m_idDynamicArray module~m_sort->module~m_iddynamicarray module~m_ddynamicarray m_dDynamicArray module~m_sort->module~m_ddynamicarray module~m_dargdynamicarray m_dArgDynamicArray module~m_idynamicarray->module~m_dargdynamicarray module~m_idargdynamicarray m_idArgDynamicArray module~m_idynamicarray->module~m_idargdynamicarray module~m_kdtree m_KdTree module~m_idynamicarray->module~m_kdtree module~m_iargdynamicarray m_iArgDynamicArray module~m_idynamicarray->module~m_iargdynamicarray module~m_rargdynamicarray m_rArgDynamicArray module~m_idynamicarray->module~m_rargdynamicarray module~m_rdynamicarray->module~m_rargdynamicarray module~m_maths->module~m_kdtree module~m_select->module~m_maths module~m_select->module~m_kdtree module~m_iddynamicarray->module~m_idargdynamicarray module~m_ddynamicarray->module~m_dargdynamicarray module~m_dargdynamicarray->module~m_kdtree Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces sort argSort insertionsort argInsertionsort Subroutines sorting_test Interfaces public interface sort Use an in-place introspection sort on an array of numbers public subroutine sort_i1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) logical, optional :: stable public subroutine sort_id1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) logical, optional :: stable public subroutine sort_r1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) logical, optional :: stable public subroutine sort_d1D(this, stable) Interfaced with sort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) logical, optional :: stable public interface argSort Use an indirect introspection sort on an array of numbers public subroutine argSort_i1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_id1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_r1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public subroutine argSort_d1D(this, i, stable) Interfaced with argSort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: i (:) Index to sort logical, optional :: stable Stable sort? public interface insertionsort Perform an in-place insertion sort on an array public subroutine insertionsort_r1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_d1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_i1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine insertionsort_id1D(this, iLeft, iRight) Interfaced with insertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public interface argInsertionsort Perform an indirect insertion sort on an array public subroutine argInsertionsort_r1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_d1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name real(kind=r64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_i1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i32) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index public subroutine argInsertionsort_id1D(this, indx, iLeft, iRight) Interfaced with argInsertionsort Arguments Type Intent Optional Attributes Name integer(kind=i64) :: this (:) 1D array integer(kind=i32) :: indx (:) Sort this integer key integer(kind=i32) :: iLeft Left index integer(kind=i32) :: iRight Right index Subroutines public subroutine sorting_test (test, N) Arguments Type Intent Optional Attributes Name class( tester ) :: test integer(kind=i32) :: N","loc":"module/m_sort.html","tags":""},{"title":"m_KdTree – Fortran Program","text":"Uses: variableKind m_errors m_allocate m_deallocate m_array1D m_random m_select m_maths m_iDynamicArray m_dArgDynamicArray m_strings module~~m_kdtree~~UsesGraph module~m_kdtree m_KdTree module~m_strings m_strings module~m_strings->module~m_kdtree module~m_idynamicarray m_iDynamicArray module~m_strings->module~m_idynamicarray module~m_random m_random module~m_strings->module~m_random module~m_dargdynamicarray m_dArgDynamicArray module~m_strings->module~m_dargdynamicarray module~m_ddynamicarray m_dDynamicArray module~m_strings->module~m_ddynamicarray module~m_idynamicarray->module~m_kdtree module~m_idynamicarray->module~m_dargdynamicarray module~m_deallocate m_deallocate module~m_deallocate->module~m_kdtree module~m_deallocate->module~m_strings module~m_deallocate->module~m_idynamicarray module~m_array1d m_array1D module~m_deallocate->module~m_array1d module~m_maths m_maths module~m_deallocate->module~m_maths module~m_deallocate->module~m_random module~m_select m_select module~m_deallocate->module~m_select module~m_deallocate->module~m_ddynamicarray module~m_array1d->module~m_kdtree module~m_array1d->module~m_maths module~m_array1d->module~m_random module~m_array1d->module~m_select module~m_sort m_sort module~m_array1d->module~m_sort module~m_maths->module~m_kdtree module~m_random->module~m_kdtree module~m_random->module~m_select module~m_random->module~m_sort module~m_allocate m_allocate module~m_allocate->module~m_kdtree module~m_allocate->module~m_strings module~m_allocate->module~m_idynamicarray module~m_allocate->module~m_array1d module~m_allocate->module~m_maths module~m_allocate->module~m_random module~m_allocate->module~m_select module~m_reallocate m_reallocate module~m_allocate->module~m_reallocate module~m_allocate->module~m_sort module~m_allocate->module~m_ddynamicarray module~m_errors m_errors module~m_errors->module~m_kdtree module~m_errors->module~m_strings module~m_errors->module~m_idynamicarray module~m_errors->module~m_deallocate module~m_errors->module~m_array1d module~m_errors->module~m_maths module~m_errors->module~m_random module~m_errors->module~m_allocate module~m_errors->module~m_select module~m_errors->module~m_dargdynamicarray module~m_unittester m_unitTester module~m_errors->module~m_unittester module~m_errors->module~m_reallocate module~m_errors->module~m_sort module~m_errors->module~m_ddynamicarray module~m_select->module~m_kdtree module~m_select->module~m_maths module~m_dargdynamicarray->module~m_kdtree module~variablekind variableKind module~variablekind->module~m_kdtree module~variablekind->module~m_strings module~variablekind->module~m_idynamicarray module~variablekind->module~m_deallocate module~variablekind->module~m_array1d module~variablekind->module~m_maths module~variablekind->module~m_random module~variablekind->module~m_allocate module~variablekind->module~m_errors module~variablekind->module~m_select module~variablekind->module~m_dargdynamicarray module~m_parameters m_parameters module~variablekind->module~m_parameters module~variablekind->module~m_unittester module~m_searching m_searching module~variablekind->module~m_searching module~variablekind->module~m_reallocate module~variablekind->module~m_sort module~variablekind->module~m_ddynamicarray module~m_parameters->module~m_strings module~m_unittester->module~m_strings module~m_unittester->module~m_idynamicarray module~m_unittester->module~m_array1d module~m_unittester->module~m_maths module~m_unittester->module~m_random module~m_unittester->module~m_allocate module~m_unittester->module~m_select module~m_unittester->module~m_dargdynamicarray module~m_unittester->module~m_reallocate module~m_unittester->module~m_sort module~m_unittester->module~m_ddynamicarray iso_fortran_env iso_fortran_env iso_fortran_env->module~m_strings iso_fortran_env->module~m_random iso_fortran_env->module~m_errors iso_fortran_env->module~m_dargdynamicarray iso_fortran_env->module~variablekind iso_fortran_env->module~m_unittester module~m_searching->module~m_idynamicarray module~m_searching->module~m_dargdynamicarray module~m_searching->module~m_ddynamicarray module~m_reallocate->module~m_idynamicarray module~m_reallocate->module~m_ddynamicarray module~m_sort->module~m_idynamicarray module~m_sort->module~m_maths module~m_sort->module~m_select module~m_sort->module~m_ddynamicarray module~m_ddynamicarray->module~m_dargdynamicarray var panmodulem_kdtreeUsesGraph = svgPanZoom('#modulem_kdtreeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. KdTree Build and search k-dimensional trees in 2, 3, and K dimensions.\nThis KdTree is balanced, in that splits are made along the dimension with the largest variance. \nA quickselect is used to quickly find the median in each splitting dimension as the splitting value.\nThe ends of each branch contain multiple leaves to prevent tail recursion.\nAn in-depth example is given below on how to use all the aspects of the KdTree and KdTreeSearch classes. Important: Once a tree has been built with a set, do not change their values.  The KdTree does NOT make\na copy of the input values used to build it.\nImportant: Generating the tree does not modify the values used to build it. Building the KdTree The KdTree object can be initialized on assignment by entering point co-ordinates.\nTo build a 2-D tree, you can use two 1-D arrays as the x, y, co-ordinates, and optionally a third 1-D array\nto build a 3-D tree. use m_KdTree type ( KdTree ) :: tree tree = KdTree ( x , y , [ z ]) Or you can build a k-dimensional tree using a 2-D array, where the first dimension is the number of items,\nand the second is the number of dimensions, k. use m_KdTree type ( KdTree ) :: tree tree = KdTree ( D ) Querying the KdTree After the tree is initialized, a search class can be used to perform search for the nearest neighbour, \nthe k nearest neighbours, all neighbours within a radius, k nearest within a radius, and items within \nupper and lower bounds in each dimension.\nThe searches are thread safe and can be used in a parallel region. After the KdTree is built, various queries can be carried out.  Searches that return multiple values\nare called using the argDynamicArray within coretran. The m_dArgDynamicArray contains an integer index\ncontaining the indices into the co-ordinates that are closest, and a double precision that contains the\ndistance from the query point to those points. use m_dArgDynamicArray use m_KdTree type ( KdTreeSearch ) :: search integer ( i32 ) :: i type ( dArgDynamicArray ) :: da ! Nearest Neighbour to (0, 0), for 3D add z, and zQuery i = search % nearest ( tree , x , y , [ z ], xQuery = 0.d0 , yQuery = 0.d0 , [ zQuery = 0.d0 ]) ! K-Nearest to (0, 0), for 3D add z, and zQuery da = search % kNearest ( tree , x , y , [ z ], xQuery = 0.d0 , yQuery = 0.d0 , [ zQuery = 0.d0 ], k = 10 ) ! Search for all points within a given distance da = search % kNearest ( tree , x , y , [ z ], xQuery = 0.d0 , yQuery = 0.d0 , [ zQuery = 0.d0 ], radius = 1 0.d0 ) ! Search for all k points within a given distance da = search % kNearest ( tree , x , y , [ z ], xQuery = 0.d0 , yQuery = 0.d0 , [ zQuery = 0.d0 ], k = 10 , radius = 1 0.d0 ) Full Example program kdTree_test use variableKind , only : i32 , r64 use m_allocate , only : allocate use m_deallocate , only : deallocate use m_random , only : rngNormal use m_KdTree , only : KdTree , KdTreeSearch use m_dArgDynamicArray , only : dArgDynamicArray use m_string , only : str implicit none real ( r64 ), allocatable :: x (:), y (:), z (:), D (:,:) integer ( i32 ) :: ia , N type ( KdTree ) :: tree type ( KdSearch ) :: search type ( dArgDynamicArray ) :: da !====================================================================! ! 2D KdTree example !====================================================================! ! Create some random points in space N = 1 d6 call allocate ( x , N ) call allocate ( y , N ) call rngNormal ( x ) call rngNormal ( y ) ! Build the tree tree = KdTree ( x , y ) ! Get the nearest neighbour to (0, 0) ia = search % kNearest ( tree , x , y , xQuery = 0.d0 , yQuery = 0.d0 ) write ( * , '(a)' ) 'Nearest point to the query location: ' // str ( x ( ia )) // str ( y ( ia )) ! Get the 10 nearest neighbours to the query da = search % kNearest ( tree , x , y , xQuery = 0.d0 , yQuery = 0.d0 , k = 10 ) write ( * , '(a)' ) 'The 10 nearest neighbour indices and distances:' call da % print () ! Find all the points within a 1.d0 da = search % kNearest ( tree , x , y , xQuery = 0.d0 , yQuery = 0.d0 , radius = 1.d0 ) write ( * , '(a)' ) 'The points within a distance of 1.d0' call da % print () Deallocate any tree memory call tree % deallocate () !====================================================================! ! 3D KdTree example !====================================================================! ! Create the third dimension call allocate ( z , N ) call rngNormal ( z ) ! Build the tree tree = KdTree ( x , y , z ) ! Get the nearest neighbour to (0, 0, 0) ia = search % kNearest ( tree , x , y , z , xQuery = 0.d0 , yQuery = 0.d0 , zQuery = 0.d0 ) write ( * , '(a)' ) 'Nearest point to the query location: ' // str ( x ( ia )) // str ( y ( ia )) // str ( z ( ia )) ! Get the 10 nearest neighbours to the query da = search % kNearest ( tree , x , y , z , xQuery = 0.d0 , yQuery = 0.d0 , zQuery = 0.d0 , k = 10 ) write ( * , '(a)' ) 'The 10 nearest neighbour indices and distances:' call da % print () ! Find all the points within a 1.d0 da = search % kNearest ( tree , x , y , z , xQuery = 0.d0 , yQuery = 0.d0 , zQuery = 0.d0 , radius = 1.d0 ) write ( * , '(a)' ) 'The points within a distance of 1.d0' call da % print () Deallocate any tree memory call tree % deallocate () !====================================================================! ! KD KdTree example !====================================================================! call allocate ( D , [ N , 3 ]) D (:, 1 ) = x D (:, 2 ) = y D (:, 3 ) = z ! Build the tree tree = KdTree ( D ) ! Get the nearest neighbour to (0, 0, 0) ia = search % kNearest ( tree , D , query = [ 0.d0 , 0.d0 , 0.d0 ]) write ( * , '(a)' ) 'Nearest point to the query location: ' // str ( D ( ia , 1 )) // str ( D ( ia , 2 )) // str ( D ( ia , 3 )) ! Get the 10 nearest neighbours to the query da = search % kNearest ( tree , D , query = [ 0.d0 , 0.d0 , 0.d0 ], k = 10 ) write ( * , '(a)' ) 'The 10 nearest neighbour indices and distances:' call da % print () ! Find all the points within a 1.d0 da = search % kNearest ( tree , D , query = [ 0.d0 , 0.d0 , 0.d0 ], radius = 1.d0 ) write ( * , '(a)' ) 'The points within a distance of 1.d0' call da % print () Deallocate any tree memory call tree % deallocate () call deallocate ( x ) call deallocate ( y ) call deallocate ( z ) call deallocate ( D ) end program Interfaces KdTree Derived Types KdTree KdTreeSearch Interfaces public interface KdTree Overloaded Initializer for a KdTree. public function init2D_KdTree(x, y) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) x-coordinates of the points real(kind=r64), intent(in) :: y (:) y-coordinates of the points Return Value type( KdTree ) KdTree Class public function init3D_KdTree(x, y, z) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) x-coordinates of the points real(kind=r64), intent(in) :: y (:) y-coordinates of the points real(kind=r64), intent(in) :: z (:) z-coordinates of the points Return Value type( KdTree ) KdTree Class public function initKD_KdTree(D) result(this) Overloaded by interface KdTree Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: D (:,:) Coordinates of the points, the k columns contain the k dimensional values. Return Value type( KdTree ) KdTree Class Derived Types type, public :: KdTree KdTree in 2, 3, or N dimensions.  See m_KdTree for more information on how to use this class. Constructor Overloaded Initializer for a KdTree. public  function init2D_KdTree (x, y) Overloaded by interface KdTree public  function init3D_KdTree (x, y, z) Overloaded by interface KdTree public  function initKD_KdTree (D) Overloaded by interface KdTree Type-Bound Procedures procedure, public :: deallocate => deallocate_KdTree kdTree%deallocate() - deallocate the recursive pointers type, public :: KdTreeSearch Class to search a KdTree.  See m_KdTree for more information on how to use this class. Type-Bound Procedures generic, public :: nearest => nearest2D, nearest3D, nearestKD KdTreeSearch%nearest() - Perform a nearest neighbour search generic, public :: kNearest => kNearest2D, kNearest3D, kNearestKD KdTreeSearch%kNearest() - Perform a k nearest neighbour search or a radius search. generic, public :: rangeSearch => rangeSearch2D, rangeSearch3D, rangeSearchKD KdTreeSearch%rangeSearch() - Find all points within axis aligned lower and upper bounds","loc":"module/m_kdtree.html","tags":""},{"title":"m_time – Fortran Program","text":"Uses: variableKind m_errors m_unitTester module~~m_time~~UsesGraph module~m_time m_time module~variablekind variableKind module~variablekind->module~m_time module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_errors->module~m_time module~m_errors->module~m_unittester module~m_unittester->module~m_time iso_fortran_env iso_fortran_env iso_fortran_env->module~variablekind iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains functions that handle time Used By module~~m_time~~UsedByGraph module~m_time m_time module~stopwatch_class Stopwatch_Class module~m_time->module~stopwatch_class module~progressbar_class ProgressBar_Class module~m_time->module~progressbar_class module~stopwatch_class->module~progressbar_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions timeinseconds daysinMonth daysinYear isLeapYear absTimetoHMS Subroutines time_test Functions public function timeinseconds (values) result(res) Convert hours minutes seconds etc. to seconds Arguments Type Intent Optional Attributes Name integer(kind=i32) :: values (8) values containing amounts of days hours etc. Return Value real(kind=r64) time in seconds public function daysinMonth (month, year) result(days) Get the number of days in a month. Accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: month How many days in this month integer(kind=i32), optional :: year Check if a leap year? Return Value integer(kind=i32) Number of days public function daysinYear (year) result(days) Get the number of days in a year, accounts for leap years Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year How many days in this year Return Value integer(kind=i32) Number of days public function isLeapYear (year) result(yes) Determine whether the year is a leap year Arguments Type Intent Optional Attributes Name integer(kind=i32) :: year Year to check Return Value logical is a leap year public function absTimetoHMS (t) result(res) Convert an absolute time to HH:MM:SS.MSEC Arguments Type Intent Optional Attributes Name real(kind=r64) :: t Time in seconds Return Value character(len=22) Resulting string contains the time Subroutines public subroutine time_test (test) Arguments Type Intent Optional Attributes Name class( tester ) :: test","loc":"module/m_time.html","tags":""},{"title":"ProgressBar_Class – Fortran Program","text":"Uses: iso_fortran_env variableKind Stopwatch_Class m_time module~~progressbar_class~~UsesGraph module~progressbar_class ProgressBar_Class module~m_time m_time module~m_time->module~progressbar_class module~stopwatch_class Stopwatch_Class module~m_time->module~stopwatch_class module~variablekind variableKind module~variablekind->module~progressbar_class module~variablekind->module~m_time module~variablekind->module~stopwatch_class module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_strings m_strings module~variablekind->module~m_strings module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_allocate m_allocate module~variablekind->module~m_allocate module~stopwatch_class->module~progressbar_class iso_fortran_env iso_fortran_env iso_fortran_env->module~progressbar_class iso_fortran_env->module~variablekind iso_fortran_env->module~stopwatch_class iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester iso_fortran_env->module~m_strings module~m_errors->module~m_time module~m_errors->module~m_unittester module~m_errors->module~m_strings module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_unittester->module~m_time module~m_unittester->module~m_strings module~m_unittester->module~m_allocate module~m_strings->module~stopwatch_class module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_allocate->module~m_strings var panmoduleprogressbar_classUsesGraph = svgPanZoom('#moduleprogressbar_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. An inline and updateable command prompt progress bar Example usage use variableKind use ProgressBar_Class type ( ProgressBar ) :: P integer ( i32 ) :: i , N N = 100000 call P % set ( N , time = . false .) call P % print ( 0 ) do i = 1 , N Compute some stuff call P % print ( i ) enddo call P % set ( N , time = . true .) call P % print ( 0 ) do i = 1 , N Compute some stuff call P % print ( i ) enddo Interfaces ProgressBar Derived Types ProgressBar Interfaces public interface ProgressBar private function ProgressBar_i1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) private function ProgressBar_id1(N, title, time) result(res) Interfaced with class instantiation ProgressBar() Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: N Maximum expected number of iterations character(len=*), intent(in), optional :: title Title to give the progress bar logical, intent(in), optional :: time Show an estimated time to completion? Return Value type( ProgressBar ) Derived Types type, public :: ProgressBar A progress bar that displays a moving counter with percentage and optional estimated time remaining\n Print the progress Bar Constructor private  function ProgressBar_i1 (N, title, time) Interfaced with class instantiation ProgressBar() private  function ProgressBar_id1 (N, title, time) Interfaced with class instantiation ProgressBar() Type-Bound Procedures generic, public :: print => print_i1_ProgressBar_, print_id1_ProgressBar_ Print the progress Bar","loc":"module/progressbar_class.html","tags":""},{"title":"Stopwatch_Class – Fortran Program","text":"Uses: iso_fortran_env variableKind m_strings m_time module~~stopwatch_class~~UsesGraph module~stopwatch_class Stopwatch_Class module~m_time m_time module~m_time->module~stopwatch_class module~variablekind variableKind module~variablekind->module~stopwatch_class module~variablekind->module~m_time module~m_strings m_strings module~variablekind->module~m_strings module~m_errors m_errors module~variablekind->module~m_errors module~m_unittester m_unitTester module~variablekind->module~m_unittester module~m_parameters m_parameters module~variablekind->module~m_parameters module~m_deallocate m_deallocate module~variablekind->module~m_deallocate module~m_allocate m_allocate module~variablekind->module~m_allocate module~m_strings->module~stopwatch_class iso_fortran_env iso_fortran_env iso_fortran_env->module~stopwatch_class iso_fortran_env->module~variablekind iso_fortran_env->module~m_strings iso_fortran_env->module~m_errors iso_fortran_env->module~m_unittester module~m_errors->module~m_time module~m_errors->module~m_strings module~m_errors->module~m_unittester module~m_errors->module~m_deallocate module~m_errors->module~m_allocate module~m_unittester->module~m_time module~m_unittester->module~m_strings module~m_unittester->module~m_allocate module~m_parameters->module~m_strings module~m_deallocate->module~m_strings module~m_allocate->module~m_strings var panmodulestopwatch_classUsesGraph = svgPanZoom('#modulestopwatch_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Contains code timing capabilities Example usage program stopwatch_test use variableKind , only : i32 use Stopwatch_Class , only : Stopwatch type ( Stopwatch ) :: clk integer ( i32 ) :: i , N call clk % start ( 'Some Title' ) N = 100000 do i = 1 , N Compute some stuff enddo call clk % stop () call clk % elapsed () write ( * , '(a)' ) 'Finished on ' // clk % datetime () end program Used By module~~stopwatch_class~~UsedByGraph module~stopwatch_class Stopwatch_Class module~progressbar_class ProgressBar_Class module~stopwatch_class->module~progressbar_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types Stopwatch Derived Types type, public :: Stopwatch Class for timing sections of code, See the Stopwatch_Class module documentation for usage. Type-Bound Procedures procedure, public :: start => start_Stopwatch Start the Stopwatch procedure, public :: stop => stop_Stopwatch Stop the Stopwatch procedure, public :: reset => reset_Stopwatch Reset the Stopwatch procedure, public :: restart => restart_Stopwatch Restart the Stopwatch procedure, public :: time => time_Stopwatch Get the current or stopped time procedure, public :: lap => lap_Stopwatch Lap the Stopwatch procedure, public :: lapInSeconds => lapInSeconds_Stopwatch Get the lap time in seconds procedure, public :: elapsed => elapsed_Stopwatch Get the current elapsed time procedure, public :: elapsedInSeconds => elapsedInSeconds_Stopwatch Get the elapsed time in seconds procedure, public :: date => date_Stopwatch Print the date procedure, public :: dateAndTime => dateAndTime_Stopwatch Print the date and time","loc":"module/stopwatch_class.html","tags":""}]}